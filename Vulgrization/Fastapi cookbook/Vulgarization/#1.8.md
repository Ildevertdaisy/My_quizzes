#1

FastAPI, c’est comme un chef d’orchestre 🎵 qui fait parler l’appli avec les gens 📱💬. Par exemple, si quelqu’un veut ajouter un jeu vidéo dans une bibliothèque, il envoie des infos (comme le nom du jeu ou l’année de sortie). FastAPI vérifie que tout est bien rempli avant de dire oui.

### 📦 Les "modèles" pour vérifier les données

FastAPI utilise **Pydantic** (une boîte magique pour bien ranger et vérifier les infos). C’est comme un filtre ou une règle du jeu 🎯 : si les infos envoyées ne sont pas correctes, FastAPI dit non tout de suite 🚫.

### 🎮 Exemple d’appli : une boutique de jeux en ligne

Imagine une boutique où tu peux acheter des jeux 🎮. Quand tu veux en commander un, tu remplis un petit formulaire avec :

- **Le nom du jeu** (ex : "Super Aventure 3")
- **La plateforme** (ex : "Nintendo Switch")

Si tu écris "vingt-neuf euros" au lieu de "29.99", FastAPI voit l’erreur et t’envoie un message 📢 : "Le prix doit être un chiffre, pas des mots !" C’est comme un vendeur qui vérifie ta commande et te corrige gentiment.

### ❌ Que fait FastAPI en cas d’erreur ?

Si les infos ne respectent pas les règles, FastAPI renvoie une erreur tout seul 🛑.
Par exemple :

- Tu veux ajouter une tâche 📋
- Tu écris "Faire les courses" mais tu oublies la date 🗓️
- FastAPI dit : "Erreur ❌ : il manque la date !"

C’est comme quand tu oublies un truc dans un formulaire en ligne ✍️. Le site te montre un message rouge 🚦 : "Remplis ce champ avant de continuer !"

### 🎵 Exemple avec une appli de musique

Tu as une appli pour créer des playlists 🎧. Pour ajouter une chanson, tu donnes :

- Le **titre** 🎶
- L’**artiste** 🎤
- La **durée** en minutes ⏳

Si tu ajoutes une chanson sans la durée, FastAPI dit : "Oups, il manque la durée !" ⏳❌
C’est comme vouloir mettre une musique sans le son 🎵❌.

### 📊 Pourquoi c’est utile ?

FastAPI vérifie les infos tout seul pour éviter les erreurs. C’est comme un gardien de porte 🚪 : il laisse passer seulement les bonnes infos et bloque celles qui sont fausses ou incomplètes 🚧🔍.

En résumé, FastAPI avec Pydantic, c’est comme un prof 📖✅ : il vérifie ton exercice. S’il manque un truc ou si c’est mal écrit, il te dit : "Corrige et recommence !" 😊

#2

---

### 📢 Personnaliser les erreurs dans FastAPI

Dans une appli de **livraison de repas 🍕**, si quelqu’un oublie son adresse ou met trop de chiffres dans son numéro, FastAPI doit lui dire qu’il y a un problème.

FastAPI peut montrer un message spécial quand quelque chose ne va pas. Il gère les erreurs et explique ce qu’il faut corriger, comme dans l’exemple de code juste en dessous !

---

### 📝 **Le code expliqué avec des mots simples**

```python
import json
from fastapi import Request, status
from fastapi.exceptions import RequestValidationError
from fastapi.responses import PlainTextResponse
```

📌 **Que fait cette partie ?**

- **`import json`** → On utilise une boîte à outils appelée **json** (elle sert à ranger les infos en texte que la machine peut comprendre).

- **`from fastapi import Request, status`** → On prend deux outils de FastAPI :
  - **`Request`** : comme un facteur 📬 qui apporte ce que l’utilisateur envoie.
  - **`status`** : une liste de codes pour dire si tout va bien ✅ ou s’il y a une erreur ❌.
- **`from fastapi.exceptions import RequestValidationError`** → C’est un outil qui repère si les infos envoyées ne suivent pas les règles.
- **`from fastapi.responses import PlainTextResponse`** → C’est une réponse en **texte brut**, comme un message SMS tout simple 📩.

---

### 🔧 **Création d’un gestionnaire d’erreur**

```python
@app.exception_handler(RequestValidationError)
async def validation_exception_handler(
    request: Request,
    exc: RequestValidationError
):
```

📌 **Que fait cette partie ?**

- **`@app.exception_handler(RequestValidationError)`** → Ça veut dire : **"Hé FastAPI, s’il y a une erreur, utilise cette fonction pour t’en occuper !"** 🛠️
- **`async def validation_exception_handler(request: Request, exc: RequestValidationError):`**
  - **`async def`** → La fonction peut attendre sans bloquer tout le reste, comme un cuisinier 👨‍🍳 qui prépare plusieurs plats en même temps.
- **`request: Request`** → C’est la demande de l’utilisateur (ex : "Je veux une pizza 🍕 !").
- **`exc: RequestValidationError`** → C’est l’erreur repérée (ex : "Tu as oublié l’adresse !").

---

### 📄 **Créer une réponse claire pour l’utilisateur**

```python
    return PlainTextResponse(
        "This is a plain text response:"
        f" \n{json.dumps(exc.errors(), indent=2)}",
        status_code=status.HTTP_400_BAD_REQUEST,
    )
```

📌 **Que fait cette partie ?**

- **`return PlainTextResponse(...`** → On envoie un message tout simple pour expliquer l’erreur.
- **`"This is a plain text response:"`** → C’est le début du message qui dit : "Voici l’erreur en version texte".
- **`json.dumps(exc.errors(), indent=2)`** →
  - **`exc.errors()`** → Donne les détails de l’erreur (ex : "Adresse manquante !").
  - **`json.dumps(..., indent=2)`** → Range les infos pour que ce soit bien lisible (comme des notes dans un cahier 📖).
- **`status_code=status.HTTP_400_BAD_REQUEST`** →
  - **`HTTP_400_BAD_REQUEST`** → C’est le code qui veut dire : **"Erreur 400 : infos incorrectes !"** 🚫.

---

### 🎮 Exemple avec une appli de jeux

Tu peux ajouter des **personnages** dans ton jeu 🎮. Pour en créer un, tu donnes :
✅ Son **nom** (ex : "Super Guerrier")
✅ Sa **force** (ex : 95)
✅ Son **niveau** (ex : 10)

Si tu oublies la force ou écris "fort" au lieu d’un chiffre, l’appli montre :
🛑 **"Erreur 400 : La force doit être un nombre !"**

C’est exactement ce que fait FastAPI : il repère les infos incorrectes et envoie un message clair pour corriger l’erreur.

---

### 📌 En résumé : pourquoi c’est utile ?

✔️ **FastAPI repère les erreurs tout seul** pour éviter que l’appli ne plante.
✔️ **On peut changer le message d’erreur** pour qu’il soit plus clair.
✔️ **Les utilisateurs comprennent vite ce qui ne va pas**.

C’est comme un agent de cinéma 🍿 qui dit : "Oups, ton billet c’est pour demain !" au lieu de te laisser entrer.

Grâce à ça, l’appli est **plus solide et plus facile à utiliser** 🚀 !

#3

Dans une appli de **réservation de train 🚆**, la personne doit donner :
✅ Son nom et prénom
✅ La date du voyage 📅
✅ Le nombre de places à acheter

Si ces infos ne sont pas bonnes, FastAPI peut le repérer.

Si quelqu’un réserve sans mettre la date ou écrit "deux" au lieu de **2**, l’appli ne comprend pas 🛑.

FastAPI détecte ces erreurs **automatiquement**, et on peut même lui dire **quoi répondre** quand ça arrive !

---

### 🎯 Que fait ce gestionnaire d’erreur ?

**RequestValidationError**, c’est comme un **inspecteur 📋** qui vérifie si tout est bien rempli.
S’il trouve une erreur, le gestionnaire l’attrape et envoie un message clair à l’utilisateur.

C’est comme un guichetier de train qui dit :
🚫 **"Tu as oublié la date du voyage. Remplis-la avant de continuer !"**

Et la réponse s’affiche en **texte simple** (PlainTextResponse), comme un petit **SMS ou ticket 🧾** qui explique clairement l’erreur.

---

### 🏀 Exemple avec une appli de sport

Tu veux réserver un terrain de foot ⚽ ou de basket 🏀 ?
Tu dois donner :

- Ton **nom**
- La **date et l’heure ⏰**
- Le **nombre de joueurs** présents

Si quelqu’un oublie l’heure ou écrit un mot au lieu d’un nombre, FastAPI bloque et montre :
🔴 **"Erreur : il manque l’heure de la réservation"**

C’est super utile pour éviter des réservations incomplètes ou fausses !

---

### 📌 Pourquoi c’est important ?

✔️ **Moins d’erreurs** : Les gens voient vite ce qu’ils doivent corriger.
✔️ **Moins de travail pour les développeurs** : FastAPI s’en occupe tout seul.
✔️ **L’appli est plus agréable** : Un bon message aide à corriger sans se fâcher 😊.

En résumé, FastAPI est comme un **agent de contrôle 🚦** : il bloque les mauvaises infos et explique **ce qu’il faut corriger** avant de continuer 🚀.

#4

### 🚀 Quand FastAPI attrape une erreur

Dans une appli pour gérer ta bibliothèque 📚, tu veux ajouter un livre. Tu dois remplir :
✅ Le **titre** (ex : "Les aventures magiques")
✅ L’**auteur** (ex : "Alice Dupont")
✅ L’**année** (ex : 2022)

Si une info est mauvaise, FastAPI le voit et envoie un message clair.

Si tu fais une erreur, comme :

- Mettre un **chiffre à la place du titre** (ex : `3` au lieu de `"Harry Potter"`)
- Mettre une **année bizarre** comme `0`

FastAPI repère l’erreur tout de suite et refuse d’enregistrer le livre 📛.

---

### 🔎 Comment FastAPI détecte l’erreur ?

Si une info est fausse, l’appli envoie une **erreur avec le code `400`**, ce qui veut dire **"Mauvaise demande"** ❌.

Dans le message d’erreur, on voit plusieurs détails importants :

#### 📌 **Erreur sur le titre du livre**

```
"type": "string_type"
"loc": ["body", "author"]
"msg": "Input should be a valid string"
"input": 3
```

- **"type": "string_type"** → FastAPI attendait **un texte** ("string"), mais il a reçu **un nombre** à la place.

- **"loc": \["body", "author"]** → Ça montre où est l’erreur : dans le **corps de la demande**, à l’endroit de **l’auteur**.
- **"msg": "Input should be a valid string"** → Le message dit que l’entrée doit être une **phrase**, pas un **chiffre**.
- **"input": 3** → C’est la **mauvaise valeur** envoyée.

🛑 **Exemple avec une appli d’hôtel 🏨**
Tu veux réserver une chambre et tu mets `42` au lieu de `"Alice"` pour le nom.
L’appli te répond : **"Erreur : le nom doit être un texte, pas un nombre !"**

---

#### 📌 **Erreur sur l’année de publication**

```
"type": "greater_than"
"loc": ["body", "year"]
"msg": "Input should be greater than 1900"
"input": 0
"ctx": { "gt": 1900 }
```

- **"type": "greater_than"** → FastAPI voulait une **année après 1900**, mais la valeur était trop petite.
- **"loc": \["body", "year"]** → L’erreur vient du champ **année** (`year`).
- **"msg": "Input should be greater than 1900"** → L’année doit être **plus grande que 1900**.
- **"input": 0** → L’utilisateur a mis `0`, ce qui est faux.
- **"ctx": { "gt": 1900 }** → FastAPI rappelle que la valeur attendue est **après 1900**.

📅 **Exemple avec une appli de location de voitures 🚗**
Tu écris l’année de naissance du conducteur et tu mets `1800` ?
L’appli te répond : **"Erreur : l’année doit être plus grande que 1900 !"**

---

### ✅ Pourquoi c’est important ?

✔️ **FastAPI bloque les erreurs avant qu’elles fassent des dégâts**.
✔️ **Les messages d’erreur sont clairs**, donc faciles à corriger.
✔️ **Pas de mauvaises infos** dans la base de données.

C’est comme un **agent de sécurité 🔍** qui vérifie tout avant de laisser passer. Résultat : une appli plus fiable 🚀 !

#5

### 🔒 Pourquoi cacher les messages d’erreur peut être utile ?

Parfois, dire **trop de détails** sur une erreur peut être **dangereux**.

Exemple : dans une appli bancaire 🏦, si quelqu’un met un mauvais mot de passe, il ne faut pas dire :
🚫 **"Ce mot de passe ne correspond pas à Paul123"**

Sinon, quelqu’un pourrait deviner des infos secrètes.

Le problème ? 🤔 Ça donne trop d’infos à un pirate qui pourrait deviner le bon mot de passe 🔓.

FastAPI peut **cacher les détails** dans les messages d’erreur.
C’est comme un magasin de jouets 🎁 qui ne dit pas combien de consoles il lui reste, pour éviter les voleurs.

---

### 🛠 Comment ça marche dans une appli ?

Dans une appli de livraison de repas 🍕, un client oublie son adresse.

- **Sans protection** : l’appli montre un message très précis :
  🚫 **"Erreur : Adresse manquante dans `delivery_address`"**

- **Avec un message sécurisé** : on peut juste dire :
  ✅ **"Erreur : Informations manquantes dans votre commande."**

Comme ça, on ne montre pas **comment l’appli fonctionne** à ceux qui voudraient tricher.

---

### 🎯 Personnaliser les erreurs avec FastAPI

Avec FastAPI, on peut **repérer les erreurs** et aussi **choisir le message** qu’on veut montrer.

✔️ **On peut cacher les détails techniques** pour que personne ne comprenne comment l’appli marche.
✔️ **Les messages sont plus simples** pour les utilisateurs.
✔️ **C’est une protection en plus 🔐**, comme un bouclier contre les personnes malveillantes.

En résumé, **cacher les messages d’erreur**, c’est comme garder **le plan secret** d’un jeu vidéo 🎮 pour éviter que des tricheurs cassent les règles ! 🚀

#6

### 🚀 Ce que tu as appris jusqu’ici

Tu as vu comment **FastAPI** repère les erreurs quand quelqu’un envoie de mauvaises infos.
C’est comme un prof 📄✅ qui vérifie ton contrôle avant de le corriger.

Mais une appli ne fait pas que repérer les erreurs ! Elle doit aussi **stocker et ranger** toutes ses infos 📦.

Dans le **prochain chapitre**, tu vas apprendre à **gérer les données** d’une appli web :
1️⃣ **Comment enregistrer et retrouver les infos facilement**
2️⃣ **Comment utiliser des bases SQL et NoSQL** (des gros classeurs numériques 📊)
3️⃣ **Comment protéger les données contre les voleurs ou les tricheurs 🔒**

---

### 📦 Pourquoi gérer les données est important ?

Dans une appli de **devoirs scolaires 📚**, il faut :
✅ **Enregistrer** un devoir (ex : "Exercice de maths pour lundi")
✅ **Retrouver la liste** quand l’élève revient
✅ **Bien ranger et protéger** les infos pour que personne ne les efface ou les change

Si l’appli gère mal les données, il peut y avoir des bugs 🐛 :

❌ Des devoirs qui disparaissent
❌ Des devoirs mélangés entre élèves
❌ Un élève qui peut tout effacer 😨

Donc, **bien ranger et protéger les données**, c’est super important !

---

### 🛠 SQL et NoSQL : deux façons de ranger les données

📑 **SQL** → C’est comme un **tableau Excel** avec des lignes et des colonnes.
Parfait pour tout ce qui doit être bien rangé, comme une **bibliothèque 📖**.

📦 **NoSQL** → C’est comme une **grosse boîte de dossiers**, où les infos peuvent changer de forme.
Très pratique pour des applis avec plein de données différentes, comme un **réseau social 📱**.

---

### 🔒 La sécurité des données, c’est super important !

Si une appli garde des infos comme des **messages 💬**, des **scores 🎮** ou des **photos 📸**, il faut :
✔️ **Empêcher les voleurs de les prendre**
✔️ **Laisser seulement les bons utilisateurs y accéder**
✔️ **Éviter que tout soit perdu ou changé par erreur**

C’est comme un **coffre-fort dans une banque 🏦** : seules les bonnes personnes peuvent l’ouvrir, et les autres doivent rester dehors !

---

### 🎯 Pourquoi c’est important d’apprendre ça ?

Ça te permet de :
✔️ **Créer des applis solides et bien rangées**
✔️ **Éviter les bugs où les infos se perdent**
✔️ **Protéger les données des utilisateurs contre les voleurs**

C’est comme **passer du bricolage 🛠️ à la construction d’un immeuble 🏢** : tu vas apprendre à faire des applis qui grandissent sans bug même avec plein d’utilisateurs ! 🚀
