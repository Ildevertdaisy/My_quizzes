#1


---

### ğŸ“Œ Les **modÃ¨les de requÃªtes et de rÃ©ponses** dans FastAPI

Quand une appli parle Ã  une autre (comme un jeu qui cherche des amis ou une appli de musique qui cherche des chansons), il faut que les infos soient bien rangÃ©es ğŸ“¦.

Câ€™est comme Ã©crire une lettre ğŸ“© :

* Quand tu Ã©cris, tu fais un dÃ©but (Bonjour !), un message clair, et une fin (Ã€ bientÃ´t !).
* Ton ami fait pareil pour que tu comprennes bien.

Dans le monde des **API** (des boÃ®tes aux lettres entre applis ğŸ“¬), il faut que les infos soient bien formÃ©es et vÃ©rifiÃ©es. Câ€™est lÃ  que **FastAPI** et **Pydantic** viennent aider.

---

### ğŸ— FastAPI et Pydantic, les super assistants des API

**FastAPI** aide Ã  crÃ©er des API rapides et bien rangÃ©es.
Mais il a besoin de vÃ©rifier si les donnÃ©es sont bonnes.

Câ€™est **Pydantic** qui fait Ã§a : câ€™est un **contrÃ´leur de qualitÃ©** (il vÃ©rifie si tout est comme prÃ©vu âœ…).

Par exemple :

* Si une appli de **livraison de repas** ğŸ” attend un numÃ©ro mais reÃ§oit "Pizza", **Pydantic** dit : "Erreur ! Ce nâ€™est pas un numÃ©ro !"
* Si un **jeu vidÃ©o** ğŸ® veut un score mais reÃ§oit une phrase, il dit : "Je veux un nombre !"

---

### ğŸ“Š Pourquoi câ€™est important ?

Imagine un **supermarchÃ© en ligne** ğŸ›’ :

* Le client envoie une commande avec des articles.
* Lâ€™appli vÃ©rifie que tout est bien Ã©crit (pas de lettres Ã  la place des chiffres).
* Puis elle renvoie une confirmation avec le montant et la date.

Si on ne vÃ©rifie pas bien les infos, Ã§a peut faire :
âŒ Une commande sans adresse ğŸ˜±
âŒ Une quantitÃ© comme "-5" (Ã§a nâ€™a pas de sens)

Heureusement, **FastAPI** et **Pydantic** trouvent et corrigent ces erreurs avant quâ€™il y ait un problÃ¨me !

---

### ğŸ”„ ModÃ¨les de requÃªtes et de rÃ©ponses

Dans **FastAPI**, on utilise des **modÃ¨les** (comme des formulaires) pour dire :
ğŸ“¤ Ce quâ€™on peut **envoyer** Ã  lâ€™appli (les **requÃªtes**)
ğŸ“¥ Ce quâ€™on peut **recevoir** aprÃ¨s (les **rÃ©ponses**)

Par exemple, dans une appli de **tÃ¢ches** ğŸ“ :

* Quand on ajoute une tÃ¢che, on envoie un titre et une date.
* Lâ€™appli rÃ©pond avec un message et un identifiant.

Si on oublie le titre ou si la date est mauvaise, **Pydantic** dit : "Erreur ! Corrige Ã§a ğŸ”"

---

### ğŸ¯ Conclusion

**FastAPI** et **Pydantic**, câ€™est comme un **gardien des donnÃ©es** ğŸ‘®â€â™‚ï¸ : ils Ã©vitent les erreurs et gardent tout bien rangÃ©.

TrÃ¨s utile pour :

* Les applis de **messagerie** ğŸ“±
* Les **jeux vidÃ©o** ğŸ®

Sans eux, ce serait le bazar ğŸ˜µ.
Mais grÃ¢ce Ã  eux, tout marche bien et tout est vÃ©rifiÃ© ğŸš€.


#2


---

### ğŸ— **Pydantic, un super outil pour organiser et vÃ©rifier les donnÃ©es !**

Quand on utilise une appli, on envoie des infos ğŸ“¤.
Par exemple :

* Dans une appli de **photos** ğŸ“·, on envoie un nom et un mot de passe.
* Dans un **jeu en ligne** ğŸ®, on envoie un pseudo et un score.

Parfois, les infos envoyÃ©es Ã  lâ€™appli sont fausses ğŸ˜± :

* Tu oublies ton mot de passe pour tâ€™inscrire âŒ
* Tu mets "chien" ğŸ¶ au lieu dâ€™un score dans un jeu âŒ

Si lâ€™appli accepte tout, câ€™est le bazar !

Heureusement, **Pydantic** vÃ©rifie tout et remet de lâ€™ordre âœ….

---

### ğŸ¯ **Pydantic : le gardien des donnÃ©es !**

**Pydantic**, câ€™est comme un contrÃ´leur avant la poste ğŸ“¬. Il :
ğŸ” **VÃ©rifie les donnÃ©es** (ex : un Ã¢ge nÃ©gatif, il dit non)
ğŸ“ **Impose des rÃ¨gles** (ex : un mot de passe doit Ãªtre assez long)
ğŸ”„ **Transforme les donnÃ©es** (ex : "25" en texte devient un vrai nombre)

Dans une appli de **rendez-vous** ğŸ“…, **Pydantic** vÃ©rifie que :

* La date est bien une vraie date.
* Le nom est du texte, pas un chiffre.

Sâ€™il y a une erreur, il bloque tout et montre un message clair ğŸ’¡.

---

### ğŸ”„ **Des donnÃ©es toujours bien organisÃ©es !**

**Pydantic** organise aussi les infos que lâ€™appli envoie.

Par exemple, dans une appli **mÃ©tÃ©o** â›… :

* Tu demandes la mÃ©tÃ©o, lâ€™appli rÃ©pond : "Demain, il fera 18Â°C et du soleil."
* **Pydantic** vÃ©rifie que la rÃ©ponse contient bien une tempÃ©rature et une description.

Sâ€™il manque quelque chose ou si câ€™est mal rangÃ©, **Pydantic** corrige tout ğŸ“Š.

---

### ğŸ”„ **Des donnÃ©es toujours bien organisÃ©es !**

**Pydantic** range aussi les **rÃ©ponses** envoyÃ©es par lâ€™appli.

Par exemple, dans une appli **mÃ©tÃ©o** â›… :

* Si tu demandes la mÃ©tÃ©o, lâ€™appli doit rÃ©pondre clairement : "18Â°C et du soleil."
* **Pydantic** vÃ©rifie quâ€™il y a bien une tempÃ©rature et une description.

Sâ€™il manque quelque chose ou si câ€™est mal rangÃ©, **Pydantic** corrige ğŸ“Š.

---

### ğŸ¯ **Conclusion**

**Pydantic**, câ€™est comme un **prof qui vÃ©rifie les devoirs** ğŸ“– : il regarde si tout est bien Ã©crit, sans erreur.

TrÃ¨s utile pour :

* Les applis de **shopping** ğŸ›ï¸
* Les plateformes de **vidÃ©os** ğŸ¬

Il rend les **API** (applis qui se parlent) **claires, sÃ»res et bien rangÃ©es** ! ğŸš€


#3


### ğŸš€ **Se prÃ©parer Ã  utiliser FastAPI !**

Un **endpoint**, câ€™est comme une **boÃ®te aux lettres spÃ©ciale** ğŸ“© dans une appli.
On y **envoie des demandes** (comme une lettre ğŸ“¬) et on **reÃ§oit des rÃ©ponses** (comme un colis ğŸ“¦).

Par exemple :

* Dans une appli **de musique** ğŸµ, un **endpoint** sert Ã  demander une chanson.
* Dans une appli **de mÃ©tÃ©o** â›…, il rÃ©pond avec la tempÃ©rature dâ€™une ville.

Maintenant quâ€™on connaÃ®t Ã§a, on va voir comment **bien organiser les infos** dans **FastAPI**.

---

### ğŸ›  **Les Ã©tapes pour bien faire une API avec FastAPI**

Quand une appli envoie ou reÃ§oit des infos, il faut **tout bien ranger et vÃ©rifier** pour Ã©viter les erreurs.

Voici les **quatre grandes Ã©tapes** pour que Ã§a fonctionne bien ğŸ‘‡ :
---

### 1ï¸âƒ£ **CrÃ©er un modÃ¨le** ğŸ“

Un **modÃ¨le**, câ€™est comme une **fiche de personnage** ğŸ®.
Il dit comment doivent Ãªtre les donnÃ©es :

* Un **nom** (du texte)
* Un **Ã¢ge** (un nombre)
* Une **photo** (un lien ou une image)


Sans **modÃ¨le clair**, tout peut devenir un vrai bazar ğŸ˜µ !

Par exemple, dans une appli de **courses** ğŸ›’, le modÃ¨le peut dire :

* Le **nom** du produit = du texte
* Le **prix** = un nombre avec dÃ©cimales

Si quelquâ€™un Ã©crit "trois euros" au lieu dâ€™un nombre, lâ€™appli dit : **"Erreur !"** ğŸš¨

---

### 2ï¸âƒ£ **DÃ©finir le "corps" de la requÃªte** ğŸ“¨

Le **corps de la requÃªte** (request body), câ€™est le **message quâ€™on envoie Ã  lâ€™appli**.

Par exemple, dans une appli de **cinÃ©ma** ğŸ¬, pour acheter un billet, on envoie :

* Le **nom du film**
* Le **nombre de places**

Si le message est incomplet, lâ€™appli dit **"Erreur"** ğŸ¤”.

Donc on doit toujours dire **Ã  lâ€™avance ce quâ€™il faut envoyer**.


---

### 3ï¸âƒ£ **VÃ©rifier que les donnÃ©es sont correctes** ğŸ”

On ne peut pas accepter **nâ€™importe quoi** !

Il faut **vÃ©rifier** que les infos sont **au bon format**.

Exemple :

* Dans une appli de **livraison** ğŸ”, si lâ€™adresse est vide, lâ€™appli bloque ğŸ“¢.
* Dans une appli **bancaire** ğŸ’³, un montant comme "-50â‚¬" est refusÃ© ğŸ˜¨.

Avec **FastAPI** et **Pydantic**, ces vÃ©rifications se font **toutes seules** âœ….

---

### 4ï¸âƒ£ **GÃ©rer le format des rÃ©ponses** ğŸ“¦

Quand une appli rÃ©pond, elle doit **envoyer des infos claires et bien rangÃ©es**.

Câ€™est comme un **colis** ğŸ“¦ : tu veux les bons objets, bien emballÃ©s, avec une Ã©tiquette lisible.

Exemple :
Dans une appli de **recettes** ğŸ³, si tu cherches "GÃ¢teau au chocolat", lâ€™appli doit te rÃ©pondre avec :

* Le **titre**
* Les **ingrÃ©dients**

Si tout est mÃ©langÃ©, on ne comprend plus rien ğŸ˜µ.

**FastAPI** aide Ã  faire des rÃ©ponses **toujours bien rangÃ©es et faciles Ã  lire** ğŸ†.

---

### ğŸ **Conclusion**

Avec ces **4 Ã©tapes**, une API FastAPI marche bien ğŸ¯ :

1ï¸âƒ£ On **crÃ©e un modÃ¨le** ğŸ“
2ï¸âƒ£ On **dit ce quâ€™on peut envoyer** ğŸ“¤ (le corps de la requÃªte)
3ï¸âƒ£ On **vÃ©rifie les infos** ğŸ”
4ï¸âƒ£ On **range bien les rÃ©ponses** ğŸ“¦

#4


### ğŸ“š **CrÃ©er un modÃ¨le avec Pydantic dans FastAPI**

Dans une appli de **librairie en ligne** ğŸ“–, chaque livre doit avoir :

* Un **titre** (nom du livre)
* Un **auteur** (qui lâ€™a Ã©crit)
* Une **annÃ©e** (date de sortie)

Si les infos dâ€™un livre sont mal rangÃ©es ou manquent, on ne le retrouve plus !

**FastAPI** et **Pydantic** aident Ã  crÃ©er une **structure claire** pour que tout soit bien organisÃ© âœ….

---

### ğŸ›  **Le fichier models.py : le plan des donnÃ©es**

Dans une appli, on ne met pas tout au mÃªme endroit, sinon câ€™est le bazar ğŸ˜µ.
**Câ€™est comme une trousse dâ€™Ã©cole** ğŸ’ :

* Les crayons vont dans une poche,
* Et les cahiers dans un compartiment spÃ©cial.

On va crÃ©er un fichier **models.py** ğŸ“‚.

Il sert Ã  **dÃ©finir les objets** (comme une fiche dâ€™identitÃ© pour chaque livre ğŸ“‘).

---

### ğŸ” **Le code prÃ©sentÃ© :**  

Voici le code quâ€™on va expliquer en dÃ©tail :  

```python
from pydantic import BaseModel

class Book(BaseModel):
    title: str
    author: str
    year: int
```

---

### ğŸ§© **DÃ©composition et explication ligne par ligne**  

1ï¸âƒ£ **Importer BaseModel depuis Pydantic**  

```python
from pydantic import BaseModel
```

ğŸ” **Explication** :

* `from` veut dire **"prends depuis un endroit"**.
* `pydantic` est une **boÃ®te Ã  outils** ğŸ§° pour ranger et vÃ©rifier les donnÃ©es dans FastAPI.
* `import BaseModel` veut dire : **"je prends BaseModel pour crÃ©er des donnÃ©es bien organisÃ©es"**.

ğŸ‘‰ **Câ€™est comme utiliser un moule Ã  gÃ¢teau** ğŸ° : Ã§a sert Ã  crÃ©er des objets bien formÃ©s (comme des livres).

---

2ï¸âƒ£ **CrÃ©er une classe "Book" qui hÃ©rite de BaseModel**  

```python
class Book(BaseModel):
```

ğŸ” **Explication** :

* `class Book:` veut dire **"je crÃ©e un modÃ¨le appelÃ© Book"** ğŸ“˜
* `(BaseModel)` veut dire **"il suit les rÃ¨gles de Pydantic pour bien ranger les donnÃ©es"**

ğŸ‘‰ **Câ€™est comme une fiche obligatoire pour chaque livre**.

Si un livre ne suit pas ce modÃ¨le, **FastAPI le refuse** !

---

3ï¸âƒ£ **DÃ©finir les informations dâ€™un livre**  

```python
    title: str
    author: str
    year: int
```

ğŸ” **Explication** :

* `title: str` = **le titre est un texte** ğŸ“ (ex : "Harry Potter")
* `author: str` = **lâ€™auteur est un texte** ğŸ‘¤ (ex : "J.K. Rowling")
* `year: int` = **lâ€™annÃ©e est un nombre entier** ğŸ”¢ (ex : 1997)

ğŸ‘‰ **Câ€™est comme un formulaire Ã  bien remplir** !
Si on met un nombre Ã  la place du titre ou du texte pour lâ€™annÃ©e, **FastAPI dit "Erreur !"** ğŸš¨.

---

### ğŸ† **Pourquoi câ€™est utile ?**

* Ã‡a Ã©vite les **erreurs dans les donnÃ©es**.
  â†’ Ex : si on Ã©crit lâ€™annÃ©e en lettres ("deux mille vingt"), lâ€™appli dit non ğŸš«.

* Ã‡a rend lâ€™appli **plus claire et bien rangÃ©e** ğŸ—.
  â†’ Chaque livre a sa fiche bien remplie ğŸ“‹.

Câ€™est utile **pour plein dâ€™applis** :
ğŸ“· Dans une appli de **photos** : un modÃ¨le avec titre et image.
ğŸ® Dans un **jeu** : un modÃ¨le avec pseudo et score.

---

### ğŸ¯ **Conclusion**

Avec **Pydantic** et **BaseModel** dans FastAPI, on **organise bien les donnÃ©es** ğŸ“¦ :
1ï¸âƒ£ On **importe Pydantic** ğŸ› 
2ï¸âƒ£ On **crÃ©e un modÃ¨le** ğŸ“œ
3ï¸âƒ£ On **indique les bons types** pour Ã©viter les erreurs ğŸš«

RÃ©sultat : une appli **plus claire, propre et sÃ»re** ğŸ‰ğŸš€

GrÃ¢ce Ã  Ã§a, lâ€™appli est **plus propre, plus claire et plus sÃ»re** ğŸ‰ğŸš€.


#5

### ğŸ“– **Le modÃ¨le Book avec Pydantic**

Dans notre appli de **librairie en ligne** ğŸ“š, le modÃ¨le **Book** est un **cadre** qui dit comment ranger les infos dâ€™un livre.

ğŸ‘‰ **Câ€™est comme une fiche dâ€™identitÃ© pour un livre** !
Il doit avoir :
1ï¸âƒ£ Un **titre** â€“ ex : *Harry Potter*
2ï¸âƒ£ Un **auteur** â€“ ex : *J.K. Rowling*
3ï¸âƒ£ Une **annÃ©e** â€“ ex : *1997*

---

### ğŸ” **Pourquoi chaque champ a un type ?**

Chaque info doit avoir un **type prÃ©cis**, comme une boÃ®te spÃ©ciale ğŸ :

* ğŸ“œ `title: str` â†’ du **texte** (ex : "Le Seigneur des Anneaux")
* ğŸ”¢ `year: int` â†’ un **nombre entier** (ex : 1954)

ğŸ‘‰ **Câ€™est comme remplir un formulaire** :

Si on met un nombre Ã  la place du titre ou du texte pour lâ€™annÃ©e, lâ€™appli dit **"Erreur !"** ğŸš¨.

---

### ğŸ— **Pourquoi câ€™est important ?**

Dans une appli de **films** ğŸ¬ :

* Si on Ã©crit "Deux mille vingt-deux" au lieu de "2022", lâ€™appli ne comprend pas.

Dans une appli de **tÃ¢ches** ğŸ“‹ :

* Si on met "demain" au lieu de "2024-03-10", lâ€™appli ne sait pas la date.

ğŸ‘‰ **Avec Pydantic, ces erreurs sont Ã©vitÃ©es automatiquement** âœ….

---

### ğŸš€ **RÃ©sumÃ©**

ğŸ“Œ Le modÃ¨le **Book** est un **plan** pour ranger les infos dâ€™un livre.
ğŸ“Œ Chaque champ (titre, auteur, annÃ©e) doit avoir **le bon type**.
ğŸ“Œ Ã‡a Ã©vite les erreurs et garde tout bien rangÃ©.

Que ce soit pour des **livres**, des **films** ou des **joueurs de jeux vidÃ©o** ğŸ®, **Pydantic** aide Ã  tout organiser sans erreur âœ…ğŸš€.


#6


### ğŸ“© **Le corps de la requÃªte dans FastAPI**

Quand on veut **ajouter un livre** ğŸ“š, on doit **envoyer des infos** Ã  lâ€™appli :

* Le **titre**
* Lâ€™**auteur**
* Lâ€™**annÃ©e** de publication

**FastAPI** utilise **Pydantic** pour :

* **VÃ©rifier les infos** âœ…
* Et aussi **les faire voyager de lâ€™utilisateur vers lâ€™appli** âœ‰ï¸

Câ€™est ce quâ€™on appelle le **corps de la requÃªte** (request body).

ğŸ‘‰ **Câ€™est comme remplir un formulaire en ligne** :

Quand tu mets ton nom ou un message, **FastAPI** rÃ©cupÃ¨re tout Ã§a pour bien les utiliser.

---

### ğŸ›  **Le code prÃ©sentÃ© :**  

Voici le code que nous allons expliquer en dÃ©tail :  

```python
from models import Book

@app.post("/book")
async def create_book(book: Book):
    return book
```

---

### ğŸ§© **DÃ©composition et explication ligne par ligne**  

#### 1ï¸âƒ£ **Importer le modÃ¨le "Book"**  

```python
from models import Book
```

ğŸ” **Explication** :

* `from` = **prendre depuis un autre fichier**
* `models` = le fichier oÃ¹ on a mis le **modÃ¨le Book**
* `import Book` = **je prends le modÃ¨le Book** ğŸ“–

ğŸ‘‰ **Câ€™est comme prendre une fiche modÃ¨le pour remplir une bibliothÃ¨que** ğŸ“š.
Sans ce modÃ¨le, on ne sait pas Ã  quoi doit ressembler un livre.


---

#### 2ï¸âƒ£ **CrÃ©er un nouvel "endpoint" pour ajouter un livre**  

```python
@app.post("/book")
```

ğŸ” **Explication** :
* `@app.post("/book")` = **quand on envoie une demande POST Ã  /book, la fonction dÃ©marre** ğŸ“¬
* **POST** = sert Ã  **envoyer des nouvelles infos Ã  lâ€™appli**
* Dans une appli de **photos** ğŸ“· : POST sert Ã  **ajouter une image**.
* Dans une appli de **tÃ¢ches** ğŸ“‹ : POST ajoute une **nouvelle tÃ¢che**.
* Ici, POST sert Ã  **ajouter un livre** ğŸ“š.

ğŸ‘‰ **Câ€™est comme dire : "Ajoute ce livre dans la bibliothÃ¨que !"**


---

#### 3ï¸âƒ£ **CrÃ©er la fonction qui va recevoir les informations du livre**  

```python
async def create_book(book: Book):
```

ğŸ” **Explication** :

* `async def` = **je crÃ©e une fonction rapide qui ne bloque pas lâ€™appli** ğŸš€

  * `async` = **asynchrone** (elle peut gÃ©rer plusieurs choses Ã  la fois)
  * `def` = **je dÃ©finis une fonction** (une suite dâ€™actions Ã  faire)

* `create_book(book: Book)` :

  * `create_book` = **nom de la fonction** appelÃ©e quand on **envoie un livre** ğŸ“–
  * `(book: Book)` = elle **attend un objet Book**
  * Cet objet doit avoir : **titre, auteur et annÃ©e** âœ…
 
ğŸ‘‰ **Câ€™est comme remplir une fiche avec les infos dâ€™un livre et lâ€™envoyer Ã  lâ€™appli** ğŸ“.

---

#### 4ï¸âƒ£ **Renvoyer les informations du livre reÃ§u**  

```python
    return book
```

ğŸ” **Explication** :

* `return book` = **je renvoie le livre reÃ§u** ğŸ“¤
* Ã‡a montre Ã  lâ€™utilisateur **ce qui a Ã©tÃ© enregistrÃ©**

ğŸ‘‰ **Câ€™est comme un site qui dit : "Merci ! Voici ton rÃ©sumÃ©"** ğŸ‰

---

### ğŸ¯ **Pourquoi câ€™est utile ?**

Sans Ã§a, lâ€™appli ne peut pas **recevoir de nouveaux livres** âŒ.

Avec ce code :
âœ… Elle **accepte un nouveau livre**
âœ… Elle **vÃ©rifie** le titre, lâ€™auteur et lâ€™annÃ©e
âœ… Elle **renvoie une confirmation** avec les infos enregistrÃ©es âœ…

Et Ã§a marche aussi pour plein d'autres applis :
ğŸ“· Une appli de **photos** pour ajouter une image avec un titre.
ğŸ® Un **jeu vidÃ©o** pour ajouter un joueur avec un pseudo.

---

### ğŸ **RÃ©sumÃ©**

ğŸ“Œ **FastAPI** utilise **Pydantic** pour **transporter les infos** ğŸ“©
ğŸ“Œ Le **request body** est comme un **formulaire rempli par lâ€™utilisateur**
ğŸ“Œ Avec **POST**, lâ€™appli peut **enregistrer un nouvel objet** (ex : un livre ğŸ“š)
ğŸ“Œ Ce principe sert aussi pour **ajouter des images, tÃ¢ches ou rÃ©servations** ğŸš€

#7

### ğŸ“¬ **Quand on envoie une requÃªte POST ?**

Dans notre appli ğŸ“š, on a un **endpoint** (comme une boÃ®te aux lettres ğŸ“©) Ã  lâ€™adresse `/book`.
Il sert Ã  **envoyer un nouveau livre** en remplissant un **formulaire numÃ©rique**.

Mais comment lâ€™appli comprend ce quâ€™on lui envoie ? ğŸ¤”
ğŸ‘‰ **FastAPI lit, vÃ©rifie et range les infos** avant de les enregistrer âœ….

---

### ğŸ›  **Comment FastAPI gÃ¨re les donnÃ©es ?**

Quand un utilisateur envoie une requÃªte **POST**, il envoie des donnÃ©es en **JSON** (un format spÃ©cial pour Ã©crire les infos).

ğŸ“Œ **JSON** est une faÃ§on dâ€™Ã©crire des infos en texte bien rangÃ©.
ğŸ‘‰ **Câ€™est comme une fiche de renseignements** Ã  remplir avant dâ€™envoyer une demande !

Par exemple, si on veut ajouter un livre, on envoie Ã§a en **JSON** :

```json
{
  "title": "Le Petit Prince",
  "author": "Antoine de Saint-ExupÃ©ry",
  "year": 1943
}
```

**FastAPI lit ces infos** et les **vÃ©rifie avec le modÃ¨le "Book"** ğŸ“–.

---

### ğŸ” **Si les donnÃ©es sont fausses ?**

**FastAPI vÃ©rifie tout seul** avec **Pydantic** :

* Si câ€™est bon âœ… â†’ le livre est enregistrÃ©
* Si câ€™est faux âŒ â†’ il bloque et **envoie un message dâ€™erreur**

ğŸ‘‰ **Câ€™est comme sâ€™inscrire sans tout remplir** :
Lâ€™appli dira :

* âŒ "Il manque le nom !"
* âŒ "Lâ€™annÃ©e doit Ãªtre un nombre !"
* âŒ "Ce champ est obligatoire !"


Exemples dâ€™erreurs :

* Pas de titre â†’ âŒ "Le titre est obligatoire !"
* AnnÃ©e en lettres â†’ âŒ "Lâ€™annÃ©e doit Ãªtre un nombre !"
* Auteur oubliÃ© â†’ âŒ "Lâ€™auteur est obligatoire !"

GrÃ¢ce Ã  cette **vÃ©rification automatique**, lâ€™appli Ã©vite de **planter** et garde des donnÃ©es **propres et bien rangÃ©es** ğŸ†.

---

### ğŸ® **OÃ¹ est-ce aussi utile ?**

ğŸ›’ **Shopping** : VÃ©rifier que le prix est un nombre.
ğŸ® **Jeu vidÃ©o** : VÃ©rifier que le score est bien un nombre.
ğŸ“· **Photos** : VÃ©rifier quâ€™il y a un titre et un lien.
ğŸš— **Taxis** : VÃ©rifier que les adresses sont bien Ã©crites.

---

### ğŸ **Conclusion**

âœ… **FastAPI lit et vÃ©rifie les infos** envoyÃ©es par lâ€™utilisateur.
âœ… Si câ€™est faux ou incomplet, il **affiche une erreur** sans planter.
âœ… Ce systÃ¨me marche aussi pour les **jeux**, le **shopping**, les **photos** ou les **rÃ©servations**.

ğŸ‘‰ RÃ©sultat : des applis **bien rangÃ©es et faciles Ã  utiliser** ğŸš€ !


#8

### âœ… **VÃ©rifier les donnÃ©es avec Pydantic**

Quand lâ€™appli reÃ§oit des infos, il faut vÃ©rifier quâ€™elles sont **correctes** âœ….

Exemple :
ğŸ“š Pour tâ€™inscrire Ã  la bibliothÃ¨que :

* Ton **nom** doit Ãªtre du texte
* Ton **Ã¢ge** ne peut pas Ãªtre nÃ©gatif âŒ
* Ton **e-mail** doit contenir un `@`

Si quelquâ€™un met des **infos bizarres ou incomplÃ¨tes**, lâ€™appli doit **bloquer lâ€™erreur** ğŸš¨.

ğŸ‘‰ Câ€™est exactement ce que fait **Pydantic** dans **FastAPI** ! âœ…

---

### ğŸ›  **Le code prÃ©sentÃ©**  

Voici comment Pydantic nous aide Ã  vÃ©rifier que les donnÃ©es envoyÃ©es sont bien remplies et respectent certaines rÃ¨gles :  

```python
from pydantic import BaseModel, Field

class Book(BaseModel):
    title: str = Field(..., min_length=1, max_length=100)
    author: str = Field(..., min_length=1, max_length=50)
    year: int = Field(..., gt=1900, lt=2100)
```

---

### ğŸ§© **Explication dÃ©taillÃ©e ligne par ligne**  

#### 1ï¸âƒ£ **Importer les outils de Pydantic**  

```python
from pydantic import BaseModel, Field
```
ğŸ” **Explication** :

* `from` = **prends depuis un endroit** ğŸ“¦
* `pydantic` = **boÃ®te Ã  outils pour vÃ©rifier et ranger les donnÃ©es**
* `import BaseModel` = **BaseModel sert Ã  crÃ©er des donnÃ©es bien organisÃ©es** âœ…

* `import Field` = **Field permet de mettre des rÃ¨gles prÃ©cises** sur chaque info (ex : un mot de passe doit avoir au moins 8 lettres).

ğŸ‘‰ **Câ€™est comme un prof qui dit quoi Ã©crire dans un devoir** ğŸ“.

---

#### 2ï¸âƒ£ **CrÃ©er un modÃ¨le de livre avec des rÃ¨gles strictes**  

```python
class Book(BaseModel):
```

ğŸ” **Explication** :

* `class Book:` = **on crÃ©e une classe appelÃ©e "Book"** ğŸ“–
* `(BaseModel)` = elle **utilise les rÃ¨gles de Pydantic** (comme un moule pour faire des objets bien faits) âœ…

ğŸ‘‰ **Câ€™est comme une fiche dâ€™inscription avec des rÃ¨gles pour chaque case Ã  remplir** ğŸŸ.

---

#### 3ï¸âƒ£ **DÃ©finir des rÃ¨gles pour chaque donnÃ©e**  

##### ğŸ“ **Le titre du livre**  

```python
title: str = Field(..., min_length=1, max_length=100)
```

ğŸ” **Explication** :

* `title: str` = **le titre doit Ãªtre du texte** ğŸ“œ (pas un chiffre). 
* `Field(..., min_length=1, max_length=100)` :
  * **min\_length=1** = le titre **ne peut pas Ãªtre vide**
  * **max\_length=100** = le titre **ne doit pas Ãªtre trop long**


ğŸ‘‰ **Câ€™est comme dire : "ton pseudo doit faire entre 3 et 15 lettres dans un jeu"** ğŸ®.

---

##### ğŸ‘¤ **Le nom de lâ€™auteur**  

```python
author: str = Field(..., min_length=1, max_length=50)
```

ğŸ” **Explication** :

* `author: str` = **le nom de lâ€™auteur doit Ãªtre du texte** ğŸ–Š
* `min_length=1` = **obligatoire, au moins 1 lettre**
* `max_length=50` = **pas plus de 50 lettres**

ğŸ‘‰ **Câ€™est comme dire : "ton mot de passe doit faire entre 8 et 20 lettres"** ğŸ”’.


---

##### ğŸ“… **Lâ€™annÃ©e de publication du livre**  

```python
year: int = Field(..., gt=1900, lt=2100)
```

ğŸ” **Explication** :

* `year: int` = **lâ€™annÃ©e doit Ãªtre un nombre entier** ğŸ”¢
* `gt=1900` = **plus grand que 1900**
* `lt=2100` = **plus petit que 2100**

ğŸ‘‰ **Câ€™est comme dire : "ton Ã¢ge doit Ãªtre entre 0 et 120 ans"** ğŸ¥.

---

### ğŸš¨ **Pourquoi ces validations sont utiles ?**

* **Elles Ã©vitent les erreurs** âŒ â†’ ex : Ã©crire *"Toto"* pour lâ€™annÃ©e.
* **Elles gardent les donnÃ©es bien rangÃ©es** ğŸ“¦ â†’ ex : un film pas avant 1900.
* **Elles aident lâ€™utilisateur Ã  corriger tout de suite** ğŸš€.

ğŸ‘‰ **Câ€™est comme quand un site dit "Adresse invalide !" au lieu dâ€™accepter nâ€™importe quoi pour commander un burger ğŸ”.**

---

### ğŸ® **OÃ¹ utilise-t-on aussi ces validations ?**

ğŸ“· **Appli de photos** â†’ Lâ€™image ne doit pas dÃ©passer 5 Mo.
ğŸ› **Boutique en ligne** â†’ Le prix doit Ãªtre positif.
ğŸ“… **Rendez-vous** â†’ La date doit Ãªtre dans le futur.
ğŸ® **Jeu vidÃ©o** â†’ Le pseudo doit faire entre 3 et 15 lettres.
---

### ğŸ **RÃ©sumÃ©**

âœ… **Pydantic vÃ©rifie que les infos envoyÃ©es sont correctes**.
âœ… Avec **`Field()`**, on peut **mettre des limites** (ex : taille du texte).
âœ… Si câ€™est trop court, trop long ou pas du bon type â†’ **FastAPI dit "Erreur"**.
âœ… Ces rÃ¨gles servent aussi dans des applis de **shopping, jeux ou photos**.

ğŸ‘‰ RÃ©sultat : une appli **plus claire, plus fiable et plus agrÃ©able** ğŸš€.


#9

### ğŸ“¦ **Organiser les rÃ©ponses de FastAPI**

Quand une appli rÃ©pond, tout doit Ãªtre **propre et utile** ğŸ§¹.

Par exemple, sur une appli de **livraison** ğŸ”ğŸ“± :

* Tu veux voir le **nom du plat, le prix et lâ€™heure**
* Pas des infos inutiles comme **lâ€™adresse du cuisinier** ğŸ˜…


Dans une **API** (appli qui parle Ã  une autre), câ€™est pareil :
**FastAPI permet de choisir** ce quâ€™on veut **envoyer** ğŸ“¤ et **comment lâ€™organiser**.

---

### ğŸ¯ **Pourquoi bien organiser les rÃ©ponses ?**

ğŸ“Œ **Pour cacher les infos sensibles** ğŸ”’
ğŸ‘‰ Exemple : Dans une appli de **messages** ğŸ“©, on ne doit **pas envoyer les mots de passe** des contacts !

ğŸ“Œ **Avoir toujours la mÃªme forme de rÃ©ponse** ğŸ“
ğŸ‘‰ Exemple : Dans une appli **mÃ©tÃ©o** â˜€ï¸, on veut la tempÃ©rature **toujours en chiffres**, pas parfois "Il fait chaud".
Sinon, câ€™est le bazar !

ğŸ“Œ **Rendre les rÃ©ponses claires et simples** ğŸ“
ğŸ‘‰ Exemple : Dans une appli de **tÃ¢ches** âœ…, on renvoie juste :

* Le **titre**
* La **date limite**
* Le **statut** (fait ou pas)
  Pas besoin dâ€™un long message compliquÃ© !

---

### ğŸ”„ **Comment FastAPI gÃ¨re les rÃ©ponses ?**

FastAPI utilise un **modÃ¨le de rÃ©ponse** (response model).
ğŸ‘‰ **Câ€™est comme une boÃ®te ğŸ oÃ¹ on choisit exactement ce quâ€™on envoie dedans**.

Exemple dans une appli de **vidÃ©os** ğŸ¬ :

* On peut envoyer **seulement le titre et la durÃ©e** dâ€™un film, pas tout le reste.

Dans un **jeu en ligne** ğŸ® :

* Pour le classement, on montre **le pseudo et le score**, pas le mot de passe ğŸ˜¨.

---

### ğŸ›  **Pourquoi câ€™est mieux ?**

âœ… **ProtÃ¨ge les infos privÃ©es** â†’ on montre juste lâ€™essentiel
âœ… **RÃ©ponses plus claires** â†’ pas dâ€™infos en trop
âœ… **MÃªme format Ã  chaque fois** â†’ Ã©vite les erreurs

Ce principe est **partout** :
ğŸ“· **Photos** â†’ juste le titre et le lien, pas les dÃ©tails techniques
ğŸ’³ **Banque** â†’ seulement le solde, pas les numÃ©ros de carte
ğŸš— **Taxi** â†’ nom du chauffeur et heure, pas tout le reste

---

### ğŸ **Conclusion**

Avec **FastAPI**, on peut **organiser les rÃ©ponses** pour quâ€™elles soient :
ğŸ“Œ **Claires** â€” on choisit les bonnes infos
ğŸ“Œ **SÃ©curisÃ©es** â€” pas de donnÃ©es sensibles
ğŸ“Œ **Simples** â€” lâ€™appli est plus rapide et facile Ã  utiliser ğŸš€

ğŸ‘‰ RÃ©sultat : des **API plus propres et plus efficaces** ğŸ”¥



#10

### ğŸ“š **CrÃ©er un endpoint sans lâ€™annÃ©e**

Dans une **librairie en ligne** ğŸ“–,
si on veut juste **la liste des livres**, on montre :

* Le **titre**
* Lâ€™**auteur**
  Pas besoin de lâ€™annÃ©e (trop dâ€™infos Ã  lâ€™Ã©cran) ğŸ“¦.

ğŸ‘‰ **Comme dans une appli de films ğŸ¬** : on veut voir le **titre** et le **rÃ©alisateur**, pas la date exacte.

Avec **FastAPI**, on peut **choisir les infos Ã  envoyer** grÃ¢ce Ã  un **modÃ¨le de rÃ©ponse spÃ©cial** ğŸ.

---

### ğŸ›  **Le code prÃ©sentÃ©**  

Voici le code quâ€™on va expliquer en dÃ©tail ğŸ‘‡  

```python
from pydantic import BaseModel

class BookResponse(BaseModel):
    title: str
    author: str

@app.get("/allbooks")
async def read_all_books() -> list[BookResponse]:
    return [
        {
            "id": 1,
            "title": "1984",
            "author": "George Orwell"
        },
        {
            "id": 2,
            "title": "The Great Gatsby",
            "author": "F. Scott Fitzgerald"
        },
    ]
```

---

### ğŸ§© **DÃ©composition et explication ligne par ligne**  

#### 1ï¸âƒ£ **Importer Pydantic pour structurer la rÃ©ponse**  

```python
from pydantic import BaseModel
```

ğŸ” **Explication** :

* `from` = **prends depuis un endroit** ğŸ“¦
* `pydantic` = **boÃ®te Ã  outils** pour organiser et vÃ©rifier
* `import BaseModel` = **modÃ¨le de base** pour dire **quelles donnÃ©es seront envoyÃ©es**

ğŸ‘‰ **Câ€™est comme une boÃ®te cadeau ğŸ : on choisit ce quâ€™on met dedansâ€¦ et ce quâ€™on ne met pas !** 

---

#### 2ï¸âƒ£ **CrÃ©er un modÃ¨le de rÃ©ponse qui affiche seulement le titre et lâ€™auteur**  

```python
class BookResponse(BaseModel):
    title: str
    author: str
```

ğŸ” **Explication** :

* `class BookResponse(BaseModel):` = **on crÃ©e une "boÃ®te" pour choisir les infos Ã  renvoyer**
* `title: str` = **le titre est du texte** ğŸ“–
* `author: str` = **lâ€™auteur aussi** ğŸ–Š

ğŸ‘‰ **Câ€™est comme une liste de courses ğŸ›’ avec juste "PÃ¢tes" et "Lait", sans la marque ni le prix !**

---

#### 3ï¸âƒ£ **CrÃ©er un endpoint qui renvoie la liste des livres**  

```python
@app.get("/allbooks")
```

ğŸ” **Explication** :

* `@app.get("/allbooks")` = crÃ©e un **endpoint GET** ğŸ“©

  * `GET` = **je veux lire des infos**, pas en envoyer
  * `"/allbooks"` = **lâ€™adresse pour voir la liste des livres**

ğŸ‘‰ **Câ€™est comme une Ã©tagÃ¨re ğŸ“š oÃ¹ on voit les titres des livres sans les prendre.**

---

#### 4ï¸âƒ£ **DÃ©finir la fonction qui envoie la liste des livres**  

```python
async def read_all_books() -> list[BookResponse]:
```

ğŸ” **Explication** :

* `async def` = crÃ©e une fonction qui **rÃ©pond vite mÃªme si plusieurs personnes la lancent en mÃªme temps** âš¡. 
* `read_all_books()` = nom de la fonction qui **renvoie la liste des livres**
* `-> list[BookResponse]` = **la rÃ©ponse sera une liste de "BookResponse"** ğŸ“‹

ğŸ‘‰ **Câ€™est comme dire : "je donne une liste de fiches, et chaque fiche a juste le titre et lâ€™auteur"**.

---

#### 5ï¸âƒ£ **CrÃ©er et renvoyer une liste de livres**  

```python
return [
    {
        "id": 1,
        "title": "1984",
        "author": "George Orwell"
    },
    {
        "id": 2,
        "title": "The Great Gatsby",
        "author": "F. Scott Fitzgerald"
    },
]
```

ğŸ” **Explication** :

* `return [...]` = **on renvoie une liste de livres** ğŸ“‹
* Chaque livre a :

  * un `id` (identifiant)
  * un `title` (titre)
  * un `author` (auteur)
    ğŸš¨ **Pas dâ€™annÃ©e** : on a choisi de ne pas lâ€™envoyer !


ğŸ‘‰ **Câ€™est comme une playlist ğŸµ oÃ¹ on voit juste le titre et lâ€™artiste, sans lâ€™annÃ©e de sortie !**

---

### ğŸš€ **Pourquoi câ€™est utile ?**

âœ… **On montre juste les infos importantes**
âœ… **Les rÃ©ponses sont plus claires et rapides**
âœ… **On cache les infos sensibles** (comme un mot de passe)

---

### ğŸ® **Autres exemples**

ğŸ“· **Photos** â†’ juste le titre et lâ€™image
ğŸ® **Jeux** â†’ juste le pseudo et le score
ğŸ› **Shopping** â†’ juste le nom du produit et le prix

---

### ğŸ **RÃ©sumÃ©**

ğŸ“Œ **FastAPI filtre les rÃ©ponses** pour garder **seulement les infos utiles** ğŸ¯
ğŸ“Œ Avec un **modÃ¨le de rÃ©ponse**, on choisit **ce quâ€™on montre**
ğŸ“Œ Ã‡a rend les rÃ©ponses **plus lÃ©gÃ¨res et plus sÃ»res** ğŸ”’
ğŸ“Œ Ce systÃ¨me est utilisÃ© dans les applis de **jeux, photos, shoppingâ€¦** ğŸš€

ğŸ‘‰ RÃ©sultat : des **API plus rapides, plus claires et plus agrÃ©ables** ğŸ‰



#11


### ğŸ“© **Comment dire Ã  FastAPI quoi renvoyer ?**

Quand lâ€™appli envoie des infos, **tout doit Ãªtre bien rangÃ©** ğŸ“¦.

Exemple : si tu demandes une **liste de livres** ğŸ“š, tu veux juste :

* Le **titre**
* Lâ€™**auteur**

Pas lâ€™annÃ©e ni dâ€™autres dÃ©tails.
ğŸ‘‰ Lâ€™appli doit suivre une **rÃ¨gle claire** pour que ce soit **simple et lisible**.
 

Avec **FastAPI**, on peut dire **Ã  lâ€™avance** quel modÃ¨le utiliser pour que **seules les bonnes infos soient envoyÃ©es** ğŸ¯.

---

### ğŸ›  **Deux faÃ§ons de dÃ©finir le modÃ¨le de rÃ©ponse**  

#### 1ï¸âƒ£ **Avec une "indication de type" (type hint) dans la fonction**  

Dans le code, on voit cette notation :  

```python
-> list[BookResponse]
```

ğŸ” **Explication** :

* `->` = **la fonction va renvoyer Ã§a**
* `list[BookResponse]` = **elle renvoie une liste de BookResponse** ğŸ“‹
* Et **BookResponse** contient juste **le titre et lâ€™auteur**.

ğŸ‘‰ **Câ€™est comme dire : "Tu dois renvoyer juste le titre et lâ€™auteur, et rien dâ€™autre !"** ğŸš€ 

ğŸ“Œ **Exemple** :
Dans un jeu vidÃ©o ğŸ®, on peut **montrer juste le pseudo et le score** dans le classement, sans lâ€™email ou lâ€™avatar.

---

#### 2ï¸âƒ£ **Avec le paramÃ¨tre `response_model` dans le dÃ©corateur**  

Il y a une autre faÃ§on dâ€™indiquer le modÃ¨le de rÃ©ponse :  

```python
@app.get("/allbooks", response_model= list[BookResponse])
```

ğŸ” **Explication** :

* `@app.get("/allbooks")` = **crÃ©e un endpoint GET** pour lire des donnÃ©es
* `response_model=list[BookResponse]` = **FastAPI nâ€™enverra que le titre et lâ€™auteur** des livres

ğŸ‘‰ **Câ€™est comme dire au serveur : "Juste le plat principal, pas lâ€™entrÃ©e ni le dessert" ğŸ½ !**

ğŸ“Œ **Autres exemples** :
ğŸ› **Shopping** â†’ montrer juste le nom et le prix
â˜ï¸ **MÃ©tÃ©o** â†’ montrer juste la tempÃ©rature et la ville

---

### ğŸ¯ **Pourquoi câ€™est utile ?**

âœ… **Les rÃ©ponses sont plus lÃ©gÃ¨res** â†’ tout va plus vite âš¡
âœ… **Les infos sont bien rangÃ©es** ğŸ“
âœ… **Les donnÃ©es privÃ©es sont protÃ©gÃ©es** ğŸ”’

---

### ğŸ **RÃ©sumÃ©**

ğŸ“Œ **FastAPI peut renvoyer juste les infos utiles** ğŸ¯
ğŸ“Œ On le fait avec `-> list[BookResponse]` ou `response_model`
ğŸ“Œ Câ€™est utilisÃ© dans les applis de **jeux, mÃ©tÃ©o, shopping...**

ğŸ‘‰ RÃ©sultat : des API **plus rapides, sÃ»res et simples** ğŸš€


#12

### ğŸ— **Quâ€™est-ce qui est prioritaire ?**

FastAPI peut savoir **quoi renvoyer** de deux faÃ§ons :
1ï¸âƒ£ `-> list[BookResponse]` (type indiquÃ© Ã  droite de la fonction)
2ï¸âƒ£ `response_model=...` dans le dÃ©corateur

ğŸ‘‰ Il y a un ordre entre les deuxâ€¦

ğŸ‘‰ **Si on utilise les deux, câ€™est `response_model` qui gagne** ğŸš€ !

---

### ğŸ¯ **Pourquoi `response_model` est plus important ?**

`-> list[BookResponse]` aide Ã  comprendre **le format** des donnÃ©es.
Mais parfois, ce nâ€™est **pas assez** : il peut y avoir des **erreurs** ğŸ›‘.
ğŸ‘‰ `response_model` est plus sÃ»r et plus prÃ©cis âœ….

âœ… **Dans ce cas, `response_model` prend le dessus** et aide FastAPI Ã  bien organiser les donnÃ©es ğŸ“¦.  

---

### ğŸ“Œ **Exemple simple**

Dans une appli de **tÃ¢ches** ğŸ“‹ :

* On demande la **liste des tÃ¢ches**
* Sâ€™il y a des erreurs dans la liste, Ã§a peut bloquer
* Alors on utilise `response_model` pour dire : **"Tu renvoies juste le titre et la date limite"** âœ…

ğŸ‘‰ **Câ€™est comme un prof qui dit : "MÃªme si ton devoir est mal prÃ©sentÃ©, je le corrige avec mes rÃ¨gles"** ğŸ“

---

### ğŸ® **Autres exemples**

ğŸ“· **Photos** â†’ juste le titre et le lien, pas la taille du fichier
ğŸµ **Musique** â†’ juste le titre et lâ€™artiste, pas le fichier audio ğŸ§
ğŸš— **Taxi** â†’ juste le nom du chauffeur et lâ€™heure, pas son numÃ©ro privÃ©


---

### ğŸ **Conclusion**

ğŸ“Œ `response_model` est **plus important** que lâ€™indication de type
ğŸ“Œ Il **Ã©vite les erreurs** et garde les rÃ©ponses **bien rangÃ©es**
ğŸ“Œ UtilisÃ© dans plein dâ€™applis : **photos, musique, jeux, transport...**

ğŸ‘‰ RÃ©sultat : des **API claires, sÃ»res et faciles Ã  utiliser** ğŸš€



#13

### ğŸ“– **La doc automatique de FastAPI**

Quand on crÃ©e une API avec **FastAPI**, une page de **documentation est crÃ©Ã©e toute seule** ğŸ“œ.

ğŸ‘‰ Câ€™est un super avantage !

ğŸ‘‰ **Câ€™est comme un mode dâ€™emploi interactif** : tu peux voir **comment marche lâ€™API** et mÃªme **la tester sans coder** !

Pour voir la doc, ouvre cette adresse dans ton navigateur ğŸŒ :

```
http://127.0.0.1:8000/docs
```

ğŸ‘‰ Câ€™est comme une **page dâ€™aide interactive** : tu peux **voir les routes**, **tester les requÃªtes** et **lire les rÃ©ponses** ğŸ¯.

---

### ğŸ›  **VÃ©rifier ce que lâ€™API envoie**

Dans la doc, tu peux ouvrir (`unroll`) lâ€™endpoint `/allbooks`.

Il montre une **liste de livres**, mais **seulement avec le titre et lâ€™auteur** (pas lâ€™annÃ©e).

Quand on regarde la rÃ©ponse attendue, voici ce quâ€™on voit ğŸ‘‡ :  

```
[
Â Â {
Â Â Â Â "title": "string",
Â Â Â Â "author": "string"
Â Â }
]
```

---

### ğŸ§ **Que veut dire cette rÃ©ponse ?**

ğŸ” Ligne par ligne :

* **\[ ]** = câ€™est une **liste** ğŸ“‹
* **{ }** = un **livre** dans la liste ğŸ“–
* `"title": "string"` = le **titre** est du texte
* `"author": "string"` = lâ€™**auteur** est du texte aussi 

ğŸ‘‰ **Comme dans une appli de musique ğŸµ** :
On voit **juste le titre et lâ€™artiste**, pas la durÃ©e ni la date.

ğŸ› **Dans le shopping** :
On voit **le nom et le prix**, pas les dÃ©tails techniques.

---

### ğŸ¯ **Pourquoi câ€™est utile ?**

âœ… On peut **tester lâ€™API sans coder** ğŸ‰
âœ… On voit **quelles infos sont envoyÃ©es et comment** ğŸ“¦
âœ… On vÃ©rifie que **tout fonctionne comme prÃ©vu** ğŸ› 

---

### ğŸ **RÃ©sumÃ©**

ğŸ“Œ **FastAPI crÃ©e une doc automatique Ã  lâ€™adresse** `http://127.0.0.1:8000/docs` ğŸŒ
ğŸ“Œ On peut **tester les endpoints** et voir les rÃ©ponses ğŸ‘€
ğŸ“Œ `/allbooks` renvoie une **liste avec juste le titre et lâ€™auteur** ğŸ“–
ğŸ“Œ UtilisÃ© dans les applis de **shopping, musique, mÃ©tÃ©oâ€¦**

ğŸ‘‰ GrÃ¢ce Ã  Ã§a, les devs peuvent **tester et amÃ©liorer lâ€™API facilement** ğŸš€

#14

### ğŸ‰ **Bravo !**

Tu sais maintenant **utiliser Pydantic avec FastAPI** ğŸ“¦
Tu peux **organiser et vÃ©rifier les donnÃ©es** facilement ğŸ› ï¸
Ton appli est prÃªte Ã  gÃ©rer **des infos complexes sans se tromper** âœ…

---

### ğŸ” **Ce que tu as appris**

âœ… **Le "corps de requÃªte"** = le message quâ€™on envoie Ã  une appli
ğŸ“Œ Exemple : dans une **appli de messages** ğŸ“©, un message contient **le texte, lâ€™expÃ©diteur et la date**.

âœ… **CrÃ©er un modÃ¨le Pydantic** = comme remplir un **formulaire avec des rÃ¨gles**
ğŸ“Œ Exemple : dans une **appli de shopping** ğŸ›, un produit doit avoir **un nom, un prix et une quantitÃ©**.

âœ… **Filtrer les rÃ©ponses** = garder **seulement ce qui est utile**
ğŸ“Œ Exemple : dans un jeu ğŸ®, on montre **le pseudo et le score**, mais **pas le mot de passe**.

âœ… **VÃ©rifier les donnÃ©es** = Ã©viter les erreurs grÃ¢ce aux rÃ¨gles Pydantic
ğŸ“Œ Exemple : dans une appli de **taxis** ğŸš•, on peut **refuser une adresse vide ou une date invalide**.

âœ… **Utiliser la doc automatique** = tester lâ€™API sans coder ğŸ“œ
ğŸ“Œ Exemple : sur **[http://127.0.0.1:8000/docs](http://127.0.0.1:8000/docs)**, un dev peut voir **la liste des films** ğŸ¬ dans une appli de streaming.

---

### ğŸš€ **Pourquoi câ€™est important ?**

Ã‡a permet de crÃ©er des applis **plus rapides, plus claires et plus sÃ»res** ğŸ¯
ğŸ“Œ Dans la musique, les photos, le shopping ou les jeux :
ğŸ‘‰ **Bien gÃ©rer les donnÃ©es**, câ€™est essentiel pour Ã©viter les erreurs ğŸ”¥


GrÃ¢ce Ã  **FastAPI** et **Pydantic**, les API sont **plus simples, plus rapides et plus intelligentes** ğŸ‰ğŸš€