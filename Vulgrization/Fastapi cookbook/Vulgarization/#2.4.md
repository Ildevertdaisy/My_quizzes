#1

---

### ğŸ”Œ **Se connecter Ã  une base de donnÃ©es, câ€™est comme brancher un tÃ©lÃ©phone Ã  Internet !**

Quand tu veux jouer Ã  ton jeu prÃ©fÃ©rÃ© ou Ã©couter de la musique sur Spotify ğŸ®ğŸµ, il te faut une **connexion Internet**. Sinon, ton appli ne peut pas envoyer ni recevoir d'infos (comme une nouvelle chanson ou la liste des musiques). Câ€™est pareil pour une base de donnÃ©es : sans connexion, lâ€™appli ne peut pas parler avec elle !

Câ€™est **pareil pour une base de donnÃ©es !** Une appli (comme une boutique ou un jeu) doit **se connecter** pour chercher les infos quâ€™elle veut (comme des produits ou des scores).

---

### ğŸ¦ **Quâ€™est-ce quâ€™une base de donnÃ©es ?**

Câ€™est comme une **grande bibliothÃ¨que** ğŸ“š, mais pour ranger des infos numÃ©riques (pas des livres).

Par exemple :
âœ… Une appli de restaurant garde le menu. ğŸ”
âœ… Une appli de tÃ¢ches note ce que tu dois faire. âœ… 

Pour que lâ€™appli puisse lire ou Ã©crire dans la base de donnÃ©es, il faut une **connexion** (comme un cÃ¢ble pour parler avec elle) !

---

### ğŸ”— **La connexion Ã  la base de donnÃ©es : un pont magique !**

Câ€™est comme un **pont** entre une ville et une Ã®le ğŸï¸.

* **Lâ€™appli** est la ville ğŸ™ï¸.
* **La base de donnÃ©es** est lâ€™Ã®le ğŸŒ´.
* **La connexion** est le pont ğŸŒ‰ pour aller chercher ou envoyer des infos (comme des trÃ©sors).

Si la connexion marche bien, lâ€™appli reÃ§oit vite les infos. Mais si elle est coupÃ©e, lâ€™appli peut ne rien afficher ou ne plus marcher du tout. ğŸ˜±


---

### ğŸ¯ **Pourquoi câ€™est important ?**

Sans connexion, lâ€™appli ne peut pas accÃ©der Ã  la base de donnÃ©es.

âŒ Un jeu ne peut pas charger ta partie. ğŸ®
âŒ Une appli de messages ne voit pas les nouveaux messages. ğŸ’¬

Câ€™est pour Ã§a quâ€™il faut une **bonne connexion** ! Câ€™est comme un **Wi-Fi super rapide** ğŸ“¶ğŸš€ pour que tout marche sans bug.


---

### ğŸ“Œ **En rÃ©sumÃ© :**

âœ” Une **base de donnÃ©es** garde les infos. ğŸ—„ï¸
âœ” Une **connexion** sert Ã  les chercher. ğŸ”—
âœ” Sans connexion, lâ€™appli ne peut rien envoyer ni recevoir. âŒ

Et voilÃ  ! Maintenant tu sais pourquoi la connexion est super importante ! ğŸ˜Š


#2

---

### ğŸ  **Les sessions, câ€™est comme un bureau de travail !**

Quand une appli (comme un jeu ou une boutique) veut parler Ã  la base de donnÃ©es, elle utilise une **session** (un espace organisÃ© pour travailler bien).

ğŸ‘‰ **Câ€™est quoi une session ?**

Dans SQLAlchemy (un outil pour parler aux bases de donnÃ©es avec Python), une **session** est comme un **bureau temporaire** ğŸ¢ oÃ¹ lâ€™appli peut :
ğŸ“„ Ã©crire des infos,
ğŸ“ changer des choses,
ğŸ“‚ ou lire ce qui est dÃ©jÃ  lÃ .

Câ€™est comme si tu allais Ã  la bibliothÃ¨que ğŸ“š et que tu tâ€™installais Ã  une table :

âœ” Tu peux lire un livre ğŸ“–,
âœ” ou Ã©crire une note dans ton cahier ğŸ–Šï¸.

Quand tu as fini Ã  la bibliothÃ¨que, tu rends les livres et tu quittes la table. La **session**, câ€™est pareil : elle organise le travail, puis se ferme quand tout est fini.

---

### ğŸ”— **Chaque session va avec une seule base de donnÃ©es**

Une session marche avec **une seule base Ã  la fois**.

Câ€™est comme une appli de **livraison de repas** ğŸ• :
Tu ouvres une commande dans **un seul restaurant**. Pas possible de prendre une pizza ici et un sushi ailleurs en mÃªme temps !

Comme une commande dans un seul resto, une session SQLAlchemy est **toujours liÃ©e Ã  une seule base de donnÃ©es**. Elle ne peut pas en gÃ©rer plusieurs en mÃªme temps.

---

### ğŸ® **Pourquoi une session est utile ?**

Sans session, ce serait le bazar ! ğŸ˜µ

Dans un jeu ğŸ®, si les joueurs ajoutaient leurs scores directement sans session, Ã§a ferait des erreurs, de mauvais points ou mÃªme des bugs.

Les sessions servent Ã  :
âœ… **Organiser** les changements ğŸ—‚ï¸
âœ… **Ã‰viter les erreurs** quand plusieurs personnes agissent en mÃªme temps ğŸ”„
âœ… **Bien enregistrer** les infos et les garder en sÃ©curitÃ© ğŸ”

---

### ğŸ“Œ **En rÃ©sumÃ© :**

âœ” Une **session** est un bureau temporaire pour ajouter, changer ou lire des infos. ğŸ¢
âœ” Elle est connectÃ©e Ã  **une seule base**. ğŸ”—
âœ” Elle aide Ã  **Ã©viter les erreurs** et Ã  tout bien organiser. âœ…

Sans session, ce serait vite le chaos ğŸ˜…, mais SQLAlchemy sâ€™en occupe pour nous ! ğŸš€



#3

---

### ğŸ  **Pourquoi une classe pour les sessions ?**

Quand une appli (comme un jeu ou un rÃ©seau social) parle Ã  la base, elle utilise une **session**.

Mais au lieu dâ€™en crÃ©er une Ã  la main Ã  chaque fois, on fait une **classe spÃ©ciale** qui sâ€™en occupe toute seule.

ğŸ‘‰ La classe sâ€™appelle **SessionLocal**. Câ€™est comme un **robot assistant** ğŸ¤– qui ouvre et gÃ¨re les sessions tout seul.

Câ€™est comme un **distributeur de billets** ğŸ¦ :

* Tu ne vas pas ouvrir le coffre toi-mÃªme ğŸ’°.
* Tu passes par le **distributeur**, qui fait tout pour toi.

**SessionLocal**, câ€™est pareil : il sait **ouvrir** et **gÃ©rer** les sessions tout seul.

---

### ğŸ” **DÃ©cryptons le code ensemble !**  

```python
from sqlalchemy.orm import sessionmaker
```

ğŸ”¹ **`from sqlalchemy.orm import sessionmaker`**
On importe `sessionmaker`, un outil de SQLAlchemy qui aide Ã  crÃ©er les sessions (comme un robot qui prÃ©pare ton bureau de travail).
* `sessionmaker`, câ€™est un **constructeur de sessions** (il fabrique des sessions).
* Câ€™est comme un **chef** ğŸ‘¨â€ğŸ³ qui prÃ©pare une session toute prÃªte Ã  servir !

---

```python
SessionLocal = sessionmaker(
Â Â Â Â autocommit=False, autoflush=False, bind=engine
)
```

ğŸ”¹ **`SessionLocal = sessionmaker(...)`**
On crÃ©e une **classe spÃ©ciale** qui fabrique des sessions quand on en a besoin.
Câ€™est comme une **usine Ã  sessions** ğŸ­ qui fait tout toute seule !

ğŸ‘‰ **`autocommit=False`**
* Les changements ne sont **pas enregistrÃ©s tout de suite**.
* Câ€™est comme Ã©crire un message ğŸ“© que tu peux corriger ou envoyer plus tard.

ğŸ‘‰ **`autoflush=False`**

* Les changements ne partent pas tout de suite vers la base.
* Câ€™est comme un **brouillon dâ€™email** ğŸ“§ que tu peux relire avant de lâ€™envoyer.

ğŸ‘‰ **`bind=engine`**

* On **connecte la session Ã  une base**.
* Câ€™est comme dire Ã  ton assistant ğŸ¤– : **"Tu Ã©criras tout dans ce cahier prÃ©cis"** ğŸ“’.

---

### ğŸ¯ **Pourquoi utiliser SessionLocal ?**

Sans cette classe, ce serait le **dÃ©sordre** ! ğŸ˜µ

ğŸ” Si un client commande, la session enregistre tout.
âŒ Sans session bien faite, plusieurs clients pourraient changer la mÃªme commande et crÃ©er des erreurs.

Avec **SessionLocal**, tout est bien rangÃ© : chaque utilisateur a **sa propre session** ğŸ¯, sans dÃ©ranger les autres.

---

### ğŸ“Œ **En rÃ©sumÃ© :**

âœ” **SessionLocal** fabrique des sessions pour parler Ã  la base. ğŸ­
âœ” `sessionmaker` aide Ã  les crÃ©er tout seul. ğŸ¤–
âœ” Les options (`autocommit`, `autoflush`, `bind`) Ã©vitent les erreurs. âœ…
âœ” Lâ€™appli reste bien organisÃ©e, comme un **resto bien gÃ©rÃ©**. ğŸ½ï¸

GrÃ¢ce Ã  Ã§a, tout marche sans mÃ©lange ! ğŸš€


#4


### ğŸ­ **Une usine Ã  sessions : Ã  quoi sert `sessionmaker` ?**

Dans une appli avec base de donnÃ©es (comme un jeu ou une appli de photos ğŸ“¸), crÃ©er chaque session Ã  la main serait trop long.
Alors on utilise `sessionmaker`, une **usine spÃ©ciale** qui les fabrique pour nous !

La fonction **`sessionmaker`** ğŸ©âœ¨ est comme une **usine magique** qui fabrique des sessions toutes prÃªtes !

ğŸ› ï¸ Câ€™est comme une **machine Ã  crÃªpes** ğŸ¥ :

Au lieu de tout faire Ã  la main, la machine prÃ©pare chaque crÃªpe toute seule.

**`sessionmaker`**, câ€™est pareil : il **fabrique les sessions automatiquement**, sans tout refaire Ã  chaque fois.

---

### ğŸ” **Pourquoi `autocommit=False` et `autoflush=False` ?**

Quand une appli change des infos (comme ajouter un joueur ğŸ® ou une commande ğŸ›’), il ne faut pas envoyer Ã§a nâ€™importe comment.
Ces options permettent de **choisir le bon moment** pour envoyer les changements.

ğŸ‘‰ **`autocommit=False` : rien nâ€™est envoyÃ© tout seul !**

* Câ€™est comme Ã©crire un message ğŸ“± sans appuyer sur "Envoyer".
* Lâ€™appli peut **vÃ©rifier et corriger** avant dâ€™envoyer, pour Ã©viter les erreurs. 

ğŸ‘‰ **`autoflush=False` : rien nâ€™est envoyÃ© sans ton accord !**

* Câ€™est comme remplir un formulaire ğŸ• : on **nâ€™envoie pas chaque lettre** tapÃ©e.
* Lâ€™appli **attend que tout soit prÃªt** avant dâ€™envoyer, pour Ã©viter les erreurs. âœ…

---

### ğŸ¯ **Pourquoi contrÃ´ler les transactions ?**

Si lâ€™appli envoyait tout sans contrÃ´le, Ã§a pourrait :
âŒ crÃ©er des erreurs,
âŒ effacer des infos par accident,
âŒ ou faire buguer lâ€™appli.

Alors on prÃ©fÃ¨re **gÃ©rer Ã§a nous-mÃªmes** pour que tout reste bien propre ! âœ…


Dans une appli de banque ğŸ¦ :

* Si tout part sans vÃ©rifier, tu pourrais perdre de lâ€™argent ou lâ€™envoyer au mauvais compte ğŸ˜±.
* Avec **`autocommit=False`**, lâ€™appli **vÃ©rifie dâ€™abord** avant de valider le virement. âœ…

Dans une appli de messages ğŸ’¬ :

* Si chaque mot partait tout seul, ton ami recevrait le message **mot par mot**.
* Lâ€™appli attend que tu **appuies sur "Envoyer"** pour tout envoyer dâ€™un coup. âœ…

---

### ğŸ“Œ **En rÃ©sumÃ© :**

âœ” **`sessionmaker`** est une **usine Ã  sessions** ğŸ­ pour parler Ã  la base.
âœ” **`autocommit=False`** : les changements attendent quâ€™on dise â€œOKâ€ ğŸ“©.
âœ” **`autoflush=False`** : rien ne part sans contrÃ´le ğŸ›‘.
âœ” Comme une banque ğŸ¦, lâ€™appli vÃ©rifie avant dâ€™envoyer. âœ…

Avec Ã§a, tout est **plus sÃ»r et bien rangÃ©** ! ğŸš€


#5

### ğŸ”— **CrÃ©er une fonction pour ouvrir une session**

On a dÃ©jÃ  **SessionLocal** (notre usine Ã  sessions ğŸ­).
Maintenant, on a besoin dâ€™une **fonction simple** pour **ouvrir et fermer une session** Ã  chaque fois que lâ€™appli veut parler Ã  la base.
 

ğŸ‘‰ **Comme dans un resto ğŸ½ï¸ :**

* Le client arrive â†’ on lui donne une table (**ouvrir une session**)
* Il commande â†’ on utilise la session pour parler Ã  la base
* Il part â†’ on ferme la session

On va crÃ©er une **fonction spÃ©ciale** pour faire tout Ã§a automatiquement avec FastAPI.

---

### ğŸ§ **Regardons le code !**

```python
from database import SessionLocal
```

ğŸ”¹ On importe **SessionLocal** (notre **usine Ã  sessions** ğŸ­) depuis `database.py`.
Elle sait **crÃ©er des sessions** pour parler Ã  la base.

Câ€™est comme **amener une machine Ã  cafÃ©** â˜• dans la cuisine : maintenant, on peut **prÃ©parer des cafÃ©s** (des sessions) quand on veut !
  

---

```python
def get_db()
```
ğŸ”¹ **`def get_db()`**

* On crÃ©e une **fonction** qui sâ€™appelle `get_db` (Ã§a veut dire "prendre la base").
* Elle **ouvre une session** et la **donne** quand lâ€™appli en a besoin.

Câ€™est comme crÃ©er un **serveur** ğŸ‘¨â€ğŸ³ dans un resto : il **donne une table** au client et **apporte sa commande** (la session).

---

```python
db = SessionLocal()
```
ğŸ”¹ **`db = SessionLocal()`**  
- On **crÃ©e une nouvelle session** en appelant `SessionLocal()`.  
- Cela signifie que lâ€™application peut maintenant **communiquer avec la base de donnÃ©es** ğŸ“‚.  

Câ€™est comme **allumer une voiture** ğŸš— avant de commencer un trajet. La base de donnÃ©es est prÃªte Ã  rÃ©pondre aux demandes de lâ€™application.  

---

```python
try:
    yield db
```

ğŸ”¹ **`try:`** veut dire **"on essaye"**.
ğŸ”¹ **`yield db`** veut dire **"on donne la session Ã  lâ€™appli"** pour quâ€™elle lâ€™utilise.

Avec `yield`, la session reste **ouverte** pendant quâ€™elle est utilisÃ©e.


ğŸ‘‰ **Comme un ticket de manÃ¨ge ğŸ¡ :**

* Tu prends un ticket â†’ tu as une session.
* Tu montes â†’ la session reste ouverte.
* Le tour finit â†’ on rÃ©cupÃ¨re le ticket â†’ la session se ferme.

---

```python
finally:
    db.close()
```

ğŸ”¹ **`finally:`** = **"on exÃ©cute Ã§a Ã  la fin, quoi quâ€™il arrive"**
ğŸ”¹ **`db.close()`** = **"on ferme la session"**, pour bien libÃ©rer la place. âœ…

ğŸ‘‰ **Comme ranger la table au resto ğŸ½ï¸ :**

* Quand le client part, on **dÃ©barrasse**.
* Ici, on **ferme la session** pour quâ€™elle ne reste pas ouverte pour rien. âœ…

---

### ğŸ¯ **Pourquoi câ€™est important ?**

âŒ Trop de sessions ouvertes = base trop chargÃ©e ğŸ‹ï¸
âŒ Une session ouverte trop longtemps = dâ€™autres sont bloquÃ©s ğŸš§
âœ… Avec `get_db()`, la session est **ouverte quand il faut** et **fermÃ©e juste aprÃ¨s** ğŸ”„

---

### ğŸ“Œ **En rÃ©sumÃ© :**

âœ” **`get_db()`** crÃ©e et ferme les sessions tout seul âš™ï¸
âœ” **`yield db`** garde la session ouverte pendant lâ€™usage ğŸ”„
âœ” **`db.close()`** ferme tout Ã  la fin pour Ã©viter les blocages ğŸš¦
âœ” Comme un **resto bien organisÃ©** : chaque client a sa table, et on nettoie aprÃ¨s ğŸ½ï¸

FastAPI peut ainsi gÃ©rer la base **facilement et sans bugs** ! ğŸš€



#6

### ğŸŒ **Faire parler notre appli avec la base de donnÃ©es grÃ¢ce Ã  FastAPI !**

On a appris Ã  crÃ©er une **session** (un petit lien temporaire avec la base ğŸ“‚) pour que notre appli puisse aller chercher ou garder des infos.

### ğŸ“¡ **Faire rÃ©pondre notre appli avec FastAPI !**

Maintenant, on veut que notre appli **rÃ©ponde aux demandes des gens**. Par exemple, si quelquâ€™un veut voir **la liste des utilisateurs** dans un jeu ğŸ®, lâ€™appli doit savoir **chercher Ã§a dans la base** et **envoyer la rÃ©ponse**.

Câ€™est exactement ce quâ€™on va faire avec **FastAPI** ! ğŸš€

---

### ğŸ§ **On regarde le code ensemble !**

Voici comment on crÃ©e un **endpoint** (une porte dâ€™entrÃ©e vers les donnÃ©es) :

```python
from fastapi import Depends, FastAPI
from sqlalchemy.orm import Session
from database import SessionLocal
```

ğŸ”¹ **`from fastapi import Depends, FastAPI`**

* On **importe FastAPI** (lâ€™outil pour crÃ©er une API facilement).
* **`Depends`** sert Ã  utiliser une fonction (comme `get_db`) **sans lâ€™appeler nous-mÃªmes**.

ğŸ‘‰ **Câ€™est comme une prise Ã©lectrique âš¡** :

* Au lieu de brancher un appareil direct sur une batterie (trop compliquÃ©), on le met sur une prise qui **gÃ¨re tout toute seule**.
* Pareil, **`Depends(get_db)`** nous donne **une session avec la base** sans quâ€™on ait besoin de la faire nous-mÃªmes Ã  chaque fois. 

ğŸ”¹ **`from sqlalchemy.orm import Session`**

* On importe `Session`, qui est **une connexion temporaire avec la base** (juste pour un moment).
* Câ€™est comme **une ligne tÃ©lÃ©phonique ğŸ“** : on lâ€™ouvre, on parle avec la base, puis on raccroche.

ğŸ”¹ **`from database import SessionLocal`**

* On prend notre **usine Ã  sessions** ğŸ­ (elle fabrique des connexions avec la base) pour en crÃ©er une Ã  chaque demande.

---

```python
app = FastAPI()
```

ğŸ”¹ **`app = FastAPI()`**

* On crÃ©e notre **appli FastAPI**.
* Câ€™est comme **allumer un tÃ©lÃ©phone ğŸ“±** pour quâ€™il puisse recevoir des appels.

---

```python
@app.get("/users/")
```

ğŸ”¹ **`@app.get("/users/")`**

* On crÃ©e un **endpoint** (une adresse spÃ©ciale pour demander des infos).
* **"/users/"** veut dire que si quelquâ€™un tape cette adresse, lâ€™appli **va lui donner la liste des utilisateurs**.

ğŸ‘‰ **Câ€™est comme une sonnette de magasin ğŸšªğŸ””** :

* Quand quelquâ€™un appuie dessus (va sur `/users/`), le vendeur **ouvre et donne la liste des utilisateurs**.

---

```python
def read_users(db: Session = Depends(get_db)):
```

ğŸ”¹ **`def read_users(db: Session = Depends(get_db)):`**

* On crÃ©e une **fonction** pour rÃ©cupÃ©rer la liste des utilisateurs.
* **`db: Session`** = on a une **connexion temporaire avec la base** (juste le temps de parler).
* **`= Depends(get_db)`** = FastAPI **va chercher tout seul une session** en appelant `get_db()`.

ğŸ‘‰ **Câ€™est comme un resto ğŸ½ï¸ :**

* Le serveur prend une commande, mais au lieu dâ€™aller en cuisine, il envoie un **robot cuisinier ğŸ¤–** (`get_db`) qui va chercher les plats Ã  sa place.

---

```python
users = db.query(User).all()
```

ğŸ”¹ **`users = db.query(User).all()`**

* On demande Ã  la base : **"Donne-moi tous les utilisateurs !"**
* **`.query(User)`** = on cherche des infos sur les **utilisateurs**.
* **`.all()`** = on veut **toute la liste**.

ğŸ‘‰ **Câ€™est comme demander au bibliothÃ©caire ğŸ“š :**

* "Tu peux me donner la liste de tous les livres ?"
* Et il te donne **toute la liste** !

---

```python
return users
```

ğŸ”¹ **`return users`**

* On **renvoie** la liste des utilisateurs.
* FastAPI va **changer Ã§a tout seul** en un format que les applis et navigateurs comprennent (comme JSON).

ğŸ‘‰ **Câ€™est comme un distributeur de billets ğŸ’µ :**

* Tu demandes ("Je veux voir les utilisateurs").
* Lâ€™appli va chercher dans la base.
* Puis elle **te donne une rÃ©ponse lisible** (la liste des utilisateurs).

---

### ğŸ¯ **Pourquoi câ€™est super utile ?**

âœ… Les applis peuvent **rÃ©cupÃ©rer les donnÃ©es facilement**.
âœ… Avec **`Depends(get_db)`**, la connexion Ã  la base est **automatique et propre**.
âœ… On peut **ajouter dâ€™autres portes** (comme `/photos/`) pour dâ€™autres infos.

---

### ğŸ“Œ **En rÃ©sumÃ© :**

âœ” Avec **FastAPI**, notre appli peut **rÃ©pondre aux demandes**. âš¡
âœ” `@app.get("/users/")` crÃ©e **une adresse spÃ©ciale** pour voir les utilisateurs. ğŸ“¡
âœ” `Depends(get_db)` donne **automatiquement une session de base**. ğŸ”Œ
âœ” `db.query(User).all()` demande **toute la liste des utilisateurs**. ğŸ”„

Câ€™est comme un **resto automatique** ğŸ½ï¸ :

* Le client commande (`/users/`),
* Le serveur demande au robot (`Depends(get_db)`),
* Le robot prÃ©pare (`db.query(User).all()`),
* Et on sert le plat (`return users`).

GrÃ¢ce Ã  Ã§a, lâ€™API **parle avec la base** et **envoie les bonnes infos** vite et bien ! ğŸš€



#7

### ğŸ”„ **Pourquoi une nouvelle session Ã  chaque fois ?**

Quand une appli (comme un jeu ğŸ® ou un rÃ©seau social ğŸ“±) veut parler Ã  la base, elle envoie une **requÃªte** (une demande d'info ou une action).

ğŸ‘‰ **Mais attention !** Si tout le monde utilisait **la mÃªme session**, ce serait le **chaos total ğŸ˜µ** !

Câ€™est pour Ã§a que **FastAPI crÃ©e une nouvelle session Ã  chaque demande** et la **ferme bien quand câ€™est fini**. âœ…


---

### ğŸ  **Une session, câ€™est comme une chambre dâ€™hÃ´tel !**

Chaque visiteur reÃ§oit **sa propre chambre** ğŸ¨ pour poser ses affaires et dormir tranquille.

Quand il part :
âœ” La chambre est nettoyÃ©e ğŸ§¹
âœ” Elle est prÃªte pour le prochain ğŸ¡
âœ” Personne ne peut toucher Ã  ses affaires

ğŸ‘‰ Comme Ã§a, **chaque requÃªte a sa session privÃ©e**, sans tout mÃ©langer !

Une **session de base**, câ€™est **comme une chambre dâ€™hÃ´tel** :
âœ… **Chaque requÃªte a sa propre session**, comme chaque voyageur a sa chambre.
âœ… Quand câ€™est fini, **la session est fermÃ©e et nettoyÃ©e**.
âœ… Comme Ã§a, **pas de mÃ©lange de donnÃ©es**, chacun a son espace !

---

### ğŸ›‘ **Et si on ne fermait pas les sessions ?**

Si une appli garde ses sessions **ouvertes trop longtemps**, Ã§a peut devenir un **gros problÃ¨me** ğŸ˜± :

âŒ **Trop de sessions dâ€™un coup** = la base est saturÃ©e ğŸ‹ï¸, comme un hÃ´tel plein qui ne libÃ¨re jamais ses chambres.

âŒ **MÃ©lange de donnÃ©es** ğŸ”€ : Si deux demandes utilisent la **mÃªme session**, un utilisateur peut voir **les infos dâ€™un autre** ! Comme commander un burger ğŸ” et recevoir une pizza ğŸ• !

âŒ **ProblÃ¨mes dans les transactions** ğŸš§ : Dans une appli bancaire ğŸ’°, une session mal gÃ©rÃ©e peut **bloquer un virement**, et lâ€™argent reste coincÃ© entre deux comptes.


---

### ğŸ¯ **Pourquoi câ€™est super important ?**

ğŸš€ **CrÃ©er une session pour chaque demande**, Ã§a permet :
âœ” **Pas de mÃ©lange** entre les utilisateurs.
âœ” **Pas de surcharge** de la base.
âœ” **Tout est bien fini** avant de fermer la session.

Câ€™est comme un hÃ´tel ğŸ¨ bien organisÃ© : chaque chambre est propre et prÃªte.

RÃ©sultat : lâ€™appli reste **rapide, sÃ»re et bien rangÃ©e** ! ğŸ”¥




#8

### ğŸš€ **Lancer le serveur pour tester !**

Maintenant que lâ€™appli est prÃªte, il faut la **dÃ©marrer**.
Câ€™est comme **allumer une console de jeu ğŸ®** avant de jouer ou **ouvrir une appli de musique ğŸµ** avant dâ€™Ã©couter.

Pour lancer lâ€™appli, on tape :

```
$ uvicorn main:app --reload
```

---

### ğŸ” **On regarde la commande !**

ğŸ‘‰ **`uvicorn`**

* Câ€™est **le serveur** qui fait tourner lâ€™appli.
* Il **Ã©coute les demandes** et **envoie les rÃ©ponses**.
* Câ€™est comme **un chef dâ€™orchestre ğŸ¼** qui fait jouer la musique correctement.

ğŸ‘‰ **`main:app`**

* `main` = le nom du fichier (comme `main.py`)
* `app` = notre appli FastAPI dedans

Câ€™est comme dire : **"Va dans `main.py` et lance lâ€™appli quâ€™il y a dedans."**


ğŸ‘‰ **`--reload`**

* Permet de **redÃ©marrer tout seul** quand on change le code.
* Pas besoin de le faire Ã  la main Ã  chaque fois.
* Câ€™est comme une **feuille automatique ğŸ“Š** qui se met Ã  jour toute seule quand on change un chiffre.


---

### ğŸ“¡ **Tester lâ€™API sur notre ordi !**

Quand le serveur tourne, on peut tester en allant sur :

```
localhost:8000/users
```

ğŸ‘‰ **`localhost:8000`**, Ã§a veut dire :

* **`localhost`** = **mon ordi**
* **`8000`** = **le port** (le canal oÃ¹ lâ€™appli Ã©coute)

Câ€™est comme dire : **"HÃ© appli, montre-moi les utilisateurs !"**

---

### ğŸ“­ **Pourquoi la rÃ©ponse est vide ?**

Quand on fait une demande **GET** sur `/users`, FastAPI regarde dans la base et renvoie **la liste des utilisateurs**â€¦

Mais sâ€™il nâ€™y a encore **personne enregistrÃ©**, la liste est **vide** !

ğŸ‘‰ **Mais la liste est vide pour lâ€™instant !** ğŸ˜•

* Ã‡a veut dire que **personne nâ€™a encore Ã©tÃ© ajoutÃ©**.
* Câ€™est comme **ouvrir une nouvelle boÃ®te aux lettres ğŸ“¬** et voir quâ€™il nâ€™y a **pas encore de courrier**.
  

---

### ğŸ¯ **Pourquoi câ€™est important ?**

âœ… **Lancer le serveur** permet dâ€™utiliser lâ€™API pour de vrai.
âœ… **Tester avec `/users`** vÃ©rifie si tout marche bien.
âœ… **La liste vide**, câ€™est normal au dÃ©but : on ajoutera des utilisateurs plus tard.

GrÃ¢ce Ã  Ã§a, lâ€™API est **prÃªte sur notre ordi** et peut recevoir des infos ! ğŸš€