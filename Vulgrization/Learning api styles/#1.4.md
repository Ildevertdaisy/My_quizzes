#1

---

## ğŸ§© Une application en â€œmorceaux indÃ©pendantsâ€ (architecture modulaire)

Quand on crÃ©e une appli aujourdâ€™hui (par exemple : un site de rÃ©servation de voyage ğŸ›«), on nâ€™Ã©crit pas tout dans un seul bloc.

â¡ï¸ On sÃ©pare les choses :

* Une partie sâ€™occupe de **la recherche dâ€™hÃ´tels** ğŸ¨
* Une autre gÃ¨re **les paiements** ğŸ’³
* Une autre sâ€™occupe des **emails de confirmation** ğŸ“§

Chaque partie est appelÃ©e un **composant** (ou **service**).

Et ces services **parlent entre eux grÃ¢ce Ã  des APIs** ğŸ“¡

---

## ğŸ® Analogie simple : comme un jeu vidÃ©o en modules

Imagine un jeu vidÃ©o ğŸ® :

* Un module sâ€™occupe du son ğŸ”Š
* Un autre des scores ğŸ§®
* Un autre de lâ€™affichage ğŸ‘¾

â¡ï¸ Si tu veux **changer la musique**, tu modifies juste le module du son.
Tu ne touches pas aux autres.

ğŸ’¡ GrÃ¢ce aux APIs, tous ces modules **peuvent se parler** sans dÃ©pendre les uns des autres.

---

## ğŸ¤ Les APIs permettent **lâ€™interopÃ©rabilitÃ©**

â¡ï¸ Ã‡a veut dire que **des systÃ¨mes diffÃ©rents peuvent travailler ensemble**, comme une montre connectÃ©e qui parle avec ton tÃ©lÃ©phone ğŸ“±âŒš, ou une appli qui utilise Google Maps pour tâ€™afficher une carte ğŸ—ºï¸.

Chaque systÃ¨me a **sa propre API** qui dit :

> â€œVoici comment me parler : tu peux mâ€™envoyer ce type de demande, je te renverrai Ã§a.â€

Et mÃªme si les systÃ¨mes sont trÃ¨s diffÃ©rents (Android, iOS, Linux...), **Ã§a fonctionne**, grÃ¢ce Ã  cette **langue commune**.

---

## ğŸ› ï¸ Et Ã§a ouvre la porte Ã  une nouvelle faÃ§on de crÃ©er : **les microservices**

Les **microservices**, câ€™est une mÃ©thode oÃ¹ une application est construite **comme une collection de petits programmes sÃ©parÃ©s**, chacun avec une fonction bien prÃ©cise.

â¡ï¸ Chaque microservice a **sa propre API** pour se connecter au reste.

ğŸ’¡ Exemples :

* Dans une **appli bancaire**, un service gÃ¨re les virements, un autre les notifications, un autre la connexion.
* Dans une **appli de vente**, un service gÃ¨re les stocks, un autre les livraisons, un autre les retours.

GrÃ¢ce aux APIs, **chaque partie peut Ã©voluer seule**, Ãªtre dÃ©placÃ©e, amÃ©liorÃ©e, ou mÃªme utilisÃ©e dans une autre appli ğŸ”

---

## ğŸ¯ RÃ©sumÃ© trÃ¨s simple

* Les APIs permettent de **dÃ©couper une application** en **petits services indÃ©pendants**.
* Chaque service peut **travailler seul**, mais aussi **discuter avec les autres**.
* Câ€™est comme si chaque piÃ¨ce dâ€™un puzzle pouvait Ãªtre remplacÃ©e sans refaire tout le puzzle ğŸ§©âœ¨
* Ã‡a rend les applis **plus souples, plus faciles Ã  entretenir**, et prÃªtes Ã  Ã©voluer dans le temps.

---



#2


---

## ğŸ’¼ Pourquoi les APIs sont utiles pour une entreprise ?

Une entreprise, peu importe son domaine (voyage, musique, transport, banque...), veut **Ãªtre efficace et rentable** ğŸ’°

Aujourdâ€™hui, **presque toutes les entreprises utilisent des logiciels** pour vendre, organiser, ou communiquer. Et comme **tout est de plus en plus connectÃ©**, il devient indispensable de **faire parler les logiciels entre eux**.

â¡ï¸ Câ€™est exactement ce que font les **APIs** (les portes dâ€™entrÃ©e qui permettent aux logiciels de se parler entre eux).

---

## ğŸ¯ Exemples trÃ¨s concrets de ce que les APIs permettent

### 1. CrÃ©er de nouvelles **sources de revenus** ğŸ’¸

ğŸ‘‰ Câ€™est-Ã -dire : **gagner de lâ€™argent dâ€™une nouvelle faÃ§on** grÃ¢ce aux APIs.

#### ğŸ’¡ Exemple avec des sites de voyage :

* Des sites comme **skyscanner.com** ou **booking.com** **ne possÃ¨dent pas directement des avions ou des hÃ´tels**.
* Ce sont des **agrÃ©gateurs**, câ€™est-Ã -dire quâ€™ils vont **chercher les infos chez dâ€™autres services** (compagnies aÃ©riennes, chaÃ®nes dâ€™hÃ´tels...) via leurs **APIs**.

â¡ï¸ Ces sites envoient des questions comme :

> â€œDonne-moi les vols Paris â†’ Rome le 10 avrilâ€
> â€œQuels hÃ´tels Ã  New York coÃ»tent moins de 150 â‚¬ ?â€

Et les APIs leur renvoient les rÃ©sultats, quâ€™ils affichent **dans leur propre interface**.

RÃ©sultat :

* Lâ€™utilisateur peut **choisir et rÃ©server** en quelques clics âœˆï¸ğŸ¨
* Lâ€™hÃ´tel ou la compagnie gagne un client ğŸ’¼
* Et **lâ€™agrÃ©gateur aussi touche une commission** ğŸ’µ

---

## ğŸ” Tout le monde y gagne

* Lâ€™**hÃ´tel** vend plus de chambres ğŸ›ï¸
* Le **client** trouve une bonne offre facilement ğŸ“±
* Le **site (API aggregator)** prend un petit pourcentage ğŸ§¾
* Et lâ€™entreprise qui fournit lâ€™API gagne aussi (elle peut vendre son API comme un produit)

---

## ğŸ’¬ Câ€™est comme un **supermarchÃ© numÃ©rique** :

Imagine une appli qui fait les courses Ã  ta place :

* Elle appelle lâ€™API de Carrefour pour le lait,
* Lâ€™API dâ€™Auchan pour les biscuits,
* Et celle dâ€™IntermarchÃ© pour les promotions.

Tout est **regroupÃ© dans une seule appli**, et Ã  la fin :

* Tu paies,
* Chaque supermarchÃ© reÃ§oit sa part,
* Et lâ€™appli gagne un peu en passant.

â¡ï¸ Câ€™est **le mÃªme principe** que Booking ou Skyscanner, mais appliquÃ© Ã  **plein d'autres domaines**.

---

## ğŸ“Š Et câ€™est une vraie tendance !

Dâ€™aprÃ¨s des Ã©tudes, **plus de la moitiÃ© des revenus** de certains grands groupes comme :

* **Salesforce** (logiciels pour les entreprises),
* **eBay** (achat/vente en ligne),
* ou **Expedia** (voyages en ligne),

â¡ï¸ viennent **des APIs**. Pas juste des applis visibles, mais **des connexions entre services**.

---

## ğŸ§  RÃ©sumÃ© trÃ¨s simple

* Les APIs permettent aux entreprises de **se connecter et dâ€™Ã©changer des donnÃ©es automatiquement**.
* Des sites comme **Booking ou Skyscanner** gagnent de lâ€™argent en **utilisant les APIs dâ€™autres entreprises**.
* Les APIs deviennent alors **des outils pour vendre plus**, pour se faire connaÃ®tre, ou mÃªme pour crÃ©er un **nouveau business** Ã  part entiÃ¨re.
* Aujourdâ€™hui, dans **presque tous les secteurs** (santÃ©, Ã©ducation, commerce, transport), **les APIs sont devenues essentielles**.

---



#3

---

## ğŸŒ 1. Les APIs permettent de **toucher plus de monde**

Prenons lâ€™exemple de **Zoom** (le cÃ©lÃ¨bre outil de visioconfÃ©rence) ğŸ¥ :

* Zoom nâ€™est pas seulement disponible sur un site web.
* On peut aussi lâ€™utiliser **sur tÃ©lÃ©phone**, **tablette**, **ordinateur**, ou mÃªme **tÃ©lÃ© connectÃ©e**.

ğŸ‘‰ Et tout Ã§a est possible grÃ¢ce aux **APIs** que Zoom met Ã  disposition.

â¡ï¸ Quand une entreprise **ouvre ses APIs aux dÃ©veloppeurs**, Ã§a veut dire quâ€™elle autorise dâ€™autres applis ou appareils Ã  **se connecter Ã  son service**.

### ğŸ¯ RÃ©sultat ?

* Tu peux rejoindre un appel Zoom depuis presque **nâ€™importe quel appareil** ğŸ“±ğŸ–¥ï¸ğŸ“º
* Zoom peut **atteindre beaucoup plus dâ€™utilisateurs**, mÃªme ceux qui nâ€™utilisent pas le site.
* Donc, **lâ€™entreprise gagne plus de visibilitÃ©** et potentiellement plus dâ€™utilisateurs ou de clients ğŸ’¼ğŸŒ

---

## ğŸ¤– 2. Les APIs donnent accÃ¨s Ã  **des technologies avancÃ©es**

Lâ€™autre exemple vient de **GitHub Copilot**, lancÃ© en 2021 par GitHub et basÃ© sur un modÃ¨le de langage (comme moi ğŸ˜‰) dÃ©veloppÃ© par **OpenAI**.

### ğŸ’¡ Quâ€™est-ce que GitHub Copilot ?

Câ€™est un outil qui **aide les dÃ©veloppeurs Ã  Ã©crire du code plus vite**, en suggÃ©rant automatiquement des lignes de code.

Mais pour que Ã§a fonctionne, GitHub a utilisÃ© une **API fournie par OpenAI**, ce qui veut dire :

> â€œOpenAI nous donne une porte dâ€™accÃ¨s pour quâ€™on puisse utiliser leur technologie, sans devoir tout rÃ©inventer.â€

â¡ï¸ GrÃ¢ce Ã  cette API, GitHub a pu **connecter leur application** au modÃ¨le GPT (entraÃ®nÃ© sur des millions de lignes de code), et ainsi transformer Copilot en **assistant intelligent pour les programmeurs**.

---

### ğŸ¯ RÃ©sultat ?

* GitHub **gagne du temps** : pas besoin de crÃ©er toute lâ€™intelligence tout seul.
* OpenAI **rend ses outils disponibles** Ã  dâ€™autres entreprises, en toute sÃ©curitÃ©.
* Et les utilisateurs finaux (les dÃ©veloppeurs) profitent dâ€™un outil **ultra pratique et intelligent** âœ¨

---

## ğŸ“š RÃ©sumÃ© trÃ¨s simple :

| Avantage                                | Ce que Ã§a veut dire en pratique                     | Exemple concret ğŸ§ª                    |
| --------------------------------------- | --------------------------------------------------- | ------------------------------------- |
| ğŸŒ Toucher plus de monde                | Utiliser une appli sur diffÃ©rents appareils         | Zoom sur smartphone, PC, TV...        |
| ğŸ¤– AccÃ©der Ã  des technologies de pointe | Utiliser des outils intelligents crÃ©Ã©s par dâ€™autres | GitHub Copilot grÃ¢ce Ã  lâ€™API dâ€™OpenAI |

---



#4

---

## ğŸ§  Rappel rapide : une API, câ€™est quoi ?

Une **API** est une **porte dâ€™entrÃ©e numÃ©rique** que les programmes utilisent pour :

* demander des infos ğŸ“¬,
* envoyer des donnÃ©es ğŸ“¤,
* ou faire une action (comme payer ou ajouter un produit au panier) ğŸ›’.

Mais selon **qui a le droit dâ€™utiliser cette porte**, on classe les APIs en trois catÃ©gories :
â¡ï¸ **PrivÃ©e**, **Publique**, ou **Partenaire**.

---

## ğŸ”’ 1. API **PrivÃ©e** = rÃ©servÃ©e Ã  lâ€™intÃ©rieur de lâ€™entreprise

â¡ï¸ Ce type dâ€™API est **utilisÃ© uniquement en interne**.
Câ€™est comme une **porte secrÃ¨te** que seuls les employÃ©s peuvent ouvrir ğŸ”

### ğŸ’¡ Exemple concret :

* Une entreprise de transport a une API qui permet de **suivre lâ€™emplacement des camions** ğŸšš.
* Cette API est utilisÃ©e **par les Ã©quipes internes** (comme les chauffeurs ou les managers), mais **pas accessible au public**.

ğŸ¯ Objectif : faire **communiquer les Ã©quipes** entre elles, de faÃ§on organisÃ©e.

---

## ğŸŒ 2. API **Publique** = ouverte Ã  tout le monde

â¡ï¸ Cette API est **disponible pour tout le monde** :
nâ€™importe quel dÃ©veloppeur ou entreprise peut sâ€™en servir (parfois gratuitement, parfois payant).

### ğŸ’¡ Exemple concret :

* Le site **open-meteo.com** propose une API mÃ©tÃ©o.
  Tu peux demander : â€œQuel temps fera-t-il demain Ã  Paris ?â€ ğŸŒ¦ï¸
* Tu peux lâ€™utiliser dans une **appli de randonnÃ©e**, un **outil agricole**, ou un **assistant personnel**.

â¡ï¸ Parfois câ€™est **gratuit pour un usage personnel**, mais **payant pour un usage commercial** (comme une entreprise qui vend un service mÃ©tÃ©o).

---

## ğŸ¤ 3. API **Partenaire** = partagÃ©e avec des entreprises spÃ©cifiques

â¡ï¸ Cette API nâ€™est **ni totalement privÃ©e**, ni totalement ouverte.
Elle est **accessible uniquement aux partenaires** de lâ€™entreprise.

Câ€™est comme une **porte spÃ©ciale pour les amis de confiance** ğŸšªğŸ¤

### ğŸ’¡ Exemple concret :

* Une **banque** partage une API avec une appli de gestion de budget (comme Bankin' ou Linxo) ğŸ¦ğŸ“².
* Lâ€™API nâ€™est pas publique, mais la banque accepte que **ses partenaires autorisÃ©s** lâ€™utilisent.

ğŸ¯ Objectif : permettre une **collaboration ciblÃ©e**, **sans ouvrir tout au monde entier**.

---

## ğŸ§¾ RÃ©sumÃ© trÃ¨s clair avec une comparaison simple :

| Type dâ€™API     | Qui peut lâ€™utiliser ? ğŸ§‘â€ğŸ’»             | Exemple concret ğŸ“±                | Comparaison imagÃ©e ğŸ”‘            |
| -------------- | --------------------------------------- | --------------------------------- | -------------------------------- |
| **PrivÃ©e**     | Seulement les employÃ©s dâ€™une entreprise | Suivi des stocks internes ğŸ“¦      | Une **porte de bureau privÃ©e**   |
| **Publique**   | Tout le monde ğŸŒ                        | Appli mÃ©tÃ©o, carte, monnaie ğŸŒ¡ï¸ğŸ’± | Une **entrÃ©e de magasin** ğŸšª     |
| **Partenaire** | Les partenaires autorisÃ©s ğŸ¤            | Appli bancaire, services liÃ©s ğŸ’³  | Une **porte avec badge VIP** ğŸ·ï¸ |

---

## ğŸ’¬ Pourquoi câ€™est important de savoir Ã§a ?

* Parce que selon le **type dâ€™API**, les **droits dâ€™accÃ¨s** changent.
* Et Ã§a influence :

  * **ce que tu peux construire avec**,
  * **comment tu lâ€™utilises** (gratuite, payante, limitÃ©e...),
  * et **Ã  qui tu la proposes** si tu crÃ©es une application.

---

#5

---

## ğŸ§± Une API peut avoir **plusieurs styles**, comme un bÃ¢timent peut avoir **plusieurs formes**

Imaginons quâ€™on parle **de maisons ou de chÃ¢teaux**.
Il y a plein de maniÃ¨res de les construire, selon :

* le pays ğŸŒ,
* lâ€™Ã©poque â³,
* les matÃ©riaux ğŸ§±,
* et les goÃ»ts (plutÃ´t simple ou dÃ©corÃ© ?) ğŸ¨

Par exemple :

* Une maison **romaine** nâ€™a pas le mÃªme style quâ€™une **maison moderne**.
* Un **chÃ¢teau mÃ©diÃ©val** est diffÃ©rent dâ€™un **immeuble en verre dâ€™aujourdâ€™hui**.

Chaque type de construction a **un nom**, un style, une maniÃ¨re de faire.

---

## ğŸ§© Eh bien pour les APIs, câ€™est **pareil**

Quand des dÃ©veloppeurs crÃ©ent une API, ils doivent choisir **un style**.
Câ€™est une maniÃ¨re de **dÃ©finir comment lâ€™API fonctionne, sâ€™organise et communique**.

ğŸ’¡ Ces styles ont chacun :

* Leur propre faÃ§on dâ€™Ã©crire les messages,
* Leur propre maniÃ¨re de connecter les programmes,
* Des rÃ¨gles spÃ©cifiques Ã  suivre (comme un plan de construction ğŸ—ï¸).

---

### ğŸ§  Quelques styles dâ€™API (quâ€™on va Ã©tudier ensuite) :

* **REST** : le plus simple, trÃ¨s utilisÃ© sur le web ğŸŒ
* **SOAP** : plus strict, souvent utilisÃ© dans les entreprises ğŸ¢
* **GraphQL** : plus moderne, trÃ¨s prÃ©cis ğŸ¯
* **gRPC** : trÃ¨s rapide, souvent utilisÃ© pour les machines qui doivent aller vite âš¡

---

## ğŸ˜ï¸ Une analogie pour bien comprendre :

Imagine que tu veux construire un **village** dâ€™applications :

* Une **API de style REST**, câ€™est comme une **maison moderne avec un plan trÃ¨s simple**, facile Ã  comprendre ğŸ¡
* Une **API de style SOAP**, câ€™est comme un **chÃ¢teau avec beaucoup de rÃ¨gles et de portes sÃ©curisÃ©es** ğŸ°
* Une **API GraphQL**, câ€™est comme un **appartement modulable** : tu choisis exactement ce dont tu as besoin ğŸ§©
* Une **API gRPC**, câ€™est une **maison connectÃ©e ultra rapide**, faite pour des Ã©changes rapides entre robots ou machines ğŸ¤–

---

## ğŸ¯ En rÃ©sumÃ© trÃ¨s simple :

* Un **style dâ€™API**, câ€™est **une maniÃ¨re de construire** et dâ€™organiser une API.
* Comme dans lâ€™architecture des bÃ¢timents, **chaque style a ses caractÃ©ristiques**, ses rÃ¨gles et ses avantages.
* Selon le besoin (exemple : un site web simple, une usine connectÃ©e, une appli mÃ©tÃ©oâ€¦), on ne choisira **pas le mÃªme style dâ€™API**.

---



#6

---

## ğŸ§± Un **style dâ€™API**, câ€™est comme un **style de construction**

Imagine que tu veux construire une maison ou une Ã©cole ğŸ¡ğŸ«. Tu peux choisir :

* des matÃ©riaux (bois, bÃ©tonâ€¦),
* une forme (moderne, ancienneâ€¦),
* et un plan (avec ou sans couloir, Ã©tage ou pasâ€¦).

ğŸ‘‰ Tout Ã§a ensemble forme un **style architectural** (par exemple : style grec, victorien, moderne, etc.).

De la mÃªme maniÃ¨re, quand on crÃ©e une **API**, on peut choisir **un style dâ€™organisation**, quâ€™on appelle **style dâ€™API**.

---

## ğŸ¯ Câ€™est quoi exactement un â€œstyle dâ€™APIâ€ ?

Câ€™est un **ensemble de rÃ¨gles et de bonnes habitudes** quâ€™on suit pour :

1. Construire une API (câ€™est-Ã -dire **comment elle est organisÃ©e**) ğŸ§©
2. Lâ€™utiliser (**comment on envoie les messages**) ğŸ’¬
3. Et la rendre claire et pratique pour dâ€™autres applications ou utilisateurs ğŸ“¦

Ce style dÃ©finit :

* les **modÃ¨les** (comme la faÃ§on dont on nomme les adresses),
* les **rÃ¨gles de communication** (ce quâ€™on peut demander et comment),
* et mÃªme le **comportement** de lâ€™API.

---

## ğŸ§  Une analogie trÃ¨s simple

Imagine que tu veux **jouer Ã  un jeu de sociÃ©tÃ©** avec dâ€™autres enfants ğŸ² :

* Il y a **plusieurs types de jeux** (jeu de cartes, jeu de plateau, jeu de rÃ´leâ€¦).
* Chaque type a ses propres **rÃ¨gles, faÃ§ons de jouer, faÃ§ons de gagner**.

Eh bien une API fonctionne pareil :
â¡ï¸ Tu choisis un **style dâ€™API**, qui est comme **le type de jeu**.
â¡ï¸ Ensuite, tu **suis ses rÃ¨gles** pour crÃ©er ton API et la faire fonctionner correctement.

---

## ğŸ•°ï¸ Comme en architecture, les styles dâ€™API changent avec le temps

â¡ï¸ Certains styles dâ€™API deviennent **trÃ¨s populaires pendant un moment** (comme les maisons modernes aujourdâ€™hui),
â¡ï¸ Puis dâ€™autres prennent la place, plus adaptÃ©s Ã  de nouveaux besoins.

ğŸ’¡ Par exemple :

* Le style **SOAP** Ã©tait Ã  la mode dans les annÃ©es 2000 ğŸ“œ
* Le style **REST** est devenu super courant dans les annÃ©es 2010 ğŸŒ
* Puis sont arrivÃ©s **GraphQL** et **gRPC**, qui sont plus rÃ©cents et modernes âœ¨

---

## ğŸ“š RÃ©sumÃ© super simple :

| Terme                  | Explication en langage trÃ¨s simple ğŸ§’                                |
| ---------------------- | -------------------------------------------------------------------- |
| **Style dâ€™API**        | Une faÃ§on bien prÃ©cise de construire et organiser une API            |
| **Paradigme**          | Une mÃ©thode ou un modÃ¨le de pensÃ©e (comme un mode de fonctionnement) |
| **Pattern / pratique** | Des bonnes habitudes ou des modÃ¨les Ã  suivre                         |
| **Protocole**          | Les rÃ¨gles Ã  respecter pour que tout le monde se comprenne           |

ğŸ¯ Les styles dâ€™API ont :

* un **but** (exemple : faire simple, faire rapide...),
* un **fonctionnement** spÃ©cifique,
* et ils **changent avec le temps**, comme les modes en vÃªtements ğŸ‘— ou en technologies ğŸ“±

---


#7

---

## ğŸ¼ Une API, câ€™est comme un **groupe de musique**

Un groupe de musique peut utiliser **les mÃªmes instruments** : guitare, batterie, basse, clavier, voix ğŸ¹ğŸ¥ğŸ¤
Mais malgrÃ© Ã§a, le groupe peut faire :

* du rock ğŸ¸,
* du reggae ğŸŒ´,
* de la pop ğŸ’ƒ,
* ou du jazz ğŸ·.

ğŸ‘‰ Ce qui change, ce nâ€™est pas lâ€™instrument, mais **la faÃ§on dont on les utilise ensemble**.
â¡ï¸ Câ€™est ce quâ€™on appelle le **style**.

---

## ğŸ§± MÃªme chose pour les APIs

Tous les styles dâ€™API utilisent un peu les **mÃªmes â€œinstrumentsâ€** :

* des **protocoles** (les rÃ¨gles pour envoyer les messages),
* des **mÃ©thodes** (les faÃ§ons de demander ou dâ€™envoyer des choses),
* et des **modÃ¨les de conception** (comment lâ€™API est structurÃ©e).

Mais selon **comment on assemble tout Ã§a**, on a un style diffÃ©rent :

* REST ğŸ§©
* GraphQL ğŸ¯
* gRPC âš¡
* SOAP ğŸ“œ
  â€¦ et dâ€™autres.

---

## ğŸ¯ Ce qui dÃ©finit un **style dâ€™API**, câ€™est ce qui **domine**

MÃªme si deux APIs utilisent le mÃªme protocole ou les mÃªmes formats (comme JSON ou XML), ce qui fait quâ€™on dit â€œÃ§a câ€™est RESTâ€ ou â€œÃ§a câ€™est GraphQLâ€, câ€™est le style principal, **la logique gÃ©nÃ©rale**.

Câ€™est comme si :

* Deux groupes ont une guitare Ã©lectrique,
* Mais lâ€™un fait du mÃ©tal et lâ€™autre de la pop :
  â¡ï¸ On **les reconnaÃ®t par le style**, pas juste par les outils ğŸ¸ğŸµ

---

## ğŸ’¡ Exemple avec REST (le style le plus connu)

* Une API REST **utilise les rÃ¨gles du web** pour faire des actions :
  â¤ â€œlire une ressourceâ€ (GET),
  â¤ â€œajouter une ressourceâ€ (POST), etc.

* Il suit une sÃ©rie de **rÃ¨gles prÃ©cises**, comme :

  * Chaque ressource a sa propre adresse (URL),
  * Les actions sont bien dÃ©finies (comme POST, GET, PUTâ€¦),
  * Et dans la version vraiment complÃ¨te (RESTful), il faut mÃªme que les rÃ©ponses **contiennent des liens** vers dâ€™autres actions possibles (ce quâ€™on appelle **hypermedia**).

ğŸ¯ Mais beaucoup dâ€™APIs qui disent â€œje suis RESTâ€ ne suivent **pas toutes les rÃ¨gles**, notamment celle des hyperliens. Donc techniquement, elles sont REST-ish (presque REST ğŸ˜…).

---

## ğŸ® Exemple dans une appli rÃ©elle :

Imaginons une appli de recettes de cuisine ğŸ“²ğŸ

* Si elle utilise une API REST, elle pourrait avoir :

  * `/recettes` â†’ liste toutes les recettes disponibles
  * `/recettes/42` â†’ montre la recette numÃ©ro 42
  * `/recettes/42/ingredients` â†’ donne les ingrÃ©dients de cette recette

â¡ï¸ Tu accÃ¨des Ã  chaque chose **par une adresse claire**, et tu sais quoi faire grÃ¢ce aux **actions standard** (GET, POSTâ€¦).

---

## ğŸ“š RÃ©sumÃ© super simple

| Ã‰lÃ©ment                   | Version simplifiÃ©e ğŸ§’                                                         |
| ------------------------- | ----------------------------------------------------------------------------- |
| Style dâ€™API               | Une **maniÃ¨re de concevoir et organiser** une API (comme un style musical ğŸµ) |
| Instruments de base       | Protocoles, formats, mÃ©thodes (toujours un peu les mÃªmes ğŸ§°)                  |
| Ce qui fait la diffÃ©rence | **Comment on combine** ces outils pour crÃ©er une expÃ©rience spÃ©cifique ğŸ§©     |
| REST                      | Un style trÃ¨s rÃ©pandu, basÃ© sur les rÃ¨gles du web ğŸŒ                          |

---



#8

---

## ğŸ§  1. Style dâ€™API **basÃ© sur des requÃªtes (query-based)**

### ğŸ’¬ Câ€™est quoi lâ€™idÃ©e ?

Câ€™est un style oÃ¹ **tu poses une question trÃ¨s prÃ©cise** Ã  lâ€™API, et **tu reÃ§ois exactement ce que tu as demandÃ©**, rien de plus.

â¡ï¸ On appelle Ã§a â€œquery-basedâ€ car le mot **query** signifie **requÃªte** (ou â€œdemande prÃ©ciseâ€).

---

### ğŸ’¡ Exemple rÃ©el avec **GraphQL**

GraphQL est une API query-based trÃ¨s connue.
Tu peux dire Ã  lâ€™API :

> â€œJe veux le nom et lâ€™image de la recette numÃ©ro 5,
> mais je ne veux **pas** les ingrÃ©dients ni les Ã©tapes.â€

Lâ€™API **te donne juste ce que tu as demandÃ©**, sans tâ€™envoyer un tas dâ€™autres infos inutiles ğŸ§ ğŸ“¦

---

### ğŸ¯ Exemple concret dans une appli :

Imaginons une **appli de cinÃ©ma** :

* Lâ€™utilisateur demande juste : le **titre du film**, et la **note du public**.
* Lâ€™API rÃ©pond uniquement avec ces 2 infos, **et pas le rÃ©sumÃ©, les acteurs, la durÃ©eâ€¦**

Cela permet :

* Dâ€™aller **plus vite** ğŸƒ
* Dâ€™Ã©conomiser des donnÃ©es (trÃ¨s utile sur mobile ğŸ“±)
* Et dâ€™avoir une **rÃ©ponse personnalisÃ©e** ğŸ§©

---

## ğŸŒŠ 2. Style dâ€™API **de type â€œflux webâ€ (web feed)**

### ğŸ’¬ Câ€™est quoi lâ€™idÃ©e ?

Ici, lâ€™API envoie **du contenu mis Ã  jour rÃ©guliÃ¨rement**,
comme **un flux dâ€™actualitÃ©s**, sans quâ€™on ait besoin de demander Ã  chaque fois.

â¡ï¸ On appelle Ã§a un **â€œfluxâ€**, car les infos **sâ€™Ã©coulent automatiquement**, un peu comme de lâ€™eau ğŸ’§

---

### ğŸ’¡ Exemples trÃ¨s connus : **RSS** et **Atom**

Ces deux technologies permettent :

* De suivre les nouveaux articles dâ€™un site,
* De recevoir les derniÃ¨res vidÃ©os dâ€™une chaÃ®ne,
* Ou dâ€™afficher les derniÃ¨res alertes mÃ©tÃ©o ğŸŒ¦ï¸

Le tout **automatiquement**, sans ouvrir le site Ã  chaque fois.

---

### ğŸ¯ Exemple concret dans la vraie vie :

* Une **appli de blog** utilise un flux RSS pour afficher les derniers articles dÃ¨s quâ€™ils sont publiÃ©s ğŸ“°
* Une **appli mÃ©tÃ©o** utilise un flux XML pour recevoir les prÃ©visions du jour **en continu**, sans redemander Ã  chaque fois â˜ï¸ğŸŒ¡ï¸
* Une **appli dâ€™actualitÃ©s** reÃ§oit les titres de plusieurs journaux Ã  la suite, automatiquement ğŸ—ï¸

---

## ğŸ§¾ RÃ©sumÃ© ultra simple

| Style dâ€™API           | Fonction principale ğŸ”                                                     | Exemple dâ€™application ğŸ“±        |
| --------------------- | -------------------------------------------------------------------------- | ------------------------------- |
| Query-based (GraphQL) | Lâ€™appli **pose une question prÃ©cise**, reÃ§oit **juste ce quâ€™elle veut** ğŸ¯ | Une app de films ou de recettes |
| Web feed (RSS, Atom)  | Lâ€™appli **reÃ§oit les nouveautÃ©s toute seule**, rÃ©guliÃ¨rement ğŸ”„            | Une app de mÃ©tÃ©o ou de blog     |

---

## ğŸ§  Ã€ retenir :

* Un **style dâ€™API** est une **faÃ§on dâ€™organiser lâ€™Ã©change de donnÃ©es**.
* Le style **query-based** est parfait quand on veut Ãªtre **trÃ¨s prÃ©cis dans ce quâ€™on reÃ§oit**.
* Le style **web feed** est parfait quand on veut **rester Ã  jour automatiquement** sur du contenu.

---



#9

---

## ğŸ“ Quâ€™est-ce que le style **RPC** (Remote Procedure Call) ?

Imaginons que tu veux **allumer la lumiÃ¨re dans ta chambre**, mais que lâ€™interrupteur se trouve **dans une autre maison** ğŸ ğŸ”¦

â¡ï¸ Avec le style RPC, tu appuies sur un bouton chez toi, et **quelquâ€™un dans lâ€™autre maison fait lâ€™action Ã  ta place**.

Mais pour toi, **Ã§a ressemble Ã  un interrupteur classique**, comme sâ€™il Ã©tait chez toi.

ğŸ¯ Câ€™est Ã§a le style RPC :

> Tu appelles une action (comme une fonction), elle sâ€™exÃ©cute **ailleurs**, et tu reÃ§ois le rÃ©sultat **comme si câ€™Ã©tait ici**.

---

## ğŸ§  Comment Ã§a marche (en trÃ¨s simplifiÃ©)

1. **Ton application (le client RPC)** envoie une commande Ã  distance ğŸ“¤.
2. Cette commande va sur un **serveur RPC**, qui sait comment exÃ©cuter lâ€™action.
3. Le serveur **fait le travail demandÃ©** (comme un calcul, une recherche, une action).
4. Il **renvoie la rÃ©ponse** Ã  ton application ğŸ“©.

Et pour toi, tout Ã§a se fait **comme une simple commande**, sans que tu aies besoin de savoir oÃ¹ le travail a Ã©tÃ© fait ğŸ§©

---

## âš™ï¸ Et quâ€™est-ce que **gRPC** ?

**gRPC** est un outil moderne (crÃ©Ã© par Google) qui applique ce style RPC, mais :

* en Ã©tant **trÃ¨s rapide** âš¡,
* en **compressant les messages** (pour quâ€™ils soient plus lÃ©gers),
* et en permettant Ã  **plein de machines** de se parler trÃ¨s efficacement.

---

## ğŸ’¡ Exemples dâ€™applications rÃ©elles qui utilisent RPC ou gRPC :

### ğŸ® Dans les jeux vidÃ©o en ligne

Quand tu joues, ton personnage saute, tire, ou bouge.
Mais tous les calculs (scores, collisions, actions) peuvent Ãªtre faits **sur un serveur Ã  distance**, qui te renvoie le rÃ©sultat **presque instantanÃ©ment**.

â¡ï¸ Ton jeu envoie une commande â€œsauteâ€,
le serveur calcule le saut, et te renvoie le mouvement du personnage.

---

### ğŸ­ Dans les systÃ¨mes industriels

Des **robots dans une usine** envoient des ordres Ã  une machine pour faire une tÃ¢che (comme couper, trier, etc.).

â¡ï¸ Le robot utilise une API RPC pour dire Ã  une autre machine : â€œFais cette action maintenantâ€,
et il reÃ§oit la confirmation une fois que câ€™est fait.

---

### ğŸ“± Dans les applis modernes (comme celles de banque ou dâ€™assistance vocale)

Ton appli peut envoyer une requÃªte pour calculer quelque chose (par exemple : â€œcombien me reste-t-il sur mon compte si je paye 85 â‚¬ ?â€).
Et cette action est **faite sur un serveur**, avec la rÃ©ponse qui revient **en quelques secondes**.

---

## ğŸ“š RÃ©sumÃ© trÃ¨s simple

| Ã‰lÃ©ment clÃ©                 | Explication simple ğŸ§’                                                    |
| --------------------------- | ------------------------------------------------------------------------ |
| RPC (Remote Procedure Call) | Une commande qui est **exÃ©cutÃ©e Ã  distance**, mais qui **semble locale** |
| gRPC                        | Une version moderne, **rapide et optimisÃ©e**, du style RPC âš¡             |
| Utilisation typique         | Appels Ã  des fonctions â€œinvisiblesâ€ sur un autre serveur ğŸ§ ğŸ“¡            |

---

ğŸ’¬ Câ€™est comme **appeler un chef dans une autre piÃ¨ce**, lui dire â€œprÃ©pare-moi une crÃªpeâ€,
et 5 secondes plus tard, tu la reÃ§ois dans ta main â€” **sans avoir vu la cuisine** ğŸ¥ğŸ§‘â€ğŸ³ğŸ“

---



#10

---

## ğŸ“ Câ€™est quoi une **API callback** ?

Le mot â€œcallbackâ€ veut dire **rappel**.

Donc une API callback, câ€™est un systÃ¨me oÃ¹ **un service en appelle un autre pour lui dire â€œÃ§a y est, câ€™est faitâ€**.

â¡ï¸ Imagine que tu commandes une pizza. Tu ne veux pas rester devant la porte Ã  attendre.

Tu veux que le livreur **te prÃ©vienne dÃ¨s quâ€™il est arrivÃ©**.

Câ€™est exactement ce que fait un callback : **il envoie un message automatique quand un Ã©vÃ©nement se produit** ğŸ•

---

## ğŸ§± Il y a deux parties importantes dans ce style :

1. **Le systÃ¨me qui envoie le message** â†’ celui qui dÃ©clenche lâ€™action (comme le livreur).
2. **Le systÃ¨me qui reÃ§oit le message** â†’ celui qui attend dâ€™Ãªtre prÃ©venu (comme toi).

Chaque fois que le premier systÃ¨me fait quelque chose (exemple : â€œcommande livrÃ©eâ€), il envoie **un message Ã  lâ€™autre systÃ¨me** pour lui dire que câ€™est fait âœ…

---

## ğŸ’¡ Comment Ã§a marche dans une vraie application ?

Prenons une **appli de paiement en ligne** :

* Tu fais un achat avec ta carte ğŸ’³
* La banque vÃ©rifie ton paiement
* Et quand câ€™est validÃ©, elle envoie un **webhook** (un message automatique) Ã  lâ€™appli de vente pour dire :

> â€œPaiement OK, tu peux prÃ©parer la commande !â€ ğŸ›ï¸

â¡ï¸ Lâ€™appli nâ€™a pas besoin de demander toutes les secondes â€œCâ€™est bon ? Câ€™est bon ?â€
Le systÃ¨me **est prÃ©venu directement** au bon moment. Câ€™est plus rapide et plus intelligent ğŸ§ âš¡

---

## ğŸ§  Câ€™est quoi un **webhook** ?

Un webhook est **une version trÃ¨s connue du style callback**, souvent appelÃ©e aussi â€œHTTP callbackâ€.

* Il utilise un simple message **HTTP POST** (comme un formulaire envoyÃ© automatiquement),
* Pour **envoyer des infos** Ã  une autre appli ou serveur dÃ¨s quâ€™un Ã©vÃ©nement arrive.

â¡ï¸ On le retrouve dans plein de domaines :

* Quand quelquâ€™un **sâ€™inscrit Ã  un site**, un webhook envoie automatiquement lâ€™info au systÃ¨me de newsletter ğŸ“§
* Quand un **fichier est uploadÃ©** sur un serveur, un webhook peut dÃ©clencher un scan automatique ğŸ”
* Quand une **tÃ¢che est terminÃ©e** dans un outil de gestion (comme Trello ou Asana), un webhook peut prÃ©venir une autre appli ğŸ“‹

---

## ğŸ” Et chaque message doit Ãªtre **confirmÃ©**

Quand un message est envoyÃ©, on attend **une confirmation** (appelÃ©e "acknowledgment").
â¡ï¸ Câ€™est comme dire : â€œJâ€™ai bien reÃ§u ton message, merci !â€
Ã‡a Ã©vite de perdre des infos ou dâ€™avoir des erreurs.

---

## ğŸ“š RÃ©sumÃ© simple comme une histoire

| Ã‰lÃ©ment                               | Version vulgarisÃ©e ğŸ§’                                                   |
| ------------------------------------- | ----------------------------------------------------------------------- |
| API Callback                          | Une API qui **prÃ©vient automatiquement** quand un Ã©vÃ©nement se passe ğŸ”” |
| Webhook                               | Le nom technique le plus utilisÃ© pour Ã§a ğŸ“®                             |
| Source system (celui qui envoie)      | Par exemple : une appli de paiement ğŸ’³                                  |
| Destination system (celui qui reÃ§oit) | Par exemple : une boutique en ligne ğŸ›’                                  |
| Acknowledgment                        | Confirmation que le message a bien Ã©tÃ© reÃ§u ğŸ“¨                          |

---

ğŸ’¬ En bref : **tu nâ€™as plus besoin de surveiller tout le temps**.
Lâ€™autre systÃ¨me **te dit quand câ€™est prÃªt ou terminÃ©**, exactement comme une **notification automatique sur ton tÃ©lÃ©phone** ğŸ“²ğŸ””

---



#11

---

## ğŸ” 1. Style **bidirectionnel** : les deux parlent **en mÃªme temps**

Dans ce style dâ€™API, **lâ€™application et le serveur peuvent Ã©changer des messages dans les deux sens**, **en mÃªme temps**, sans attendre leur tour.

â¡ï¸ Câ€™est comme une discussion tÃ©lÃ©phonique ğŸ“ :
Tu parles, et lâ€™autre personne peut te rÃ©pondre **tout de suite**, **sans attendre que tu aies fini**.

### ğŸ’¡ Exemples rÃ©els :

* Une **appli de chat en direct** : quand tu envoies un message et que lâ€™autre personne tâ€™Ã©crit en mÃªme temps ğŸ’¬ğŸ’¬
* Un **jeu en ligne multijoueur** : chaque joueur envoie ses actions en temps rÃ©el pendant que les autres font pareil ğŸ®ğŸ•¹ï¸

---

### ğŸ§° Technologies utilisÃ©es :

* **WebSocket** : un protocole spÃ©cial pour garder une **connexion ouverte** entre lâ€™utilisateur et le serveur ğŸŒ
* **gRPC** : une technologie rapide pour que deux machines Ã©changent des infos Ã  toute vitesse âš¡

---

ğŸ§  Le style bidirectionnel est **parfait pour les applis en temps rÃ©el** :

* quand on veut des rÃ©ponses **tout de suite**,
* ou quand les infos **doivent circuler dans les deux sens**, **sans pause** â±ï¸â†”ï¸â±ï¸

---

## ğŸ“¦ 2. Style **broker-based** : lâ€™info passe par un **intermÃ©diaire**

Dans ce style, les messages **ne vont pas directement** du point A au point B.
Ils passent par un **broker** (un â€œintermÃ©diaireâ€), un peu comme un **facteur numÃ©rique** ou un **centre de tri du courrier** ğŸ“¬ğŸ“¦

â¡ï¸ Ce broker :

* **reÃ§oit les messages** envoyÃ©s par les applications,
* **les trie**, **les garde en mÃ©moire** si besoin,
* et les **transmet au bon endroit** quand câ€™est le bon moment.

---

### ğŸ’¡ Exemples rÃ©els :

* Une **appli de transport** : quand une appli envoie les positions des bus, mais quâ€™il faut les rÃ©partir aux bons arrÃªts ğŸšŒğŸ“
* Une **plateforme de streaming musical** : si lâ€™un des serveurs tombe en panne, le message est mis en attente par le broker et sera livrÃ© plus tard ğŸµğŸ“¤ğŸ“¥

---

### ğŸ§° Outils connus pour ce style :

* **Kafka** ğŸ§  : pour gÃ©rer de gros volumes dâ€™informations comme les donnÃ©es dâ€™utilisateurs ou les historiques de clics
* **RabbitMQ** ğŸ° : souvent utilisÃ© dans des applications e-commerce ou santÃ© pour gÃ©rer les messages entre services
* **ActiveMQ** : utilisÃ© pour des projets dâ€™entreprise, souvent dans lâ€™industrie ou la finance ğŸ¢

---

## ğŸ“š RÃ©sumÃ© trÃ¨s simple :

| Style dâ€™API    | Fonction principale ğŸ§                                   | Exemple concret ğŸ“±                             |
| -------------- | ------------------------------------------------------- | ---------------------------------------------- |
| Bidirectionnel | **Les deux cÃ´tÃ©s communiquent en mÃªme temps** â†”ï¸        | Chat en ligne, jeu en rÃ©seau ğŸ®ğŸ’¬              |
| Broker-based   | Les messages passent **par un centre intermÃ©diaire** ğŸ“¨ | Plateforme de livraison, appli logistique ğŸššğŸ“¦ |

---

ğŸ§  En rÃ©sumÃ© :

* Le style **bidirectionnel** est **ultra rapide**, parfait pour le **temps rÃ©el** ğŸ”„
* Le style **broker** est **trÃ¨s organisÃ©**, parfait quand il faut **gÃ©rer beaucoup de messages** sans les perdre ğŸ§º

---



#12


---

## ğŸ“˜ Le livre â€œContinuous API Managementâ€ classe les styles dâ€™API en 5 types :

1. **Tunnel**
2. **Resource**
3. **Hypermedia**
4. **Query**
5. **Event-based**

Chacun de ces mots peut faire peur au dÃ©but, mais on va les expliquer **de faÃ§on intuitive**, avec des exemples dâ€™applis ou de cas rÃ©els quâ€™on utilise tous les jours ğŸ“±ğŸ’¬

---

## ğŸš‡ 1. **Tunnel** = un tuyau pour envoyer tout ce quâ€™on veut

ğŸ§  Un **tunnel**, dans le monde des APIs, câ€™est quand une appli **fait passer ses messages Ã  travers une seule et mÃªme porte**, un peu comme un **gros tuyau** oÃ¹ on glisse tout Ã  lâ€™intÃ©rieur, sans sÃ©parer les choses.

### ğŸ’¡ Exemple :

* Une appli envoie une commande â€œcommande de pizzaâ€ ğŸ•
* Tout (adresse, taille, sauce, message perso) est mis **dans un seul gros paquet**, envoyÃ© par une seule entrÃ©e.

â¡ï¸ Câ€™est pratique, mais **on ne voit pas clairement** ce qui est dedans depuis lâ€™extÃ©rieur.

---

## ğŸ“¦ 2. **Resource** = chaque chose a sa propre adresse

Ce style est trÃ¨s courant, notamment dans les APIs **REST**.

ğŸ§  Ici, **chaque objet ou Ã©lÃ©ment a une URL bien Ã  lui**, comme une **boÃ®te de rangement Ã©tiquetÃ©e** ğŸ¯

### ğŸ’¡ Exemple :

* Une appli de photos utilise :

  * `/photos` pour voir toutes les photos,
  * `/photos/42` pour la photo numÃ©ro 42 ğŸ“·

â¡ï¸ Tu peux **accÃ©der exactement Ã  ce que tu veux**, comme ouvrir un tiroir spÃ©cifique dans une armoire.

---

## ğŸ”— 3. **Hypermedia** = chaque rÃ©ponse contient **des liens vers la suite**

Câ€™est un peu comme un **livre dont chaque page te dit oÃ¹ aller ensuite**, selon ce que tu veux faire.

ğŸ§  Une API de ce type **te guide Ã  chaque Ã©tape** : tu ne demandes pas une URL prÃ©cise, elle **te donne elle-mÃªme les options** suivantes Ã  suivre.

### ğŸ’¡ Exemple :

* Une appli dâ€™achat te renvoie une rÃ©ponse qui dit :

  > â€œProduit ajoutÃ©. Tu veux maintenant \[payer], \[ajouter un autre produit], ou \[annuler] ?â€

â¡ï¸ Tu suis les options comme dans un **menu dynamique** ğŸ½ï¸

---

## ğŸ” 4. **Query** = tu poses une question prÃ©cise

On lâ€™a vu avec **GraphQL**.

ğŸ§  Ici, **tu demandes juste les infos que tu veux**, pas plus, pas moins.
Câ€™est comme **poser une question sur mesure**.

### ğŸ’¡ Exemple :

* Une appli de films demande :

  > â€œDonne-moi le titre et la durÃ©e des films sortis aprÃ¨s 2022, sans les rÃ©sumÃ©s.â€

â¡ï¸ Lâ€™API te rÃ©pond **exactement Ã§a**, sans te noyer sous plein dâ€™infos inutiles ğŸ¬ğŸ“„

---

## ğŸ”” 5. **Event-based** = on agit quand quelque chose se passe

ğŸ§  Ce style repose sur **des Ã©vÃ©nements** (exemples : â€œquelquâ€™un a payÃ©â€, â€œune nouvelle image est postÃ©eâ€, â€œle capteur a dÃ©tectÃ© du mouvementâ€).

Quand un Ã©vÃ©nement arrive, **lâ€™API envoie une notification**.

### ğŸ’¡ Exemple :

* Une appli de livraison tâ€™envoie une alerte ğŸ“¦ :

  > â€œVotre commande est en route !â€

â¡ï¸ Tu nâ€™as rien demandÃ©, mais **tu es prÃ©venu automatiquement**. On voit Ã§a avec **les webhooks**.

---

## ğŸ“š RÃ©sumÃ© super simple

| Style dâ€™API     | IdÃ©e principale ğŸ¯                             | Exemple concret ğŸ“±                        |
| --------------- | ---------------------------------------------- | ----------------------------------------- |
| **Tunnel**      | Tout est envoyÃ© dâ€™un coup par un seul point    | Commande complÃ¨te dans un seul message ğŸ“¬ |
| **Resource**    | Chaque chose a sa propre adresse claire        | Voir une photo spÃ©cifique ğŸ“·              |
| **Hypermedia**  | Lâ€™API te propose les Ã©tapes suivantes          | Comme un menu intelligent ğŸ½ï¸             |
| **Query**       | Tu poses une question ultra prÃ©cise            | â€œDonne-moi juste les titresâ€ ğŸ“„           |
| **Event-based** | Lâ€™API te prÃ©vient quand quelque chose se passe | â€œTa commande est livrÃ©eâ€ ğŸššğŸ””             |

---



#13

---

## ğŸ§± Quâ€™est-ce que ce tableau va montrer exactement ?

Le tableau organise les informations comme ceci :

* Chaque **colonne** reprÃ©sente un **style dâ€™API** (comme REST, GraphQL, gRPC, Webhookâ€¦).
* Chaque **ligne** dÃ©crit une **caractÃ©ristique importante** (comme le type de message, comment les rÃ©ponses arrivent, si câ€™est rapide ou pas, etc.).

Câ€™est un peu comme une **fiche de comparaison** quâ€™on voit dans les magazines ou sur des sites web :

| Style dâ€™API | Fonctionne avec   | RÃ©ponse automatique ? | Temps rÃ©el ? | UtilisÃ© pour...          |
| ----------- | ----------------- | --------------------- | ------------ | ------------------------ |
| REST        | HTTP              | Non                   | Non          | Sites web ğŸ“„             |
| GraphQL     | HTTP              | Non                   | Non          | Applis mobiles ğŸ“±        |
| WebSocket   | Protocole direct  | Oui                   | Oui          | Chats en ligne ğŸ’¬        |
| gRPC        | SpÃ©cial (binaire) | Oui                   | Oui          | Jeux, objets connectÃ©s âš¡ |

---

## ğŸ¯ Pourquoi câ€™est utile de voir les styles dâ€™API sous forme de tableau ?

â¡ï¸ Parce que chaque style **a ses points forts**, mais **aussi ses limites**.
Ce tableau permet de :

* **Comparer rapidement** les styles ğŸ“Š
* Savoir **lequel est le plus adaptÃ©** Ã  un projet
* Mieux comprendre **quelles rÃ¨gles ou habitudes** chaque style suit

---

## ğŸ’¡ Comparaison du monde rÃ©el

Câ€™est comme si tu comparais :

* des **moyens de transport** :

  * ğŸš— voiture (souple mais lent en ville),
  * ğŸš² vÃ©lo (rapide mais pas pour les longues distances),
  * âœˆï¸ avion (trÃ¨s rapide mais cher),
  * ğŸš¶ marcher (lent mais facile).

Ici, tu compares les **styles dâ€™API** :

* REST = la voiture : facile Ã  conduire, bon pour aller un peu partout.
* GraphQL = le vÃ©lo Ã©lectrique : tu choisis exactement ta route.
* WebSocket = le tÃ©lÃ©phone en direct : la communication ne sâ€™arrÃªte jamais.
* gRPC = la fusÃ©e ğŸš€ : pour les systÃ¨mes qui ont besoin de trÃ¨s haute vitesse et prÃ©cision.

---

## ğŸ“š En rÃ©sumÃ© trÃ¨s simple :

* Ce tableau est une **fiche pratique** qui classe les styles dâ€™API selon leurs **caractÃ©ristiques principales**.
* Il tâ€™aide Ã  **choisir le bon outil** pour le bon besoin (comme choisir entre un marteau et un tournevis ğŸ§°).
* Il montre que chaque style a :

  * des forces ğŸ’ª (rapide, prÃ©cis, soupleâ€¦),
  * des limites âŒ (lent, complexe, difficile Ã  testerâ€¦).

---



#14

---

## ğŸ“Š Comment lire ce tableau ?

Chaque **colonne** correspond Ã  un **style dâ€™API** (REST, GraphQL, gRPC, Webhook, etc.).

Chaque **ligne** dÃ©crit une **caractÃ©ristique importante** (comme le type de communication ou la vitesse).

On va voir ensemble les lignes une Ã  une ğŸ§©

---

## ğŸ” 1. **Technology** (Technologie principale)

â¡ï¸ Câ€™est le â€œtypeâ€ ou le â€œsystÃ¨meâ€ utilisÃ©.
Exemples :

* **REST** â†’ trÃ¨s utilisÃ© sur le web.
* **GraphQL** â†’ plus flexible, pour demander ce quâ€™on veut.
* **gRPC** â†’ ultra rapide, utilisÃ© entre machines.
* **Webhook** â†’ pour recevoir une alerte automatique.
* **WebSocket** â†’ pour discuter en direct.
* **RabbitMQ** (broker) â†’ pour organiser et rÃ©partir plein de messages.

---

## ğŸ”— 2. **Protocol** (Comment les messages voyagent)

â¡ï¸ Câ€™est la â€œrouteâ€ que les messages empruntent pour voyager entre les programmes.

* La plupart utilisent **HTTP** (comme les sites web ğŸŒ).
* gRPC utilise **HTTP/2** (plus rapide).
* WebSocket a son propre chemin spÃ©cial.
* RabbitMQ utilise **AMQP** (un protocole de messagerie pro).

---

## ğŸ”„ 3. **Communication Type** (Quand Ã§a parle ?)

â¡ï¸ Câ€™est le rythme de la conversation :

* **Synchronous** = un programme envoie une demande et attend la rÃ©ponse avant de continuer.
  ğŸ§ Ex : tu poses une question et tu attends quâ€™on rÃ©ponde.

* **Asynchronous** = le programme envoie une demande mais **continue sa vie**, il recevra la rÃ©ponse plus tard.
  ğŸƒ Ex : tu envoies un message et tu fais autre chose en attendant.

---

## ğŸ§± 4. **Binary Data Support** (Est-ce quâ€™on peut envoyer autre chose que du texte ?)

â¡ï¸ Certains styles acceptent **des donnÃ©es binaires** (images, vidÃ©os, fichiers...) :

* **Yes** : tu peux envoyer plein de formats, pas seulement du texte.
* **Partial** : un peu possible, mais pas super fluide.
* **No / â€”** : ce nâ€™est pas fait pour Ã§a.

---

## âš¡ 5. **Responsiveness** (Vitesse de rÃ©ponse)

â¡ï¸ Ã€ quelle vitesse lâ€™API rÃ©pond en gÃ©nÃ©ral ?

* **High** = trÃ¨s rapide (utile pour les jeux ou les applis temps rÃ©el) ğŸ®
* **Medium** = assez rapide pour la plupart des besoins ğŸ“¦
* **Low** = lent, souvent Ã  cause de la structure du style ğŸ“„

---

## ğŸ§  6. **Development Effort** (DifficultÃ© Ã  crÃ©er et maintenir)

â¡ï¸ Combien de travail Ã§a demande Ã  une Ã©quipe pour mettre en place ce style ?

* **Low** = facile Ã  construire ğŸ§©
* **Medium** = demande quelques efforts ğŸ› ï¸
* **High** = plus complexe, nÃ©cessite plus de code ou de configuration âš™ï¸

---

## ğŸ¯ RÃ©sumÃ© vulgarisÃ© faÃ§on tableau comparatif de jeux :

| Style dâ€™API | Rapide ? âš¡  | Facile Ã  crÃ©er ? ğŸ§± | Parle en direct ? ğŸ” | ReÃ§oit automatiquement ? ğŸ”” | Envoie des images ? ğŸ–¼ï¸ |
| ----------- | ----------- | ------------------- | -------------------- | --------------------------- | ----------------------- |
| REST        | Moyen       | Moyen               | Oui (synchronous)    | Non                         | Oui                     |
| GraphQL     | Moyen       | Moyen               | Oui                  | Non                         | Partiel                 |
| Web Feed    | Moyen       | Facile              | Non (asynchronous)   | Oui                         | Partiel                 |
| gRPC        | TrÃ¨s rapide | CompliquÃ©           | Oui                  | Non                         | Oui                     |
| Webhook     | Moyen       | Facile              | Non                  | Oui                         | Oui                     |
| WebSocket   | TrÃ¨s rapide | Moyen               | Oui                  | Oui                         | Oui                     |
| RabbitMQ    | TrÃ¨s rapide | TrÃ¨s compliquÃ©      | Non                  | Oui                         | Oui                     |

---

## ğŸ’¡ En rÃ©sumÃ© :

* Il nâ€™existe **pas un seul style parfait**. Tout dÃ©pend de ce quâ€™on veut faire :

  * Une **appli simple de consultation** ? REST ou GraphQL suffisent.
  * Une **appli de chat en direct** ? WebSocket est parfait.
  * Un **systÃ¨me dâ€™usine ou de messagerie complexe** ? RabbitMQ ou gRPC sont mieux.
  * Un **site qui veut juste envoyer une alerte automatique** ? Webhook est idÃ©al.

---



#15

---

## 1. ğŸ”§ **Technology**

â¡ï¸ Câ€™est lâ€™**exemple concret** dâ€™un outil ou systÃ¨me qui utilise ce style dâ€™API.

### ğŸ’¡ Exemple :

* REST est un **style**.
* Postman, ou un site web qui utilise REST, câ€™est une **technologie RESTful**.
* GraphQL, Webhook, RabbitMQâ€¦ sont aussi des technologies liÃ©es Ã  leur style respectif.

Câ€™est comme dire :

> â€œOn parle de pop music ğŸ¶â€ â†’ mais ensuite tu donnes un **groupe de pop** pour illustrer.

---

## 2. ğŸŒ **Protocol**

â¡ï¸ Câ€™est **la route ou le langage** quâ€™utilisent les messages pour voyager dâ€™un point Ã  un autre.

### ğŸ’¡ Exemples :

* **HTTP** : utilisÃ© par presque tous les sites web (comme REST ou GraphQL).
* **WebSocket** : pour les communications en direct (comme dans un tchat).
* **AMQP** : pour des systÃ¨mes plus spÃ©cialisÃ©s (comme RabbitMQ dans les grandes entreprises).

Câ€™est comme dire :

> â€œTu veux envoyer un message ? Tu peux passer par **la poste** (HTTP), **le tÃ©lÃ©phone** (WebSocket), ou **un camion spÃ©cial** (AMQP).â€

---

## 3. ğŸ” **Communication Type**

â¡ï¸ Est-ce que lâ€™appli **attend la rÃ©ponse tout de suite** ou peut-elle **faire autre chose en attendant** ?

### ğŸ’¡ Deux cas :

* **Synchronous** (synchrone) = elle **attend**. Ex : tu poses une question et tu restes bloquÃ© jusquâ€™Ã  la rÃ©ponse â³
* **Asynchronous** (asynchrone) = elle **continue**, et la rÃ©ponse arrive quand elle est prÃªte ğŸ””

### ğŸ¯ Exemple :

* Quand tu cliques â€œenvoyerâ€ sur WhatsApp, tu **nâ€™attends pas que le message soit lu** â†’ câ€™est asynchrone.
* Mais si tu fais un paiement en ligne et que tu dois attendre la confirmation avant de continuer â†’ câ€™est synchrone.

---

## 4. ğŸ–¼ï¸ **Binary Data Support**

â¡ï¸ Est-ce que lâ€™API peut envoyer autre chose que du texte ? Par exemple des images, des vidÃ©os, des sons ?

### ğŸ’¡ Trois rÃ©ponses possibles :

* **Yes** : elle gÃ¨re Ã§a trÃ¨s bien ğŸ‘ (ex : gRPC, WebSocket)
* **No** : seulement du texte ğŸ“„
* **Partial** : elle peut, **mais il faut transformer les fichiers** dâ€™abord (par exemple, convertir une image en une sÃ©rie de caractÃ¨res appelÃ©s *base64*)

---

## 5. âš¡ **Responsiveness**

â¡ï¸ Ã€ quelle **vitesse** lâ€™API rÃ©pond ? Est-ce quâ€™elle est **rapide Ã  rÃ©agir** ?

Les rÃ©ponses possibles sont :

* **High** (trÃ¨s rapide)
* **Medium** (correct)
* **Low** (plutÃ´t lent)

### ğŸ¯ Exemples :

* WebSocket ou gRPC â†’ **rÃ©actions immÃ©diates**, comme dans un jeu multijoueur ğŸ®
* Web feed (flux RSS) â†’ moins rapide, car Ã§a **rafraÃ®chit Ã  intervalles rÃ©guliers** ğŸ“°

---

## 6. ğŸ› ï¸ **Development Effort**

â¡ï¸ Câ€™est la **quantitÃ© de travail** nÃ©cessaire pour crÃ©er et maintenir une API dans ce style.

* **Low** = Facile Ã  mettre en place. Peu de configuration.
* **Medium** = Un peu plus complexe.
* **High** = Demande beaucoup dâ€™efforts, de code, ou de configuration.

### ğŸ’¡ Exemples :

* **REST** ou **Webhooks** = relativement simples.
* **gRPC** ou **RabbitMQ** = plus techniques, plus de choses Ã  apprendre et Ã  installer.

---

## ğŸ“š RÃ©sumÃ© trÃ¨s visuel :

| ğŸ§± CritÃ¨re             | ğŸ§’ En version simple                       | Exemples ğŸ¯               |
| ---------------------- | ------------------------------------------ | ------------------------- |
| **Technology**         | Le â€œnomâ€ du systÃ¨me quâ€™on utilise          | GraphQL, RabbitMQ         |
| **Protocol**           | La â€œrouteâ€ ou le â€œmoyen de transportâ€      | HTTP, WebSocket           |
| **Communication Type** | Est-ce quâ€™on attend ou non la rÃ©ponse ?    | Synchrone ou asynchrone   |
| **Binary Support**     | Peut-on envoyer des images, sons, vidÃ©os ? | Oui, Non ou partiellement |
| **Responsiveness**     | Ã€ quelle vitesse Ã§a rÃ©pond ?               | Rapide âš¡ ou lent ğŸ¢       |
| **Development Effort** | Est-ce facile Ã  construire ?               | Simple ğŸ§© ou complexe ğŸ—ï¸ |

---