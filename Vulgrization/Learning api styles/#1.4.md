#1

---

## 🧩 Une application en “morceaux indépendants” (architecture modulaire)

Quand on crée une appli aujourd’hui (par exemple : un site de réservation de voyage 🛫), on n’écrit pas tout dans un seul bloc.

➡️ On sépare les choses :

* Une partie s’occupe de **la recherche d’hôtels** 🏨
* Une autre gère **les paiements** 💳
* Une autre s’occupe des **emails de confirmation** 📧

Chaque partie est appelée un **composant** (ou **service**).

Et ces services **parlent entre eux grâce à des APIs** 📡

---

## 🎮 Analogie simple : comme un jeu vidéo en modules

Imagine un jeu vidéo 🎮 :

* Un module s’occupe du son 🔊
* Un autre des scores 🧮
* Un autre de l’affichage 👾

➡️ Si tu veux **changer la musique**, tu modifies juste le module du son.
Tu ne touches pas aux autres.

💡 Grâce aux APIs, tous ces modules **peuvent se parler** sans dépendre les uns des autres.

---

## 🤝 Les APIs permettent **l’interopérabilité**

➡️ Ça veut dire que **des systèmes différents peuvent travailler ensemble**, comme une montre connectée qui parle avec ton téléphone 📱⌚, ou une appli qui utilise Google Maps pour t’afficher une carte 🗺️.

Chaque système a **sa propre API** qui dit :

> “Voici comment me parler : tu peux m’envoyer ce type de demande, je te renverrai ça.”

Et même si les systèmes sont très différents (Android, iOS, Linux...), **ça fonctionne**, grâce à cette **langue commune**.

---

## 🛠️ Et ça ouvre la porte à une nouvelle façon de créer : **les microservices**

Les **microservices**, c’est une méthode où une application est construite **comme une collection de petits programmes séparés**, chacun avec une fonction bien précise.

➡️ Chaque microservice a **sa propre API** pour se connecter au reste.

💡 Exemples :

* Dans une **appli bancaire**, un service gère les virements, un autre les notifications, un autre la connexion.
* Dans une **appli de vente**, un service gère les stocks, un autre les livraisons, un autre les retours.

Grâce aux APIs, **chaque partie peut évoluer seule**, être déplacée, améliorée, ou même utilisée dans une autre appli 🔁

---

## 🎯 Résumé très simple

* Les APIs permettent de **découper une application** en **petits services indépendants**.
* Chaque service peut **travailler seul**, mais aussi **discuter avec les autres**.
* C’est comme si chaque pièce d’un puzzle pouvait être remplacée sans refaire tout le puzzle 🧩✨
* Ça rend les applis **plus souples, plus faciles à entretenir**, et prêtes à évoluer dans le temps.

---



#2


---

## 💼 Pourquoi les APIs sont utiles pour une entreprise ?

Une entreprise, peu importe son domaine (voyage, musique, transport, banque...), veut **être efficace et rentable** 💰

Aujourd’hui, **presque toutes les entreprises utilisent des logiciels** pour vendre, organiser, ou communiquer. Et comme **tout est de plus en plus connecté**, il devient indispensable de **faire parler les logiciels entre eux**.

➡️ C’est exactement ce que font les **APIs** (les portes d’entrée qui permettent aux logiciels de se parler entre eux).

---

## 🎯 Exemples très concrets de ce que les APIs permettent

### 1. Créer de nouvelles **sources de revenus** 💸

👉 C’est-à-dire : **gagner de l’argent d’une nouvelle façon** grâce aux APIs.

#### 💡 Exemple avec des sites de voyage :

* Des sites comme **skyscanner.com** ou **booking.com** **ne possèdent pas directement des avions ou des hôtels**.
* Ce sont des **agrégateurs**, c’est-à-dire qu’ils vont **chercher les infos chez d’autres services** (compagnies aériennes, chaînes d’hôtels...) via leurs **APIs**.

➡️ Ces sites envoient des questions comme :

> “Donne-moi les vols Paris → Rome le 10 avril”
> “Quels hôtels à New York coûtent moins de 150 € ?”

Et les APIs leur renvoient les résultats, qu’ils affichent **dans leur propre interface**.

Résultat :

* L’utilisateur peut **choisir et réserver** en quelques clics ✈️🏨
* L’hôtel ou la compagnie gagne un client 💼
* Et **l’agrégateur aussi touche une commission** 💵

---

## 🔁 Tout le monde y gagne

* L’**hôtel** vend plus de chambres 🛏️
* Le **client** trouve une bonne offre facilement 📱
* Le **site (API aggregator)** prend un petit pourcentage 🧾
* Et l’entreprise qui fournit l’API gagne aussi (elle peut vendre son API comme un produit)

---

## 💬 C’est comme un **supermarché numérique** :

Imagine une appli qui fait les courses à ta place :

* Elle appelle l’API de Carrefour pour le lait,
* L’API d’Auchan pour les biscuits,
* Et celle d’Intermarché pour les promotions.

Tout est **regroupé dans une seule appli**, et à la fin :

* Tu paies,
* Chaque supermarché reçoit sa part,
* Et l’appli gagne un peu en passant.

➡️ C’est **le même principe** que Booking ou Skyscanner, mais appliqué à **plein d'autres domaines**.

---

## 📊 Et c’est une vraie tendance !

D’après des études, **plus de la moitié des revenus** de certains grands groupes comme :

* **Salesforce** (logiciels pour les entreprises),
* **eBay** (achat/vente en ligne),
* ou **Expedia** (voyages en ligne),

➡️ viennent **des APIs**. Pas juste des applis visibles, mais **des connexions entre services**.

---

## 🧠 Résumé très simple

* Les APIs permettent aux entreprises de **se connecter et d’échanger des données automatiquement**.
* Des sites comme **Booking ou Skyscanner** gagnent de l’argent en **utilisant les APIs d’autres entreprises**.
* Les APIs deviennent alors **des outils pour vendre plus**, pour se faire connaître, ou même pour créer un **nouveau business** à part entière.
* Aujourd’hui, dans **presque tous les secteurs** (santé, éducation, commerce, transport), **les APIs sont devenues essentielles**.

---



#3

---

## 🌍 1. Les APIs permettent de **toucher plus de monde**

Prenons l’exemple de **Zoom** (le célèbre outil de visioconférence) 🎥 :

* Zoom n’est pas seulement disponible sur un site web.
* On peut aussi l’utiliser **sur téléphone**, **tablette**, **ordinateur**, ou même **télé connectée**.

👉 Et tout ça est possible grâce aux **APIs** que Zoom met à disposition.

➡️ Quand une entreprise **ouvre ses APIs aux développeurs**, ça veut dire qu’elle autorise d’autres applis ou appareils à **se connecter à son service**.

### 🎯 Résultat ?

* Tu peux rejoindre un appel Zoom depuis presque **n’importe quel appareil** 📱🖥️📺
* Zoom peut **atteindre beaucoup plus d’utilisateurs**, même ceux qui n’utilisent pas le site.
* Donc, **l’entreprise gagne plus de visibilité** et potentiellement plus d’utilisateurs ou de clients 💼🌍

---

## 🤖 2. Les APIs donnent accès à **des technologies avancées**

L’autre exemple vient de **GitHub Copilot**, lancé en 2021 par GitHub et basé sur un modèle de langage (comme moi 😉) développé par **OpenAI**.

### 💡 Qu’est-ce que GitHub Copilot ?

C’est un outil qui **aide les développeurs à écrire du code plus vite**, en suggérant automatiquement des lignes de code.

Mais pour que ça fonctionne, GitHub a utilisé une **API fournie par OpenAI**, ce qui veut dire :

> “OpenAI nous donne une porte d’accès pour qu’on puisse utiliser leur technologie, sans devoir tout réinventer.”

➡️ Grâce à cette API, GitHub a pu **connecter leur application** au modèle GPT (entraîné sur des millions de lignes de code), et ainsi transformer Copilot en **assistant intelligent pour les programmeurs**.

---

### 🎯 Résultat ?

* GitHub **gagne du temps** : pas besoin de créer toute l’intelligence tout seul.
* OpenAI **rend ses outils disponibles** à d’autres entreprises, en toute sécurité.
* Et les utilisateurs finaux (les développeurs) profitent d’un outil **ultra pratique et intelligent** ✨

---

## 📚 Résumé très simple :

| Avantage                                | Ce que ça veut dire en pratique                     | Exemple concret 🧪                    |
| --------------------------------------- | --------------------------------------------------- | ------------------------------------- |
| 🌍 Toucher plus de monde                | Utiliser une appli sur différents appareils         | Zoom sur smartphone, PC, TV...        |
| 🤖 Accéder à des technologies de pointe | Utiliser des outils intelligents créés par d’autres | GitHub Copilot grâce à l’API d’OpenAI |

---



#4

---

## 🧠 Rappel rapide : une API, c’est quoi ?

Une **API** est une **porte d’entrée numérique** que les programmes utilisent pour :

* demander des infos 📬,
* envoyer des données 📤,
* ou faire une action (comme payer ou ajouter un produit au panier) 🛒.

Mais selon **qui a le droit d’utiliser cette porte**, on classe les APIs en trois catégories :
➡️ **Privée**, **Publique**, ou **Partenaire**.

---

## 🔒 1. API **Privée** = réservée à l’intérieur de l’entreprise

➡️ Ce type d’API est **utilisé uniquement en interne**.
C’est comme une **porte secrète** que seuls les employés peuvent ouvrir 🔐

### 💡 Exemple concret :

* Une entreprise de transport a une API qui permet de **suivre l’emplacement des camions** 🚚.
* Cette API est utilisée **par les équipes internes** (comme les chauffeurs ou les managers), mais **pas accessible au public**.

🎯 Objectif : faire **communiquer les équipes** entre elles, de façon organisée.

---

## 🌍 2. API **Publique** = ouverte à tout le monde

➡️ Cette API est **disponible pour tout le monde** :
n’importe quel développeur ou entreprise peut s’en servir (parfois gratuitement, parfois payant).

### 💡 Exemple concret :

* Le site **open-meteo.com** propose une API météo.
  Tu peux demander : “Quel temps fera-t-il demain à Paris ?” 🌦️
* Tu peux l’utiliser dans une **appli de randonnée**, un **outil agricole**, ou un **assistant personnel**.

➡️ Parfois c’est **gratuit pour un usage personnel**, mais **payant pour un usage commercial** (comme une entreprise qui vend un service météo).

---

## 🤝 3. API **Partenaire** = partagée avec des entreprises spécifiques

➡️ Cette API n’est **ni totalement privée**, ni totalement ouverte.
Elle est **accessible uniquement aux partenaires** de l’entreprise.

C’est comme une **porte spéciale pour les amis de confiance** 🚪🤝

### 💡 Exemple concret :

* Une **banque** partage une API avec une appli de gestion de budget (comme Bankin' ou Linxo) 🏦📲.
* L’API n’est pas publique, mais la banque accepte que **ses partenaires autorisés** l’utilisent.

🎯 Objectif : permettre une **collaboration ciblée**, **sans ouvrir tout au monde entier**.

---

## 🧾 Résumé très clair avec une comparaison simple :

| Type d’API     | Qui peut l’utiliser ? 🧑‍💻             | Exemple concret 📱                | Comparaison imagée 🔑            |
| -------------- | --------------------------------------- | --------------------------------- | -------------------------------- |
| **Privée**     | Seulement les employés d’une entreprise | Suivi des stocks internes 📦      | Une **porte de bureau privée**   |
| **Publique**   | Tout le monde 🌍                        | Appli météo, carte, monnaie 🌡️💱 | Une **entrée de magasin** 🚪     |
| **Partenaire** | Les partenaires autorisés 🤝            | Appli bancaire, services liés 💳  | Une **porte avec badge VIP** 🏷️ |

---

## 💬 Pourquoi c’est important de savoir ça ?

* Parce que selon le **type d’API**, les **droits d’accès** changent.
* Et ça influence :

  * **ce que tu peux construire avec**,
  * **comment tu l’utilises** (gratuite, payante, limitée...),
  * et **à qui tu la proposes** si tu crées une application.

---

#5

---

## 🧱 Une API peut avoir **plusieurs styles**, comme un bâtiment peut avoir **plusieurs formes**

Imaginons qu’on parle **de maisons ou de châteaux**.
Il y a plein de manières de les construire, selon :

* le pays 🌍,
* l’époque ⏳,
* les matériaux 🧱,
* et les goûts (plutôt simple ou décoré ?) 🎨

Par exemple :

* Une maison **romaine** n’a pas le même style qu’une **maison moderne**.
* Un **château médiéval** est différent d’un **immeuble en verre d’aujourd’hui**.

Chaque type de construction a **un nom**, un style, une manière de faire.

---

## 🧩 Eh bien pour les APIs, c’est **pareil**

Quand des développeurs créent une API, ils doivent choisir **un style**.
C’est une manière de **définir comment l’API fonctionne, s’organise et communique**.

💡 Ces styles ont chacun :

* Leur propre façon d’écrire les messages,
* Leur propre manière de connecter les programmes,
* Des règles spécifiques à suivre (comme un plan de construction 🏗️).

---

### 🧠 Quelques styles d’API (qu’on va étudier ensuite) :

* **REST** : le plus simple, très utilisé sur le web 🌐
* **SOAP** : plus strict, souvent utilisé dans les entreprises 🏢
* **GraphQL** : plus moderne, très précis 🎯
* **gRPC** : très rapide, souvent utilisé pour les machines qui doivent aller vite ⚡

---

## 🏘️ Une analogie pour bien comprendre :

Imagine que tu veux construire un **village** d’applications :

* Une **API de style REST**, c’est comme une **maison moderne avec un plan très simple**, facile à comprendre 🏡
* Une **API de style SOAP**, c’est comme un **château avec beaucoup de règles et de portes sécurisées** 🏰
* Une **API GraphQL**, c’est comme un **appartement modulable** : tu choisis exactement ce dont tu as besoin 🧩
* Une **API gRPC**, c’est une **maison connectée ultra rapide**, faite pour des échanges rapides entre robots ou machines 🤖

---

## 🎯 En résumé très simple :

* Un **style d’API**, c’est **une manière de construire** et d’organiser une API.
* Comme dans l’architecture des bâtiments, **chaque style a ses caractéristiques**, ses règles et ses avantages.
* Selon le besoin (exemple : un site web simple, une usine connectée, une appli météo…), on ne choisira **pas le même style d’API**.

---



#6

---

## 🧱 Un **style d’API**, c’est comme un **style de construction**

Imagine que tu veux construire une maison ou une école 🏡🏫. Tu peux choisir :

* des matériaux (bois, béton…),
* une forme (moderne, ancienne…),
* et un plan (avec ou sans couloir, étage ou pas…).

👉 Tout ça ensemble forme un **style architectural** (par exemple : style grec, victorien, moderne, etc.).

De la même manière, quand on crée une **API**, on peut choisir **un style d’organisation**, qu’on appelle **style d’API**.

---

## 🎯 C’est quoi exactement un “style d’API” ?

C’est un **ensemble de règles et de bonnes habitudes** qu’on suit pour :

1. Construire une API (c’est-à-dire **comment elle est organisée**) 🧩
2. L’utiliser (**comment on envoie les messages**) 💬
3. Et la rendre claire et pratique pour d’autres applications ou utilisateurs 📦

Ce style définit :

* les **modèles** (comme la façon dont on nomme les adresses),
* les **règles de communication** (ce qu’on peut demander et comment),
* et même le **comportement** de l’API.

---

## 🧠 Une analogie très simple

Imagine que tu veux **jouer à un jeu de société** avec d’autres enfants 🎲 :

* Il y a **plusieurs types de jeux** (jeu de cartes, jeu de plateau, jeu de rôle…).
* Chaque type a ses propres **règles, façons de jouer, façons de gagner**.

Eh bien une API fonctionne pareil :
➡️ Tu choisis un **style d’API**, qui est comme **le type de jeu**.
➡️ Ensuite, tu **suis ses règles** pour créer ton API et la faire fonctionner correctement.

---

## 🕰️ Comme en architecture, les styles d’API changent avec le temps

➡️ Certains styles d’API deviennent **très populaires pendant un moment** (comme les maisons modernes aujourd’hui),
➡️ Puis d’autres prennent la place, plus adaptés à de nouveaux besoins.

💡 Par exemple :

* Le style **SOAP** était à la mode dans les années 2000 📜
* Le style **REST** est devenu super courant dans les années 2010 🌐
* Puis sont arrivés **GraphQL** et **gRPC**, qui sont plus récents et modernes ✨

---

## 📚 Résumé super simple :

| Terme                  | Explication en langage très simple 🧒                                |
| ---------------------- | -------------------------------------------------------------------- |
| **Style d’API**        | Une façon bien précise de construire et organiser une API            |
| **Paradigme**          | Une méthode ou un modèle de pensée (comme un mode de fonctionnement) |
| **Pattern / pratique** | Des bonnes habitudes ou des modèles à suivre                         |
| **Protocole**          | Les règles à respecter pour que tout le monde se comprenne           |

🎯 Les styles d’API ont :

* un **but** (exemple : faire simple, faire rapide...),
* un **fonctionnement** spécifique,
* et ils **changent avec le temps**, comme les modes en vêtements 👗 ou en technologies 📱

---


#7

---

## 🎼 Une API, c’est comme un **groupe de musique**

Un groupe de musique peut utiliser **les mêmes instruments** : guitare, batterie, basse, clavier, voix 🎹🥁🎤
Mais malgré ça, le groupe peut faire :

* du rock 🎸,
* du reggae 🌴,
* de la pop 💃,
* ou du jazz 🎷.

👉 Ce qui change, ce n’est pas l’instrument, mais **la façon dont on les utilise ensemble**.
➡️ C’est ce qu’on appelle le **style**.

---

## 🧱 Même chose pour les APIs

Tous les styles d’API utilisent un peu les **mêmes “instruments”** :

* des **protocoles** (les règles pour envoyer les messages),
* des **méthodes** (les façons de demander ou d’envoyer des choses),
* et des **modèles de conception** (comment l’API est structurée).

Mais selon **comment on assemble tout ça**, on a un style différent :

* REST 🧩
* GraphQL 🎯
* gRPC ⚡
* SOAP 📜
  … et d’autres.

---

## 🎯 Ce qui définit un **style d’API**, c’est ce qui **domine**

Même si deux APIs utilisent le même protocole ou les mêmes formats (comme JSON ou XML), ce qui fait qu’on dit “ça c’est REST” ou “ça c’est GraphQL”, c’est le style principal, **la logique générale**.

C’est comme si :

* Deux groupes ont une guitare électrique,
* Mais l’un fait du métal et l’autre de la pop :
  ➡️ On **les reconnaît par le style**, pas juste par les outils 🎸🎵

---

## 💡 Exemple avec REST (le style le plus connu)

* Une API REST **utilise les règles du web** pour faire des actions :
  ➤ “lire une ressource” (GET),
  ➤ “ajouter une ressource” (POST), etc.

* Il suit une série de **règles précises**, comme :

  * Chaque ressource a sa propre adresse (URL),
  * Les actions sont bien définies (comme POST, GET, PUT…),
  * Et dans la version vraiment complète (RESTful), il faut même que les réponses **contiennent des liens** vers d’autres actions possibles (ce qu’on appelle **hypermedia**).

🎯 Mais beaucoup d’APIs qui disent “je suis REST” ne suivent **pas toutes les règles**, notamment celle des hyperliens. Donc techniquement, elles sont REST-ish (presque REST 😅).

---

## 🎮 Exemple dans une appli réelle :

Imaginons une appli de recettes de cuisine 📲🍝

* Si elle utilise une API REST, elle pourrait avoir :

  * `/recettes` → liste toutes les recettes disponibles
  * `/recettes/42` → montre la recette numéro 42
  * `/recettes/42/ingredients` → donne les ingrédients de cette recette

➡️ Tu accèdes à chaque chose **par une adresse claire**, et tu sais quoi faire grâce aux **actions standard** (GET, POST…).

---

## 📚 Résumé super simple

| Élément                   | Version simplifiée 🧒                                                         |
| ------------------------- | ----------------------------------------------------------------------------- |
| Style d’API               | Une **manière de concevoir et organiser** une API (comme un style musical 🎵) |
| Instruments de base       | Protocoles, formats, méthodes (toujours un peu les mêmes 🧰)                  |
| Ce qui fait la différence | **Comment on combine** ces outils pour créer une expérience spécifique 🧩     |
| REST                      | Un style très répandu, basé sur les règles du web 🌐                          |

---



#8

---

## 🧠 1. Style d’API **basé sur des requêtes (query-based)**

### 💬 C’est quoi l’idée ?

C’est un style où **tu poses une question très précise** à l’API, et **tu reçois exactement ce que tu as demandé**, rien de plus.

➡️ On appelle ça “query-based” car le mot **query** signifie **requête** (ou “demande précise”).

---

### 💡 Exemple réel avec **GraphQL**

GraphQL est une API query-based très connue.
Tu peux dire à l’API :

> “Je veux le nom et l’image de la recette numéro 5,
> mais je ne veux **pas** les ingrédients ni les étapes.”

L’API **te donne juste ce que tu as demandé**, sans t’envoyer un tas d’autres infos inutiles 🧠📦

---

### 🎯 Exemple concret dans une appli :

Imaginons une **appli de cinéma** :

* L’utilisateur demande juste : le **titre du film**, et la **note du public**.
* L’API répond uniquement avec ces 2 infos, **et pas le résumé, les acteurs, la durée…**

Cela permet :

* D’aller **plus vite** 🏃
* D’économiser des données (très utile sur mobile 📱)
* Et d’avoir une **réponse personnalisée** 🧩

---

## 🌊 2. Style d’API **de type “flux web” (web feed)**

### 💬 C’est quoi l’idée ?

Ici, l’API envoie **du contenu mis à jour régulièrement**,
comme **un flux d’actualités**, sans qu’on ait besoin de demander à chaque fois.

➡️ On appelle ça un **“flux”**, car les infos **s’écoulent automatiquement**, un peu comme de l’eau 💧

---

### 💡 Exemples très connus : **RSS** et **Atom**

Ces deux technologies permettent :

* De suivre les nouveaux articles d’un site,
* De recevoir les dernières vidéos d’une chaîne,
* Ou d’afficher les dernières alertes météo 🌦️

Le tout **automatiquement**, sans ouvrir le site à chaque fois.

---

### 🎯 Exemple concret dans la vraie vie :

* Une **appli de blog** utilise un flux RSS pour afficher les derniers articles dès qu’ils sont publiés 📰
* Une **appli météo** utilise un flux XML pour recevoir les prévisions du jour **en continu**, sans redemander à chaque fois ☁️🌡️
* Une **appli d’actualités** reçoit les titres de plusieurs journaux à la suite, automatiquement 🗞️

---

## 🧾 Résumé ultra simple

| Style d’API           | Fonction principale 🔍                                                     | Exemple d’application 📱        |
| --------------------- | -------------------------------------------------------------------------- | ------------------------------- |
| Query-based (GraphQL) | L’appli **pose une question précise**, reçoit **juste ce qu’elle veut** 🎯 | Une app de films ou de recettes |
| Web feed (RSS, Atom)  | L’appli **reçoit les nouveautés toute seule**, régulièrement 🔄            | Une app de météo ou de blog     |

---

## 🧠 À retenir :

* Un **style d’API** est une **façon d’organiser l’échange de données**.
* Le style **query-based** est parfait quand on veut être **très précis dans ce qu’on reçoit**.
* Le style **web feed** est parfait quand on veut **rester à jour automatiquement** sur du contenu.

---



#9

---

## 📞 Qu’est-ce que le style **RPC** (Remote Procedure Call) ?

Imaginons que tu veux **allumer la lumière dans ta chambre**, mais que l’interrupteur se trouve **dans une autre maison** 🏠🔦

➡️ Avec le style RPC, tu appuies sur un bouton chez toi, et **quelqu’un dans l’autre maison fait l’action à ta place**.

Mais pour toi, **ça ressemble à un interrupteur classique**, comme s’il était chez toi.

🎯 C’est ça le style RPC :

> Tu appelles une action (comme une fonction), elle s’exécute **ailleurs**, et tu reçois le résultat **comme si c’était ici**.

---

## 🧠 Comment ça marche (en très simplifié)

1. **Ton application (le client RPC)** envoie une commande à distance 📤.
2. Cette commande va sur un **serveur RPC**, qui sait comment exécuter l’action.
3. Le serveur **fait le travail demandé** (comme un calcul, une recherche, une action).
4. Il **renvoie la réponse** à ton application 📩.

Et pour toi, tout ça se fait **comme une simple commande**, sans que tu aies besoin de savoir où le travail a été fait 🧩

---

## ⚙️ Et qu’est-ce que **gRPC** ?

**gRPC** est un outil moderne (créé par Google) qui applique ce style RPC, mais :

* en étant **très rapide** ⚡,
* en **compressant les messages** (pour qu’ils soient plus légers),
* et en permettant à **plein de machines** de se parler très efficacement.

---

## 💡 Exemples d’applications réelles qui utilisent RPC ou gRPC :

### 🎮 Dans les jeux vidéo en ligne

Quand tu joues, ton personnage saute, tire, ou bouge.
Mais tous les calculs (scores, collisions, actions) peuvent être faits **sur un serveur à distance**, qui te renvoie le résultat **presque instantanément**.

➡️ Ton jeu envoie une commande “saute”,
le serveur calcule le saut, et te renvoie le mouvement du personnage.

---

### 🏭 Dans les systèmes industriels

Des **robots dans une usine** envoient des ordres à une machine pour faire une tâche (comme couper, trier, etc.).

➡️ Le robot utilise une API RPC pour dire à une autre machine : “Fais cette action maintenant”,
et il reçoit la confirmation une fois que c’est fait.

---

### 📱 Dans les applis modernes (comme celles de banque ou d’assistance vocale)

Ton appli peut envoyer une requête pour calculer quelque chose (par exemple : “combien me reste-t-il sur mon compte si je paye 85 € ?”).
Et cette action est **faite sur un serveur**, avec la réponse qui revient **en quelques secondes**.

---

## 📚 Résumé très simple

| Élément clé                 | Explication simple 🧒                                                    |
| --------------------------- | ------------------------------------------------------------------------ |
| RPC (Remote Procedure Call) | Une commande qui est **exécutée à distance**, mais qui **semble locale** |
| gRPC                        | Une version moderne, **rapide et optimisée**, du style RPC ⚡             |
| Utilisation typique         | Appels à des fonctions “invisibles” sur un autre serveur 🧠📡            |

---

💬 C’est comme **appeler un chef dans une autre pièce**, lui dire “prépare-moi une crêpe”,
et 5 secondes plus tard, tu la reçois dans ta main — **sans avoir vu la cuisine** 🥞🧑‍🍳📞

---



#10

---

## 📞 C’est quoi une **API callback** ?

Le mot “callback” veut dire **rappel**.

Donc une API callback, c’est un système où **un service en appelle un autre pour lui dire “ça y est, c’est fait”**.

➡️ Imagine que tu commandes une pizza. Tu ne veux pas rester devant la porte à attendre.

Tu veux que le livreur **te prévienne dès qu’il est arrivé**.

C’est exactement ce que fait un callback : **il envoie un message automatique quand un événement se produit** 🍕

---

## 🧱 Il y a deux parties importantes dans ce style :

1. **Le système qui envoie le message** → celui qui déclenche l’action (comme le livreur).
2. **Le système qui reçoit le message** → celui qui attend d’être prévenu (comme toi).

Chaque fois que le premier système fait quelque chose (exemple : “commande livrée”), il envoie **un message à l’autre système** pour lui dire que c’est fait ✅

---

## 💡 Comment ça marche dans une vraie application ?

Prenons une **appli de paiement en ligne** :

* Tu fais un achat avec ta carte 💳
* La banque vérifie ton paiement
* Et quand c’est validé, elle envoie un **webhook** (un message automatique) à l’appli de vente pour dire :

> “Paiement OK, tu peux préparer la commande !” 🛍️

➡️ L’appli n’a pas besoin de demander toutes les secondes “C’est bon ? C’est bon ?”
Le système **est prévenu directement** au bon moment. C’est plus rapide et plus intelligent 🧠⚡

---

## 🧠 C’est quoi un **webhook** ?

Un webhook est **une version très connue du style callback**, souvent appelée aussi “HTTP callback”.

* Il utilise un simple message **HTTP POST** (comme un formulaire envoyé automatiquement),
* Pour **envoyer des infos** à une autre appli ou serveur dès qu’un événement arrive.

➡️ On le retrouve dans plein de domaines :

* Quand quelqu’un **s’inscrit à un site**, un webhook envoie automatiquement l’info au système de newsletter 📧
* Quand un **fichier est uploadé** sur un serveur, un webhook peut déclencher un scan automatique 🔍
* Quand une **tâche est terminée** dans un outil de gestion (comme Trello ou Asana), un webhook peut prévenir une autre appli 📋

---

## 🔁 Et chaque message doit être **confirmé**

Quand un message est envoyé, on attend **une confirmation** (appelée "acknowledgment").
➡️ C’est comme dire : “J’ai bien reçu ton message, merci !”
Ça évite de perdre des infos ou d’avoir des erreurs.

---

## 📚 Résumé simple comme une histoire

| Élément                               | Version vulgarisée 🧒                                                   |
| ------------------------------------- | ----------------------------------------------------------------------- |
| API Callback                          | Une API qui **prévient automatiquement** quand un événement se passe 🔔 |
| Webhook                               | Le nom technique le plus utilisé pour ça 📮                             |
| Source system (celui qui envoie)      | Par exemple : une appli de paiement 💳                                  |
| Destination system (celui qui reçoit) | Par exemple : une boutique en ligne 🛒                                  |
| Acknowledgment                        | Confirmation que le message a bien été reçu 📨                          |

---

💬 En bref : **tu n’as plus besoin de surveiller tout le temps**.
L’autre système **te dit quand c’est prêt ou terminé**, exactement comme une **notification automatique sur ton téléphone** 📲🔔

---



#11

---

## 🔁 1. Style **bidirectionnel** : les deux parlent **en même temps**

Dans ce style d’API, **l’application et le serveur peuvent échanger des messages dans les deux sens**, **en même temps**, sans attendre leur tour.

➡️ C’est comme une discussion téléphonique 📞 :
Tu parles, et l’autre personne peut te répondre **tout de suite**, **sans attendre que tu aies fini**.

### 💡 Exemples réels :

* Une **appli de chat en direct** : quand tu envoies un message et que l’autre personne t’écrit en même temps 💬💬
* Un **jeu en ligne multijoueur** : chaque joueur envoie ses actions en temps réel pendant que les autres font pareil 🎮🕹️

---

### 🧰 Technologies utilisées :

* **WebSocket** : un protocole spécial pour garder une **connexion ouverte** entre l’utilisateur et le serveur 🌐
* **gRPC** : une technologie rapide pour que deux machines échangent des infos à toute vitesse ⚡

---

🧠 Le style bidirectionnel est **parfait pour les applis en temps réel** :

* quand on veut des réponses **tout de suite**,
* ou quand les infos **doivent circuler dans les deux sens**, **sans pause** ⏱️↔️⏱️

---

## 📦 2. Style **broker-based** : l’info passe par un **intermédiaire**

Dans ce style, les messages **ne vont pas directement** du point A au point B.
Ils passent par un **broker** (un “intermédiaire”), un peu comme un **facteur numérique** ou un **centre de tri du courrier** 📬📦

➡️ Ce broker :

* **reçoit les messages** envoyés par les applications,
* **les trie**, **les garde en mémoire** si besoin,
* et les **transmet au bon endroit** quand c’est le bon moment.

---

### 💡 Exemples réels :

* Une **appli de transport** : quand une appli envoie les positions des bus, mais qu’il faut les répartir aux bons arrêts 🚌📍
* Une **plateforme de streaming musical** : si l’un des serveurs tombe en panne, le message est mis en attente par le broker et sera livré plus tard 🎵📤📥

---

### 🧰 Outils connus pour ce style :

* **Kafka** 🧠 : pour gérer de gros volumes d’informations comme les données d’utilisateurs ou les historiques de clics
* **RabbitMQ** 🐰 : souvent utilisé dans des applications e-commerce ou santé pour gérer les messages entre services
* **ActiveMQ** : utilisé pour des projets d’entreprise, souvent dans l’industrie ou la finance 🏢

---

## 📚 Résumé très simple :

| Style d’API    | Fonction principale 🧠                                  | Exemple concret 📱                             |
| -------------- | ------------------------------------------------------- | ---------------------------------------------- |
| Bidirectionnel | **Les deux côtés communiquent en même temps** ↔️        | Chat en ligne, jeu en réseau 🎮💬              |
| Broker-based   | Les messages passent **par un centre intermédiaire** 📨 | Plateforme de livraison, appli logistique 🚚📦 |

---

🧠 En résumé :

* Le style **bidirectionnel** est **ultra rapide**, parfait pour le **temps réel** 🔄
* Le style **broker** est **très organisé**, parfait quand il faut **gérer beaucoup de messages** sans les perdre 🧺

---



#12


---

## 📘 Le livre “Continuous API Management” classe les styles d’API en 5 types :

1. **Tunnel**
2. **Resource**
3. **Hypermedia**
4. **Query**
5. **Event-based**

Chacun de ces mots peut faire peur au début, mais on va les expliquer **de façon intuitive**, avec des exemples d’applis ou de cas réels qu’on utilise tous les jours 📱💬

---

## 🚇 1. **Tunnel** = un tuyau pour envoyer tout ce qu’on veut

🧠 Un **tunnel**, dans le monde des APIs, c’est quand une appli **fait passer ses messages à travers une seule et même porte**, un peu comme un **gros tuyau** où on glisse tout à l’intérieur, sans séparer les choses.

### 💡 Exemple :

* Une appli envoie une commande “commande de pizza” 🍕
* Tout (adresse, taille, sauce, message perso) est mis **dans un seul gros paquet**, envoyé par une seule entrée.

➡️ C’est pratique, mais **on ne voit pas clairement** ce qui est dedans depuis l’extérieur.

---

## 📦 2. **Resource** = chaque chose a sa propre adresse

Ce style est très courant, notamment dans les APIs **REST**.

🧠 Ici, **chaque objet ou élément a une URL bien à lui**, comme une **boîte de rangement étiquetée** 🎯

### 💡 Exemple :

* Une appli de photos utilise :

  * `/photos` pour voir toutes les photos,
  * `/photos/42` pour la photo numéro 42 📷

➡️ Tu peux **accéder exactement à ce que tu veux**, comme ouvrir un tiroir spécifique dans une armoire.

---

## 🔗 3. **Hypermedia** = chaque réponse contient **des liens vers la suite**

C’est un peu comme un **livre dont chaque page te dit où aller ensuite**, selon ce que tu veux faire.

🧠 Une API de ce type **te guide à chaque étape** : tu ne demandes pas une URL précise, elle **te donne elle-même les options** suivantes à suivre.

### 💡 Exemple :

* Une appli d’achat te renvoie une réponse qui dit :

  > “Produit ajouté. Tu veux maintenant \[payer], \[ajouter un autre produit], ou \[annuler] ?”

➡️ Tu suis les options comme dans un **menu dynamique** 🍽️

---

## 🔍 4. **Query** = tu poses une question précise

On l’a vu avec **GraphQL**.

🧠 Ici, **tu demandes juste les infos que tu veux**, pas plus, pas moins.
C’est comme **poser une question sur mesure**.

### 💡 Exemple :

* Une appli de films demande :

  > “Donne-moi le titre et la durée des films sortis après 2022, sans les résumés.”

➡️ L’API te répond **exactement ça**, sans te noyer sous plein d’infos inutiles 🎬📄

---

## 🔔 5. **Event-based** = on agit quand quelque chose se passe

🧠 Ce style repose sur **des événements** (exemples : “quelqu’un a payé”, “une nouvelle image est postée”, “le capteur a détecté du mouvement”).

Quand un événement arrive, **l’API envoie une notification**.

### 💡 Exemple :

* Une appli de livraison t’envoie une alerte 📦 :

  > “Votre commande est en route !”

➡️ Tu n’as rien demandé, mais **tu es prévenu automatiquement**. On voit ça avec **les webhooks**.

---

## 📚 Résumé super simple

| Style d’API     | Idée principale 🎯                             | Exemple concret 📱                        |
| --------------- | ---------------------------------------------- | ----------------------------------------- |
| **Tunnel**      | Tout est envoyé d’un coup par un seul point    | Commande complète dans un seul message 📬 |
| **Resource**    | Chaque chose a sa propre adresse claire        | Voir une photo spécifique 📷              |
| **Hypermedia**  | L’API te propose les étapes suivantes          | Comme un menu intelligent 🍽️             |
| **Query**       | Tu poses une question ultra précise            | “Donne-moi juste les titres” 📄           |
| **Event-based** | L’API te prévient quand quelque chose se passe | “Ta commande est livrée” 🚚🔔             |

---



#13

---

## 🧱 Qu’est-ce que ce tableau va montrer exactement ?

Le tableau organise les informations comme ceci :

* Chaque **colonne** représente un **style d’API** (comme REST, GraphQL, gRPC, Webhook…).
* Chaque **ligne** décrit une **caractéristique importante** (comme le type de message, comment les réponses arrivent, si c’est rapide ou pas, etc.).

C’est un peu comme une **fiche de comparaison** qu’on voit dans les magazines ou sur des sites web :

| Style d’API | Fonctionne avec   | Réponse automatique ? | Temps réel ? | Utilisé pour...          |
| ----------- | ----------------- | --------------------- | ------------ | ------------------------ |
| REST        | HTTP              | Non                   | Non          | Sites web 📄             |
| GraphQL     | HTTP              | Non                   | Non          | Applis mobiles 📱        |
| WebSocket   | Protocole direct  | Oui                   | Oui          | Chats en ligne 💬        |
| gRPC        | Spécial (binaire) | Oui                   | Oui          | Jeux, objets connectés ⚡ |

---

## 🎯 Pourquoi c’est utile de voir les styles d’API sous forme de tableau ?

➡️ Parce que chaque style **a ses points forts**, mais **aussi ses limites**.
Ce tableau permet de :

* **Comparer rapidement** les styles 📊
* Savoir **lequel est le plus adapté** à un projet
* Mieux comprendre **quelles règles ou habitudes** chaque style suit

---

## 💡 Comparaison du monde réel

C’est comme si tu comparais :

* des **moyens de transport** :

  * 🚗 voiture (souple mais lent en ville),
  * 🚲 vélo (rapide mais pas pour les longues distances),
  * ✈️ avion (très rapide mais cher),
  * 🚶 marcher (lent mais facile).

Ici, tu compares les **styles d’API** :

* REST = la voiture : facile à conduire, bon pour aller un peu partout.
* GraphQL = le vélo électrique : tu choisis exactement ta route.
* WebSocket = le téléphone en direct : la communication ne s’arrête jamais.
* gRPC = la fusée 🚀 : pour les systèmes qui ont besoin de très haute vitesse et précision.

---

## 📚 En résumé très simple :

* Ce tableau est une **fiche pratique** qui classe les styles d’API selon leurs **caractéristiques principales**.
* Il t’aide à **choisir le bon outil** pour le bon besoin (comme choisir entre un marteau et un tournevis 🧰).
* Il montre que chaque style a :

  * des forces 💪 (rapide, précis, souple…),
  * des limites ❌ (lent, complexe, difficile à tester…).

---



#14

---

## 📊 Comment lire ce tableau ?

Chaque **colonne** correspond à un **style d’API** (REST, GraphQL, gRPC, Webhook, etc.).

Chaque **ligne** décrit une **caractéristique importante** (comme le type de communication ou la vitesse).

On va voir ensemble les lignes une à une 🧩

---

## 🔍 1. **Technology** (Technologie principale)

➡️ C’est le “type” ou le “système” utilisé.
Exemples :

* **REST** → très utilisé sur le web.
* **GraphQL** → plus flexible, pour demander ce qu’on veut.
* **gRPC** → ultra rapide, utilisé entre machines.
* **Webhook** → pour recevoir une alerte automatique.
* **WebSocket** → pour discuter en direct.
* **RabbitMQ** (broker) → pour organiser et répartir plein de messages.

---

## 🔗 2. **Protocol** (Comment les messages voyagent)

➡️ C’est la “route” que les messages empruntent pour voyager entre les programmes.

* La plupart utilisent **HTTP** (comme les sites web 🌐).
* gRPC utilise **HTTP/2** (plus rapide).
* WebSocket a son propre chemin spécial.
* RabbitMQ utilise **AMQP** (un protocole de messagerie pro).

---

## 🔄 3. **Communication Type** (Quand ça parle ?)

➡️ C’est le rythme de la conversation :

* **Synchronous** = un programme envoie une demande et attend la réponse avant de continuer.
  🧍 Ex : tu poses une question et tu attends qu’on réponde.

* **Asynchronous** = le programme envoie une demande mais **continue sa vie**, il recevra la réponse plus tard.
  🏃 Ex : tu envoies un message et tu fais autre chose en attendant.

---

## 🧱 4. **Binary Data Support** (Est-ce qu’on peut envoyer autre chose que du texte ?)

➡️ Certains styles acceptent **des données binaires** (images, vidéos, fichiers...) :

* **Yes** : tu peux envoyer plein de formats, pas seulement du texte.
* **Partial** : un peu possible, mais pas super fluide.
* **No / —** : ce n’est pas fait pour ça.

---

## ⚡ 5. **Responsiveness** (Vitesse de réponse)

➡️ À quelle vitesse l’API répond en général ?

* **High** = très rapide (utile pour les jeux ou les applis temps réel) 🎮
* **Medium** = assez rapide pour la plupart des besoins 📦
* **Low** = lent, souvent à cause de la structure du style 📄

---

## 🧠 6. **Development Effort** (Difficulté à créer et maintenir)

➡️ Combien de travail ça demande à une équipe pour mettre en place ce style ?

* **Low** = facile à construire 🧩
* **Medium** = demande quelques efforts 🛠️
* **High** = plus complexe, nécessite plus de code ou de configuration ⚙️

---

## 🎯 Résumé vulgarisé façon tableau comparatif de jeux :

| Style d’API | Rapide ? ⚡  | Facile à créer ? 🧱 | Parle en direct ? 🔁 | Reçoit automatiquement ? 🔔 | Envoie des images ? 🖼️ |
| ----------- | ----------- | ------------------- | -------------------- | --------------------------- | ----------------------- |
| REST        | Moyen       | Moyen               | Oui (synchronous)    | Non                         | Oui                     |
| GraphQL     | Moyen       | Moyen               | Oui                  | Non                         | Partiel                 |
| Web Feed    | Moyen       | Facile              | Non (asynchronous)   | Oui                         | Partiel                 |
| gRPC        | Très rapide | Compliqué           | Oui                  | Non                         | Oui                     |
| Webhook     | Moyen       | Facile              | Non                  | Oui                         | Oui                     |
| WebSocket   | Très rapide | Moyen               | Oui                  | Oui                         | Oui                     |
| RabbitMQ    | Très rapide | Très compliqué      | Non                  | Oui                         | Oui                     |

---

## 💡 En résumé :

* Il n’existe **pas un seul style parfait**. Tout dépend de ce qu’on veut faire :

  * Une **appli simple de consultation** ? REST ou GraphQL suffisent.
  * Une **appli de chat en direct** ? WebSocket est parfait.
  * Un **système d’usine ou de messagerie complexe** ? RabbitMQ ou gRPC sont mieux.
  * Un **site qui veut juste envoyer une alerte automatique** ? Webhook est idéal.

---



#15

---

## 1. 🔧 **Technology**

➡️ C’est l’**exemple concret** d’un outil ou système qui utilise ce style d’API.

### 💡 Exemple :

* REST est un **style**.
* Postman, ou un site web qui utilise REST, c’est une **technologie RESTful**.
* GraphQL, Webhook, RabbitMQ… sont aussi des technologies liées à leur style respectif.

C’est comme dire :

> “On parle de pop music 🎶” → mais ensuite tu donnes un **groupe de pop** pour illustrer.

---

## 2. 🌐 **Protocol**

➡️ C’est **la route ou le langage** qu’utilisent les messages pour voyager d’un point à un autre.

### 💡 Exemples :

* **HTTP** : utilisé par presque tous les sites web (comme REST ou GraphQL).
* **WebSocket** : pour les communications en direct (comme dans un tchat).
* **AMQP** : pour des systèmes plus spécialisés (comme RabbitMQ dans les grandes entreprises).

C’est comme dire :

> “Tu veux envoyer un message ? Tu peux passer par **la poste** (HTTP), **le téléphone** (WebSocket), ou **un camion spécial** (AMQP).”

---

## 3. 🔁 **Communication Type**

➡️ Est-ce que l’appli **attend la réponse tout de suite** ou peut-elle **faire autre chose en attendant** ?

### 💡 Deux cas :

* **Synchronous** (synchrone) = elle **attend**. Ex : tu poses une question et tu restes bloqué jusqu’à la réponse ⏳
* **Asynchronous** (asynchrone) = elle **continue**, et la réponse arrive quand elle est prête 🔔

### 🎯 Exemple :

* Quand tu cliques “envoyer” sur WhatsApp, tu **n’attends pas que le message soit lu** → c’est asynchrone.
* Mais si tu fais un paiement en ligne et que tu dois attendre la confirmation avant de continuer → c’est synchrone.

---

## 4. 🖼️ **Binary Data Support**

➡️ Est-ce que l’API peut envoyer autre chose que du texte ? Par exemple des images, des vidéos, des sons ?

### 💡 Trois réponses possibles :

* **Yes** : elle gère ça très bien 👍 (ex : gRPC, WebSocket)
* **No** : seulement du texte 📄
* **Partial** : elle peut, **mais il faut transformer les fichiers** d’abord (par exemple, convertir une image en une série de caractères appelés *base64*)

---

## 5. ⚡ **Responsiveness**

➡️ À quelle **vitesse** l’API répond ? Est-ce qu’elle est **rapide à réagir** ?

Les réponses possibles sont :

* **High** (très rapide)
* **Medium** (correct)
* **Low** (plutôt lent)

### 🎯 Exemples :

* WebSocket ou gRPC → **réactions immédiates**, comme dans un jeu multijoueur 🎮
* Web feed (flux RSS) → moins rapide, car ça **rafraîchit à intervalles réguliers** 📰

---

## 6. 🛠️ **Development Effort**

➡️ C’est la **quantité de travail** nécessaire pour créer et maintenir une API dans ce style.

* **Low** = Facile à mettre en place. Peu de configuration.
* **Medium** = Un peu plus complexe.
* **High** = Demande beaucoup d’efforts, de code, ou de configuration.

### 💡 Exemples :

* **REST** ou **Webhooks** = relativement simples.
* **gRPC** ou **RabbitMQ** = plus techniques, plus de choses à apprendre et à installer.

---

## 📚 Résumé très visuel :

| 🧱 Critère             | 🧒 En version simple                       | Exemples 🎯               |
| ---------------------- | ------------------------------------------ | ------------------------- |
| **Technology**         | Le “nom” du système qu’on utilise          | GraphQL, RabbitMQ         |
| **Protocol**           | La “route” ou le “moyen de transport”      | HTTP, WebSocket           |
| **Communication Type** | Est-ce qu’on attend ou non la réponse ?    | Synchrone ou asynchrone   |
| **Binary Support**     | Peut-on envoyer des images, sons, vidéos ? | Oui, Non ou partiellement |
| **Responsiveness**     | À quelle vitesse ça répond ?               | Rapide ⚡ ou lent 🐢       |
| **Development Effort** | Est-ce facile à construire ?               | Simple 🧩 ou complexe 🏗️ |

---