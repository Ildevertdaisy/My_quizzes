#1

---

## 🧠 L’idée générale

Dans la **communication synchrone**, un programme (appelé ici le **"SENDER"**, ou "celui qui envoie") envoie une question ou une commande à un autre programme (appelé le **"RECEIVER"**, ou "celui qui reçoit"). Et ensuite... il **attend la réponse** avant de faire quoi que ce soit d’autre.

💡 C’est un peu comme quand tu vas chez le médecin 👩‍⚕️ :

* Tu arrives,
* Tu dis : “Bonjour docteur, je suis là pour mon rendez-vous”,
* Et tu **attends qu’il te réponde** avant d’aller plus loin.

Tu ne vas pas visiter les autres salles, ni faire autre chose en même temps. Tu es **bloqué** tant que tu n’as pas la réponse.

---

## 🛑 Le mot important ici : **état bloqué (blocked state)**

Quand le sender attend une réponse, on dit qu’il est **bloqué** ⛔.
➡️ Cela veut dire qu’il ne peut **rien faire d’autre** tant qu’il n’a pas reçu ce qu’il attend.

🎯 Par exemple :

* Dans une **appli de paiement**, quand tu cliques sur "payer", le système envoie une demande à la banque.
  Il **attend la réponse** (“paiement validé ✅” ou “refusé ❌”) avant d’ouvrir l’écran suivant.

* Dans une **appli de scan de code-barres**, tu scannes le produit, et l’appli attend que le serveur lui renvoie le nom et le prix.
  Pendant ce temps, **elle ne scanne rien d’autre**. Elle est bloquée 🕓.

---

## 📱 Mais attention : pour que ça fonctionne, **les deux côtés doivent être prêts**

C’est ce que le texte appelle **“la précondition”** (la condition nécessaire).

👉 Pour que la communication synchrone marche :

* Le programme qui envoie le message (**le sender**) doit être actif et prêt à parler 📢,
* Et le programme qui reçoit le message (**le receiver**) doit être **disponible** pour écouter et répondre immédiatement 👂.

Sinon… la demande reste bloquée comme un appel sans réponse 📵.

---

## 🎮 Exemple dans un jeu vidéo

Imaginons un **jeu de puzzle multijoueur** :

* Tu envoies une demande pour dire “je veux commencer la partie”.
* Le serveur doit être prêt pour répondre “OK, tu peux jouer”.

➡️ Si le serveur n’est **pas prêt**, ton jeu reste **bloqué sur l’écran de chargement** 🕹️⏳.

---

## 📚 Résumé en mode histoire :

1. 📤 Le sender (comme une appli ou un capteur) **envoie une demande**.
2. 🛑 Il **attend la réponse** sans rien faire d’autre (il est bloqué).
3. 📥 Le receiver (comme un serveur ou un service) **doit être là** pour répondre tout de suite.
4. ✅ Quand la réponse arrive, le sender peut **continuer**.

---

## 💡 Ce qu’il faut retenir

* En communication **synchrone**, tout est une **question de timing** : il faut que les deux soient **prêts en même temps**.
* Le sender **ne peut pas faire autre chose** tant qu’il attend une réponse.
* C’est très utile quand il faut **vérifier une info rapidement et de façon sûre** (comme un mot de passe, un paiement, une autorisation).

---

#2


---

## 🧠 C’est quoi une communication **asynchrone** ?

Quand une appli ou un programme veut parler à un autre, il peut choisir de le faire **sans attendre la réponse tout de suite**. C’est ce qu’on appelle une **communication asynchrone**.

🧃 C’est comme si tu envoyais un message et que tu **continuais ta journée** sans rester bloqué à attendre qu’on te réponde.

---

## 🧺 Étapes simples :

1. Le programme (ou **SENDER**) envoie un message 📤
2. Il **ne reste pas bloqué**, il continue à faire d’autres choses (comme **Task A**, **Task B**, etc.) ✅
3. Plus tard, quand la réponse arrive, il la lit **à son rythme** 📬

---

## 📦 Exemple très simple du monde réel

### 📬 Exemple 1 : une commande sur un site

* Tu commandes une pizza 🍕 sur ton appli.
* Tu ne restes **pas figé** à l’écran. Tu peux :

  * Continuer à regarder une vidéo 🎬,
  * Aller dans une autre appli 📱,
  * Ou ranger ta chambre 🧹.
* Quand la pizza arrive, l’appli te prévient : “Le livreur est là !” 🛵

➡️ C’est **asynchrone** : tu fais autre chose pendant qu’on prépare la réponse.

---

## 📩 Autres exemples d’applis qui fonctionnent de cette façon :

* Une **appli de messagerie comme WhatsApp** 📱 : tu envoies un message, tu reçois une réponse plus tard.
* Une **appli de réservation de taxi** 🚕 : tu fais la demande, tu reçois une notification quand un chauffeur est trouvé.
* Une **appli de traitement photo** : tu envoies une image à modifier, puis tu es averti quand c’est prêt 📸.

---

## 🔧 En langage technique : on dit que le programme est **non bloqué**

Cela veut dire qu’il **n’attend pas sans rien faire**. Il peut **continuer à fonctionner** pendant qu’il attend une réponse.

🧠 Imagine un élève qui lève la main pour poser une question, mais pendant que la prof réfléchit, il **fait un exercice de maths**.
Il **ne reste pas immobile à attendre** — il est **efficace** 😉

---

## 🔄 Autre avantage important :

Les deux programmes (celui qui envoie et celui qui reçoit) **n’ont pas besoin d’être actifs exactement en même temps**.
➡️ Ils peuvent **travailler à leur rythme**, un peu comme une conversation par lettre postale ✉️ (plutôt qu’un appel en direct).

---

## 🧠 Résumé très simple :

| Action                     | Synchrone               | Asynchrone                     |
| -------------------------- | ----------------------- | ------------------------------ |
| J’envoie un message        | Et j’attends la réponse | Et je fais autre chose pendant |
| Je peux continuer à agir ? | ❌ Non (je suis bloqué)  | ✅ Oui (je suis libre)          |
| Exemple d’appli            | Appel vocal 📞          | Message WhatsApp 📱            |

---



#3


---

## 🧱 D’abord, qu’est-ce qu’un **protocole réseau** ?

Un protocole, c’est juste un **ensemble de règles** que les appareils et les applis suivent pour se parler sur Internet.

➡️ C’est comme un **langage commun** 📣 : pour bien se comprendre, il faut utiliser les mêmes mots et la même grammaire.

Par exemple :

* HTTP est un protocole très connu : il sert à **envoyer des pages web, des messages, des formulaires** 📄📨
* D’autres protocoles existent pour la musique, la vidéo, ou les jeux.

---

## 🧭 Est-ce que le protocole décide s’il faut attendre la réponse ?

Pas toujours !

Parfois, le protocole **laisse le choix** au programme ou à l’application.

🎯 C’est comme une boîte aux lettres 📮 : tu peux écrire une lettre urgente (tu attends la réponse) ou une carte postale (tu laisses la réponse venir plus tard).

---

## 💡 Exemple avec HTTP (le protocole le plus courant sur Internet)

HTTP fonctionne en mode **requête-réponse** (request-response) :

👉 Tu envoies une **demande** (comme “affiche-moi cette page” ou “envoie ce formulaire”),
👉 Et tu reçois une **réponse** (“voici la page”, ou “ta demande a bien été reçue”).

Mais cette réponse, tu peux :

* Soit **attendre** qu’elle arrive (synchrone) ⏳
* Soit **continuer à faire autre chose** pendant ce temps (asynchrone) ✅

---

## ⚙️ Deux façons d’utiliser HTTP selon l’outil choisi

### 1. **En JavaScript avec `fetch()`** : mode asynchrone

* Tu envoies une requête HTTP,
* Tu ne bloques pas ton programme,
* Tu continues à faire d’autres choses dans l’appli pendant que la réponse arrive.

💡 Exemple :

* Une **appli de liste de tâches** qui envoie une nouvelle tâche au serveur, mais te laisse continuer à écrire pendant que la réponse arrive. 📝📬

---

### 2. **Avec l’outil `curl`** : mode synchrone

* Tu envoies la même requête HTTP,
* Mais tu **attends que la réponse arrive** pour continuer,
* Le programme **reste bloqué** jusqu’à ce qu’il ait reçu ce qu’il attend.

💡 Exemple :

* Une personne utilise **curl** pour tester une page web.
  Elle tape une commande, et l’ordinateur **attend la réponse** avant de passer à la suite 🖥️🕓

---

## 🎯 Résumé très simple :

| Outil / méthode         | Type de communication | Que fait le programme ?             |
| ----------------------- | --------------------- | ----------------------------------- |
| `fetch()` (JavaScript)  | Asynchrone ✅          | Il envoie le message, puis continue |
| `curl` (outil en ligne) | Synchrone ⏳           | Il attend la réponse pour continuer |

---

## 🧠 Ce qu’il faut retenir :

* Le protocole (comme HTTP) **ne décide pas tout seul** si c’est synchrone ou asynchrone.
* C’est le **programme ou l’outil** qui décide **comment** utiliser le protocole.
* Certains outils préfèrent attendre (comme curl), d’autres préfèrent **ne pas bloquer** et avancer (comme fetch).

---



#4

---

## 📚 D’abord, c’est quoi une **API** ?

Une API (Interface de Programmation d’Application), c’est un **pont entre deux programmes** qui leur permet de **se parler facilement**.
➡️ C’est comme une **télécommande** 🕹️ : tu appuies sur un bouton, et la machine fait une action.

---

## 📜 Ce que dit ce passage (en version simple)

### 📅 L’idée d’API est **très ancienne**

Même si le mot “API” a commencé à être utilisé **dans les années 1960-1970**, l’idée **était déjà là dans les années 1940** !
Mais à l’époque, on ne l’appelait pas encore comme ça.

---

## 👨‍🔬 Qui a eu cette idée au tout début ?

Dans les années 1940 (juste après la Seconde Guerre mondiale), **trois chercheurs britanniques** ont travaillé sur une idée nouvelle :

* **Maurice Wilkes**
* **David Wheeler**
* **Stanley Gill**

Ils travaillaient sur un des **premiers ordinateurs** du monde 🌍, appelé **EDSAC** (c’est un nom compliqué pour une machine géante qui faisait des calculs 🖥️).

Ils ont écrit un **livre pionnier sur la programmation** : c’était comme le **premier manuel scolaire pour apprendre à coder** 📖💡.

---

## 🧩 Quelle était leur idée révolutionnaire ?

Ils ont eu l’idée de **créer des petits morceaux de programme réutilisables**, qu’on appelle aujourd’hui :

* **sous-programmes** (ou sous-routines),
* ou **fonctions**.

🧠 En langage simple, c’est comme faire des **blocs LEGO** 🧱 que tu peux **assembler** pour construire quelque chose.

### 🎯 Exemple :

Tu veux créer une **appli de photo** 📸 :

* Au lieu de tout recoder à chaque fois (comme : “appliquer un filtre” ou “redimensionner une image”),
* Tu appelles des **petites fonctions déjà prêtes**, comme :

  * `ajouter_un_filtre()`
  * `rogner_image()`

➡️ Ces fonctions sont des **interfaces** : tu les appelles, et elles font le travail pour toi.

---

## 💡 Pourquoi c’est considéré comme le début des APIs ?

Parce que ces **petits blocs de code** étaient pensés pour être **utilisables par d’autres programmes**, un peu comme des **commandes standardisées** 🛠️

Même si on ne disait pas encore “API”, leur idée était exactement ça :

> “Ne refais pas tout à zéro. Utilise une fonction déjà prête, et appelle-la avec les bons paramètres.”

---

## 🧠 Résumé comme une histoire pour enfants :

Il y a très longtemps (dans les années 1940), trois scientifiques ont eu une idée :
👉 “Et si, au lieu d’écrire tout le programme à la main, on créait des **boutons** que d’autres pourraient utiliser ?”

Ces boutons, aujourd’hui, on les appelle **APIs**.
Ils ont permis de **gagner du temps**, **éviter les erreurs**, et **faire communiquer des programmes entre eux**.

Grâce à eux :

* Une **appli météo** peut se connecter à un serveur pour obtenir les prévisions 🌤️,
* Une **appli bancaire** peut vérifier ton compte 🏦,
* Un **jeu mobile** peut se connecter à ton profil en ligne 🎮

---



#5


---

## 🧠 Ce que ce texte veut dire (version très simple)

### 💡 Tu n’as pas besoin de tout comprendre pour utiliser quelque chose

Imaginons que tu utilises **un mixeur** en cuisine 🥤.
Tu sais :

* Comment **l’allumer** (bouton ON),
* Où mettre les fruits 🍌🍓,
* Et qu’il va **faire un smoothie** si tu appuies sur le bon bouton.

Mais est-ce que tu sais **comment les lames tournent ?**
Ou **comment le moteur est fabriqué ?**
Pas besoin ! Tu peux **l’utiliser** sans savoir tout ce qu’il y a dedans.

👉 C’est exactement ce que dit ce texte, sauf qu’il parle **d’un petit programme informatique** (appelé ici **sous-programme**, ou **subroutine**).

---

### 📦 Une “subroutine”, c’est quoi ?

C’est une **petite boîte de code** toute prête qui fait une chose précise.

➡️ Par exemple, une appli de photo pourrait utiliser une subroutine pour :

* **flouter le fond**,
* **changer la couleur**,
* ou **ajouter du texte** sur une image.

Tu n’as **pas besoin de savoir** comment cette subroutine est construite à l’intérieur. Tu dois juste savoir :

* Ce qu’elle **fait** ✅
* Et **comment l’utiliser** (par exemple : en appuyant sur un bouton ou en donnant une instruction claire)

---

### 🛠️ Elle doit être écrite de façon **générale** (utilisable partout)

➡️ Pour que cette boîte de code soit vraiment utile, elle doit être faite **de façon souple** :
Comme un **outil qu’on peut utiliser dans plusieurs situations**, sans devoir le modifier à chaque fois 🧰

### 🎯 Exemple dans une appli :

Imaginons une appli de liste de tâches 📋 :

* Il existe une subroutine pour **ajouter une tâche**.
* Une autre pour **cocher une tâche comme "faite"**.
* Encore une pour **supprimer une tâche**.

Toutes ces petites fonctions sont **prêtes à l’emploi**.
Et peu importe que ton appli soit pour l’école, le travail, ou le shopping 🛒 — tu peux **les réutiliser partout** sans devoir les réécrire.

---

## 📚 En résumé très simple :

1. Un **petit bout de programme** (subroutine) peut être utilisé **sans tout comprendre**.
2. Il suffit qu’il y ait une **explication claire** (comme une notice) pour savoir **à quoi ça sert et comment l’utiliser**.
3. Pour être vraiment pratique, ce petit programme doit être **général**, c’est-à-dire **utilisable dans plein d’endroits différents**.
4. C’est exactement comme une **API** moderne aujourd’hui !

---

## 💡 Exemples d’applis actuelles utilisant cette idée :

* Une appli de **santé** qui utilise une API pour lire la fréquence cardiaque depuis une montre connectée ❤️⌚
* Une appli de **musique** qui utilise une API pour accéder aux chansons et aux albums 🎶
* Une appli de **banque** qui utilise une API pour afficher ton solde ou ton historique 📊
* Un **jeu mobile** qui utilise une API pour vérifier les scores ou envoyer les résultats 🎮

---



#6

---

## 🧮 L’ordinateur EDSAC : un géant avec des meubles, des câbles et des bandes !

### 🖼️ Sur l’image du haut :

Tu vois une grande machine qui prend **tout un mur**. C’est **EDSAC**, un des premiers ordinateurs du monde (1949–1950).

Ce gros “frigo à calculs” est composé de :

* **racks** (grandes armoires métalliques) qui servent à **stocker les données** et à **faire les calculs** 🔢
* Des **unités d’entrée et de sortie** (comme une imprimante et un lecteur de bandes) pour communiquer avec le programmeur 📤📥

📍 Sur la droite, tu vois une **petite machine encadrée** : c’est là qu’on **insère une bande papier** dans un lecteur, appelé **tapereader**.

Le tapereader lit les trous sur la bande (comme un code), puis envoie les résultats vers une **imprimante spéciale** qu’on appelait **teleprinter**.
Cette imprimante **écrit le résultat sur du papier** 🖨️🧾.

---

## 👩‍💻 Sur l’image du bas : la programmeuse et la bibliothèque de sous-programmes

Tu vois une femme (appelée ici **opératrice** ou **programmeuse**) assise à un bureau.

Elle utilise :

* un **clavier mécanique** (pas comme un clavier moderne),
* une **machine à perforer des bandes** : elle crée des **trous dans une bande papier**, pour y écrire les instructions 🧻🕳️.

Mais elle ne fait pas tout à la main. Elle peut :

1. Aller chercher des “blocs de code” déjà prêts (qu’on appelle **sous-programmes**, ou **subroutines**).
2. Les copier **automatiquement** depuis une **bibliothèque de bandes** (📦 une armoire remplie de rubans enroulés avec des codes dessus).
3. Les combiner avec son propre programme.

---

## 🧩 Que représente cette bibliothèque de bandes perforées ?

C’est exactement l’idée de ce qu’on appelle aujourd’hui une **API** :

* Un **code déjà prêt**,
* Bien organisé dans une “bibliothèque” (comme une appli ou un service web aujourd’hui),
* Qu’on **réutilise facilement** dans un autre programme, sans tout réécrire.

🎯 À l’époque, ce n’était pas un fichier informatique, c’était **une bande de papier trouée** !

---

## 💡 Comparaison moderne :

Imaginons une **appli de tâches** que tu développes :

* Tu ne vas pas recoder toi-même un système d’envoi de notifications 🔔.
* Tu utilises une API comme **Firebase** ou **OneSignal**.
* Tu appelles une fonction toute faite, comme `envoyer_notification()`.

➡️ C’est exactement comme ce que faisait cette opératrice avec ses bandes :

* Elle récupérait une fonction déjà prête (ex : “affiche un résultat”),
* Et elle la mettait dans son propre programme **sans toucher à l’intérieur**.

---

## 🎓 Résumé très simple

* L’ordinateur **EDSAC** utilisait des **bandes papier** trouées pour recevoir les programmes.
* Une programmeuse écrivait ses instructions à la main avec un clavier mécanique.
* Elle **réutilisait des sous-programmes** enregistrés sur d’autres bandes (comme des mini-blocs de code).
* C’était une forme **très ancienne d’API**, où on utilisait du code **sans devoir comprendre son fonctionnement complet**.
* C’est exactement ce qu’on fait aujourd’hui dans des applis comme :

  * Une appli de santé qui utilise une API pour lire le rythme cardiaque ❤️,
  * Une appli de messagerie qui utilise une API pour envoyer une image 📷,
  * Une appli de voyage qui utilise une API pour obtenir les horaires de train 🚆.

---



#7

---

## 📅 Qu’est-ce qu’il s’est passé en 1968 ?

Deux chercheurs en informatique, **Ira Cotton** et **Frank Greatorex**, ont écrit un article technique sur **les graphiques à distance** (c’est-à-dire des images générées par un ordinateur loin du lieu d’affichage).

Dans leur texte, ils utilisent pour la première fois l’expression **"application program interface"**, qui est l’ancêtre direct de notre mot **API** aujourd’hui.

---

## 🧠 Que voulait dire "application program interface" pour eux ?

Ils parlaient d’un système où :

* Une **application** (un programme comme un logiciel de dessin, de calcul ou de traitement de texte),
* pouvait **parler à l’ordinateur central**,
* en passant **par une interface** (un ensemble de règles ou d’outils qui facilitent cette discussion).

### 🧱 L’interface servait de **barrière intelligente** :

* Elle séparait **l’application** du **matériel** (comme les câbles, l’ordinateur physique, les écrans, etc.).
* Grâce à cette barrière, l’appli pouvait fonctionner même si **l’ordinateur était remplacé** 🧰🖥️

---

## 🧩 En langage très simple :

C’est comme si tu utilisais **une télécommande universelle** :

* Peu importe **la marque de ta télé** (Samsung, LG, Sony…),
* La télécommande **continue de fonctionner** si tu respectes les bons boutons.

➡️ Dans l’informatique, l’**API fait le même travail** : elle permet à ton programme de **fonctionner sans se soucier de ce qu’il y a derrière**.

---

## 💡 Exemple dans une appli actuelle :

Imagine une **appli de météo** 🌦️ :

* Elle utilise une API pour demander la température à un serveur météo.
* Tu changes de téléphone ? Tu passes d’un Android à un iPhone ?
  👉 L’API **fonctionne pareil**, car elle **ne dépend pas de l’appareil**.

Ou encore une **appli de santé** 🩺 qui mesure ton rythme cardiaque avec une montre :

* L’appli envoie une demande à l’API de la montre.
* Peu importe le modèle de montre (Fitbit, Apple Watch, Xiaomi…),
  l’appli reçoit les données **grâce à une interface standardisée**.

---

## 🧠 Pourquoi c’était révolutionnaire à l’époque ?

Avant ça, chaque programme était souvent **trop lié à un seul ordinateur**.
➡️ Si tu changeais de machine, il fallait **tout réécrire** 😫.

Mais avec cette idée d’**interface d’application (API)** :

* Les programmes sont **plus libres** 🧩
* Ils deviennent **compatibles avec plusieurs machines** 💻🖥️
* Et ça rend la création d’applications **beaucoup plus rapide et flexible** 🚀

---

## 🎯 Résumé très simple :

1. En 1968, deux chercheurs ont utilisé le mot **"application program interface"** pour parler d’un **pont entre un programme et un ordinateur**.
2. Ce pont permettait de **séparer le programme** du matériel (comme un mur magique entre eux).
3. Grâce à ça, on pouvait **changer d’ordinateur sans casser le programme**.
4. C’est le **début de l’API moderne** qu’on utilise aujourd’hui dans presque toutes les applis (météo, banque, jeux, livraison, etc.).

---



#8

---

## 📅 Que s’est-il passé dans les années 1970–1980 ?

C’est à cette période que les ordinateurs ont commencé à **être connectés entre eux** 🧷📡.
Avant ça, un programme tournait **sur une seule machine** : tout était **local** (dans le même ordi).

Mais avec les réseaux (ancêtres d’Internet), les développeurs ont commencé à se dire :

> “Et si je pouvais utiliser des programmes qui sont installés **sur d’autres ordinateurs**, ailleurs dans le réseau ?”

---

## 🧩 L’API a donc évolué…

Avant, une API servait surtout à **parler à un programme dans le même ordinateur**.
Mais maintenant, elle pouvait aussi :

* Envoyer une demande à **un autre ordinateur** 🖥️📤🖥️
* Et recevoir une réponse, même si le programme était très loin.

🎯 C’est comme si une appli sur ton téléphone **envoyait une question** à un serveur situé **dans un autre pays**, et que ce serveur faisait le travail, puis **renvoyait la réponse**.

---

## 📞 C’est là qu’arrive une nouvelle idée : **Remote Procedure Call (RPC)**

💡 **RPC** veut dire : “Appel de procédure à distance” (oui, c’est un peu technique).

Mais en langage simple, c’est comme :

> “Au lieu de faire une fonction ici, je vais demander à **un autre ordinateur** de faire le travail, puis de me donner la réponse.”

C’est comme commander une pizza 🍕 :

* Tu appelles un restaurant (le serveur distant),
* Tu dis : “Prépare une pizza pour moi”,
* Et tu reçois la pizza chez toi 📦

Même si **la cuisine est ailleurs**, tu l’utilises **comme si elle était dans ta propre maison**. C’est ça un **appel à distance**.

---

## 💡 Exemples actuels d’applis qui utilisent ce principe

1. **Une appli météo** :

   * Elle ne calcule pas elle-même la température.
   * Elle envoie une **requête** à un serveur distant, qui lui renvoie les données 🌦️

2. **Une appli bancaire** :

   * Elle t’affiche ton solde, mais c’est le **serveur de ta banque** qui va chercher les vrais chiffres 💰

3. **Une appli de traduction** :

   * Quand tu tapes une phrase, l’appli envoie la demande à **un serveur très puissant**, qui fait la traduction, puis renvoie le résultat en quelques secondes 🌐🈯

---

## 🧠 Résumé très simple :

| Avant les années 1970               | Après les années 1970 (réseaux)                |
| ----------------------------------- | ---------------------------------------------- |
| APIs = outils **dans le même ordi** | APIs = outils **qui peuvent vivre ailleurs**   |
| Tout se passe **localement**        | Une partie du travail est faite **à distance** |
| Pas besoin de réseau 🌐             | Utilisation du **réseau ou d’Internet** 📡     |

Grâce à cette évolution, les APIs sont devenues **connectées**, **plus puissantes**, et **partageables** entre machines dans le monde entier 🌍

---



#9

---

## 🧠 Le problème dans les années 1990

Dans les années 1990 :

* Il existait **plein de systèmes différents** (Windows, Unix, Mac…),
* Et **plein de langages de programmation** différents (C, Java, Python, etc.),
* Et pourtant… les gens voulaient que **tous ces programmes puissent communiquer entre eux**, même s’ils ne parlaient pas la même “langue”.

Imagine un groupe d’enfants dans une cour de récré :

* Un parle anglais 🇬🇧,
* Un autre parle espagnol 🇪🇸,
* Un troisième parle chinois 🇨🇳.

➡️ Si on veut qu’ils jouent ensemble, **il faut un traducteur commun**.

C’est exactement ce que va essayer de faire **CORBA**.

---

## 🔧 CORBA : un standard pour faire parler tout le monde

### Qui a créé ça ?

C’est un groupe appelé **OMG** (Object Management Group), une organisation qui crée des règles pour les logiciels 🧰.

Ils ont inventé **CORBA**, un système standard pour que les programmes :

* Peuvent **se comprendre** même s’ils sont écrits dans des langages différents,
* Peuvent **parler à distance**, via le réseau,
* Peuvent **agir sur des objets** (comme lancer une action, lire une info, ou modifier quelque chose), **peu importe où ils sont installés**.

---

## 🎮 Comparaison avec une appli de jeu

Imagine un **jeu multijoueur** 🎮 :

* Un joueur sur une tablette Android,
* Un autre sur un PC Windows,
* Et un troisième sur un vieux Mac.

➡️ Grâce à un système comme **CORBA**, chacun peut envoyer des actions (“je bouge”, “je saute”) et tous les autres reçoivent l’info **même si leur machine est différente**.

---

## 🧱 CORBA est **indépendant du langage**

Un des gros points forts de CORBA, c’est que :

* Il ne se soucie **pas du tout du langage utilisé** (C, Java, Python…),
* Il permet de **connecter** ces langages grâce à un outil intermédiaire (le “broker” = traducteur).

C’est comme avoir un assistant multilingue qui comprend tout le monde 🤖🗣️

---

## 📝 Et pour que tout soit clair, on utilise IDL

**IDL** (Interface Definition Language), c’est une **langue spéciale** pour décrire :

* Ce qu’un objet peut faire (comme des commandes),
* Comment on peut l’utiliser (comme une notice d’utilisation).

💡 Exemple :

* Dans une appli de banque 🏦, un objet peut être “compte utilisateur”.
* IDL permet de dire : ce compte peut “afficher le solde”, “faire un virement”, “changer le mot de passe”.

Et tout ça peut être **compris par différents systèmes** — même s’ils n’ont pas été créés ensemble au départ.

---

## 🧠 Résumé très simple :

| Élément         | En version facile                                                                 |
| --------------- | --------------------------------------------------------------------------------- |
| **CORBA**       | Un système pour faire parler différents ordinateurs et langages entre eux 🧩      |
| **OMG**         | Le groupe qui a inventé CORBA 👨‍🔧                                               |
| **IDL**         | Une “langue” pour décrire les fonctions disponibles, lisible par tout le monde 📄 |
| **Années 1990** | Période où on a dû faire **cohabiter des machines très différentes** 🖥️📡💻      |

---

## 💡 Exemples modernes qui s’inspirent de cette idée :

* Une **appli de gestion d’école** qui fait parler un logiciel de notes (en Java) et un logiciel de présence (en Python).
* Une **appli de santé** où les données du patient sont lues sur une tablette Android mais synchronisées avec un système hospitalier sous Windows.
* Une **plateforme de jeux** qui permet aux utilisateurs sur console, mobile, et PC de jouer ensemble en temps réel 🎮📱💻

---



#10


---

## 🧠 Le problème que Microsoft voulait résoudre

Dans les années 1990, il fallait que :

* des **programmes différents**,
* qui étaient parfois **installés sur la même machine** (pas forcément sur Internet),
* puissent **partager des fonctions** ou **travailler ensemble**.

Mais attention : ici, on parle de **programmes déjà traduits** pour l’ordinateur, qu’on appelle des **programmes binaires** (ce sont ceux qu’on installe et qui sont prêts à être exécutés, comme un jeu ou une appli).

➡️ Et ce n’est pas pareil que du “code source” (le code lisible par les humains, que les développeurs écrivent).

---

## 🧱 C’est là que Microsoft invente **COM**

**COM** veut dire *Component Object Model* (modèle d’objet par composants).

➡️ C’est un système imaginé par Microsoft pour que **des petits morceaux de programmes**, qu’on appelle **composants**, puissent :

* être partagés,
* appelés,
* et utilisés par **d’autres programmes**, même s’ils ne sont pas faits de la même manière 🧰

### 🎯 Exemple concret :

Tu utilises une **appli de traitement de texte** (comme Word),
et tu veux **afficher un tableau Excel dedans**.
➡️ COM permet à Word d’appeler un composant d’Excel **sans se soucier de comment Excel est construit**.

---

## 🧩 Et COM ne passe pas par une API classique, mais par une **ABI**

➡️ Une **ABI** (*Application Binary Interface*) est une **interface** qui ne travaille pas avec du texte ou du code source,
mais avec du **code binaire** (celui que l’ordinateur comprend directement 🧠💡).

C’est comme si :

* une **API**, c’est comme donner une recette en français que le chef va suivre 🧑‍🍳📖,
* une **ABI**, c’est comme envoyer le plat déjà prêt, avec la bonne forme, température, et boîte 📦🍝

---

## 🔄 Différence entre **API** et **ABI** (simplifiée)

| API (Application Programming Interface) | ABI (Application Binary Interface) |
| --------------------------------------- | ---------------------------------- |
| Fonctionne avec du code source 📝       | Fonctionne avec du code machine 🧠 |
| Indépendante du matériel 📦             | Dépend du matériel utilisé 🖥️     |
| Sert à connecter des **programmes**     | Sert à connecter des **binaries**  |

---

## 💡 Autres exemples modernes

* Un **jeu vidéo** qui utilise un moteur graphique (comme Unity ou Unreal Engine) appelle **des composants en binaire** via ABI.
* Une **appli Windows** qui ouvre un fichier PDF peut utiliser un composant Adobe, même s’il a été compilé différemment.
* Dans une **appli de photo**, si un effet de filtre (comme “noir et blanc”) est codé dans un composant binaire, le programme principal peut l’appeler grâce à **COM + ABI**.

---

## 📚 Résumé très simple

1. Microsoft invente **COM** pour faire parler des petits morceaux de programmes **déjà installés** sur un ordi 🖥️
2. Pour ça, ils utilisent une méthode appelée **ABI** (interface binaire), qui travaille **au plus bas niveau**, directement avec ce que l’ordi comprend.
3. Contrairement aux APIs classiques (qui parlent avec des mots clairs), les ABIs parlent avec du **code machine**.

C’est comme si deux robots se parlaient **par signaux lumineux** plutôt que par la voix : c’est plus rapide, mais plus difficile à lire pour un humain 🤖💡

---



#11

---

## 🧼 SOAP (Simple Object Access Protocol) : un protocole très strict et bavard

En 1998, on invente **SOAP**. Ce protocole est fait pour que deux programmes **échangent des messages** sur Internet.

### 💡 À quoi sert SOAP ?

➡️ SOAP permet à des **services web** (donc des programmes qu’on appelle à distance) de **s’envoyer des messages bien formatés**.

Il utilise surtout :

* **XML** : un langage très structuré (comme un gros formulaire avec des balises) 🧾
* Et **HTTP** (le protocole du web), ou parfois **SMTP** (le protocole utilisé pour les emails) 📬

---

### 📦 Exemple dans une appli :

Imaginons une **appli de livraison de colis** 📦 :

* Elle veut demander à un serveur : “Quel est le statut de mon colis ?”
* Le serveur lui répond avec un message XML : “Colis en route, livraison prévue lundi”

SOAP sert à **organiser** et **envoyer** ce genre de message.

---

### 😓 Pourquoi certains trouvaient SOAP compliqué ?

Même s’il fonctionne très bien, **SOAP a quelques défauts** :

1. Les messages sont **très longs et lourds** 🐢
2. C’est **lent à traiter** (le programme doit lire plein de balises XML avant de comprendre)
3. Il ne suit pas vraiment les règles simples du web (comme utiliser les adresses, les actions GET ou POST) 🌐

En gros, **ça marche**, mais **c’est compliqué**, surtout si tu veux faire une appli légère, rapide, et facile à maintenir.

---

## 🌐 REST (Representational State Transfer) : une idée plus simple pour les APIs modernes

En 2000, un chercheur nommé **Roy Fielding** propose une nouvelle approche : **REST**.

Il écrit ça dans une **thèse** (un travail de recherche universitaire) pour montrer qu’on peut :

* Utiliser **les règles simples du web** (comme les URL, les actions GET, POST, etc.),
* Pour **créer des APIs faciles à comprendre et rapides à utiliser**.

---

### 💡 REST, c’est comme utiliser les outils déjà là

Plutôt que de tout réinventer (comme SOAP le faisait), REST dit :

> “Utilisons ce que le web sait déjà faire”.

Tu fais une **demande avec une URL** :

* Pour **récupérer une image**, un produit, une recette, etc.
* Et tu reçois **la réponse directement**, dans un format simple (souvent JSON, un langage facile à lire par l’ordi).

---

### 🎯 Exemples modernes d’applis REST :

* Une **appli de météo** qui demande : `/meteo/paris` et reçoit une réponse : `"il fait 21°C"` 🌤️
* Une **appli de banque** qui va chercher la liste des paiements : `/utilisateur/123/paiements` 💳
* Une **appli de gestion de tâches** qui ajoute une nouvelle tâche avec une requête POST 📝

Tout ça est **très lisible**, rapide, et logique.

---

## 📚 Résumé très simple :

| Style d’API | Année | Fonctionne comment ?                       | Avantages / Inconvénients            |
| ----------- | ----- | ------------------------------------------ | ------------------------------------ |
| **SOAP**    | 1998  | Envoie des messages XML très structurés 🧾 | Très strict, mais lourd et lent 🐢   |
| **REST**    | 2000  | Utilise les règles simples du web 🌐       | Léger, rapide, facile à comprendre ✅ |

---

## 🎮 Analogie facile :

* SOAP, c’est comme envoyer une lettre avec **en-tête, cachet, signature, tampon, accusé de réception**... même pour dire “bonjour” ✉️📬
* REST, c’est comme **envoyer un SMS** : direct, simple, rapide 📲💬

---


#12

---

## 💡 Un petit rappel pour bien comprendre

* **REST**, inventé en 2000, est un style très utilisé pour créer des APIs simples et efficaces sur Internet 🌐.
* Une **API** permet à un programme d’utiliser des fonctionnalités d’un autre programme (comme envoyer un message, afficher une carte, ou payer).

---

## 🏢 Et si on utilisait des APIs **même à l’intérieur d’une entreprise** ?

C’est ce qu’Amazon a fait autour de l’an 2002.

👉 Le patron d’Amazon, **Jeff Bezos**, a envoyé une **note interne** (appelée ici un "memo") à tous les employés.
Il a dit : “À partir de maintenant, **toutes les équipes** doivent **communiquer entre elles uniquement via des APIs**.”

Et cette règle a été surnommée **l’API mandate** (l’ordre API).

---

## 🧩 Pourquoi cette règle était révolutionnaire ?

Avant ça, dans beaucoup d’entreprises, les équipes faisaient :

* Des systèmes qui **se parlaient directement**,
* Sans passer par des APIs.

Résultat :

* C’était souvent **compliqué à modifier**,
* Et **impossible à réutiliser** pour d’autres projets ou pour des gens en dehors de l’entreprise.

💬 Jeff Bezos voulait que **chaque service d’Amazon fonctionne comme une petite appli indépendante**,
qui **expose ce qu’elle fait via une API**, comme si elle parlait au reste du monde avec une langue claire et propre.

---

## 📜 Voici les 5 règles traduites en version très simple :

### 1. Les données et services doivent être **accessibles via des APIs** 🔓

> ➡️ Toute action (comme “ajouter un article au panier” ou “vérifier le stock”) doit passer par une API, même en interne.

---

### 2. Les services **doivent se parler uniquement par API** 🔄

> ➡️ Finis les raccourcis ou les accès directs au programme d’un autre service.
> C’est comme dire : "Tu veux que le service livraison t’aide ? Demande-lui via sa porte officielle (l’API)".

---

### 3. Aucune autre forme de communication n’est autorisée 🚫

> ➡️ Pas de triche : **pas de contournement**, tout doit passer par le même chemin.

---

### 4. Chaque API doit utiliser une **technologie adaptée au besoin** ⚙️

> ➡️ Pas besoin d’utiliser le même langage partout.
> Si une équipe a besoin de vitesse, elle peut choisir une technologie rapide.
> Si elle a besoin de clarté, elle peut utiliser quelque chose de simple.

---

### 5. Les APIs doivent être prêtes à être **ouvertes au public** 🌍

> ➡️ Même si l’API est d’abord faite pour un usage interne,
> elle doit être **claire, bien documentée et assez propre pour être utilisée plus tard par des gens à l’extérieur** (comme dans AWS, le cloud d’Amazon).

---

## 💡 Exemples actuels inspirés de cette méthode :

* Une **appli de livraison de repas** où le module “paiement” est une API à part, utilisée par d’autres applis (même celles d’autres entreprises).
* Un **jeu mobile** où les scores, les classements, les amis, les achats sont tous gérés par des APIs différentes.
* Une **plateforme scolaire** où chaque outil (devoirs, messagerie, emploi du temps) est un service séparé qui parle aux autres par API.

---

## 📚 Résumé comme une histoire :

En 2002, Amazon a dit :

> "Désormais, chaque équipe est un mini-serveur, avec **une API claire**, qui dit :
> ‘Voici ce que je fais, voilà comment tu peux me demander quelque chose.’

Et grâce à ça :

* Amazon a pu **scaler (grandir)** sans que tout s’écroule,
* Réutiliser ses outils pour créer **AWS (Amazon Web Services)**,
* Et **inspirer toute l’industrie tech** 🌐🚀

---



#13


---

## 📅 Le début des années 2000 : les APIs prennent leur envol 🚀

Dès le début du 21ᵉ siècle (autour de l’an 2000), **de plus en plus d’entreprises** se mettent à utiliser des APIs pour **faire communiquer leurs programmes entre eux**.

➡️ C’est un peu comme si, d’un seul coup, **chaque service**, chaque site, chaque appli, décidait de parler une langue **commune**, compréhensible et claire ✉️💬

---

## 🧠 Pourquoi appelle-t-on ça **l’âge des APIs** ?

Parce qu’en très peu de temps :

* Beaucoup de nouvelles **technos API** sont apparues 📦
* Les développeurs ont commencé à **connecter tous les systèmes entre eux**
* Et les entreprises ont pu **partager leurs outils**, même avec l’extérieur (comme Amazon, Google ou Stripe)

C’est un peu comme l’époque où **tout le monde s’est mis à avoir un téléphone portable** :
➡️ Du jour au lendemain, **tout devient plus facile à connecter** 📞📱

---

## 📊 Quelques grandes technologies d’API qui ont marqué cette période

### 1. **REST (2000)**

REST, c’est comme **le langage simple et rapide du web**.
Tu peux faire une requête à une URL (comme “/produits/chaussures”) et tu reçois une réponse.

💡 Exemple :

* Une **appli de shopping** utilise REST pour afficher les produits 🛍️

---

### 2. **Webhooks (2007)**

Un webhook, c’est comme une **alarme automatique**.
➡️ Quand quelque chose se passe (par exemple un paiement), l’API **envoie toute seule un message** pour prévenir une autre appli.

💡 Exemple :

* Une **appli de livraison** envoie un message à un autre service dès qu’un colis est prêt 📦🔔

---

### 3. **WebSocket (2011)**

WebSocket permet une **connexion continue** entre deux programmes, pour envoyer et recevoir des infos **en temps réel** 🕐↔️🕐

💡 Exemple :

* Un **jeu en ligne** ou une **appli de chat** utilise WebSocket pour voir les messages ou mouvements dès qu’ils se produisent 🎮💬

---

### 4. **GraphQL (2015)**

GraphQL permet de **poser une question très précise** et de recevoir **juste ce qu’on a demandé**, pas plus.

💡 Exemple :

* Une **appli de recettes** qui veut juste le nom et la photo, mais pas toute la fiche technique 🍲📷

---

### 5. **gRPC (2015)**

gRPC est une technologie pour les **applications très rapides et techniques**.
➡️ Elle est utilisée dans les systèmes qui doivent **échanger beaucoup d’informations très vite**, souvent entre machines.

💡 Exemple :

* Un **système de voiture connectée** ou une **appli industrielle** qui envoie des données chaque seconde 🚗📡

---

## 🎯 Résumé simple comme un tableau

| Technologie | Année | À quoi ça sert ? 🛠️                        | Exemple concret 📱           |
| ----------- | ----- | ------------------------------------------- | ---------------------------- |
| REST        | 2000  | Faire des requêtes simples via le web       | Liste de produits 🛒         |
| Webhooks    | 2007  | Être prévenu automatiquement d’un événement | Paiement, inscription 🔔     |
| WebSocket   | 2011  | Communication en direct, sans arrêt         | Chat en direct, jeux 🎮      |
| GraphQL     | 2015  | Demander exactement ce qu’on veut           | Sélection d’infos ciblées 📸 |
| gRPC        | 2015  | Échange rapide entre machines               | Véhicules connectés 🚗       |

---

## 📚 En résumé pour tous :

Depuis les années 2000, les APIs sont devenues **invisibles mais essentielles**.
Elles connectent tout :

* Ton **application de photos** 📷 à un serveur,
* Ton **montre connectée** ⌚ à ton téléphone,
* Ton **appli de transport** à la carte en ligne 🗺️,
* Ton **jeux vidéo** à un classement mondial 🎯

On appelle cette époque **l’ère des APIs**, car elles sont **partout**, comme l’air ou l’eau 💧

---



#14

---

## 🧠 Pourquoi c’est utile de savoir ce qu’est une API ?

Il y a des compétences qu’on appelle **“soft skills”** (ce sont les compétences douces, comme savoir bien parler, écouter les autres, ou travailler en équipe).

Ces compétences sont utiles **dans tous les métiers**.

Eh bien aujourd’hui, **connaître les APIs**, c’est un peu comme une **compétence technique universelle** dans le monde de l’informatique.

➡️ Même si tu ne deviens pas développeur, savoir comment une API fonctionne peut t’aider **dans plein de situations** !

---

## 👤 Pour un individu (toi, moi, n’importe qui)

Imaginons que tu cherches un travail :

* Si tu sais **comment utiliser une API** (même un peu), tu montres que tu sais **communiquer entre systèmes**, ou **automatiser des choses**.

💡 Par exemple :

* Dans une appli de voyage, tu pourrais relier les **horaires des trains** à ton tableau de bord.
* Dans une appli de comptabilité, tu peux faire venir les données bancaires **automatiquement** grâce à une API.

🎯 ➜ Tu fais **gagner du temps**, et tu montres que tu **comprends le monde connecté**.

---

## 👨‍💻 Pour un développeur ou un architecte logiciel

Si tu construis une appli, tu dois souvent :

* **connecter** ton appli à d’autres services (météo, carte, paiement…),
* ou **organiser ton propre code** pour qu’il soit facile à utiliser par d’autres.

➡️ Dans ce cas, savoir utiliser ou créer des APIs, c’est comme savoir **poser des briques solides pour construire une maison** 🧱🏠

💡 Exemple :

* Une **appli de photos** utilise l’API d’un service cloud pour stocker les images 📷☁️
* Une **appli de musique** utilise une API pour récupérer les titres d’un artiste 🎶

---

## 🏢 Pour une entreprise ou une organisation

Une entreprise veut que ses équipes :

* **travaillent ensemble facilement**, même si elles utilisent des outils différents,
* puissent **échanger des données** de manière claire, rapide, et sécurisée.

➡️ Les APIs permettent ça : chaque équipe peut **offrir ses services** (comme “ajouter un client”, “vérifier un stock”, “envoyer une facture”) **via une porte d’entrée bien définie**.

💡 Exemple :

* Une **entreprise de logistique** peut avoir une API interne pour suivre les colis 📦
* Une **école** peut avoir une API pour que les profs, élèves, et parents voient les devoirs en ligne 📚

---

## 🎯 Résumé simple :

* 📘 **Savoir utiliser une API**, c’est un peu comme **savoir utiliser un bon outil universel** : ça sert dans plein de métiers.
* 👤 Pour une personne seule : c’est une compétence utile à apprendre, comme parler anglais ou savoir faire une présentation.
* 👨‍💻 Pour un développeur : c’est la base pour connecter des programmes entre eux.
* 🏢 Pour une entreprise : c’est la clé pour **rendre les services flexibles, organisés, et partageables**.

---




#15

---

## 💬 Ce que ça veut dire (en version très simple)

Des experts (ici, **Gartner**, un groupe qui fait beaucoup d’études sur la technologie) ont demandé à plein d’entreprises :

> “Est-ce que vous allez embaucher des gens pour travailler avec des APIs ?”

➡️ Et **38%** (donc un peu plus d’**1 entreprise sur 3**) ont répondu :

> “Oui, on veut des développeurs qui savent faire ça !”

---

## 🧠 Pourquoi c’est un chiffre important ?

Ce chiffre montre que :

* Les APIs sont devenues **très importantes pour les entreprises**,

* Et que **de plus en plus de métiers** demandent au moins un peu de connaissances sur les APIs.

---

## 🧩 Et ça veut dire quoi pour toi, moi, ou quelqu’un qui apprend ?

C’est un peu comme si on disait :

> “Si tu sais comment fonctionnent les APIs, tu auras **plus de chances** de trouver un bon travail.”

🎯 Même si tu ne veux pas devenir un programmeur professionnel,
comprendre ce qu’est une API, et **comment l’utiliser**, peut **faire la différence**.

---

## 💡 Exemples de vraies applis où les APIs sont utilisées tous les jours :

* Une **appli de livraison** (comme Uber Eats ou Deliveroo) utilise des APIs pour :

  * montrer la carte,
  * calculer l’itinéraire du livreur,
  * confirmer le paiement 📍🛵💳

* Une **appli de santé** utilise des APIs pour :

  * récupérer les résultats de ton bracelet connecté,
  * lire les données de ton poids, ton sommeil ou ton rythme cardiaque 🩺⌚

* Une **appli de photo** peut appeler une API pour :

  * appliquer un filtre,
  * envoyer l’image dans le cloud ☁️📷

---

## 📚 En résumé très simple :

* Les APIs sont devenues **incontournables** pour plein de services modernes,
* **38% des entreprises** disent qu’elles veulent embaucher des gens qui savent les utiliser,
* Donc **apprendre les APIs**, c’est un **super atout**, peu importe ton métier.

---
