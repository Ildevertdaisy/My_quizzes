#1

---

## ğŸ§ª Le **fuzzing**, câ€™est une faÃ§on de tester une API **avec des donnÃ©es bizarres ou inattendues**

En plus du **contract testing** (oÃ¹ on vÃ©rifie si lâ€™API suit bien les rÃ¨gles prÃ©vues), il existe une autre mÃ©thode de test trÃ¨s utile appelÃ©e **fuzzing** (ou "test par bourrage", en version imagÃ©e ğŸ›ğŸ²).

---

## ğŸ² Comment Ã§a marche ?

ğŸ‘‰ Le **fuzzer** (câ€™est le programme qui fait le test) envoie Ã  lâ€™API **plein dâ€™entrÃ©es alÃ©atoires** :

* des textes Ã©tranges,
* des nombres trÃ¨s grands ou trÃ¨s petits,
* des infos inattendues, comme un emoji ğŸ™ Ã  la place dâ€™un prÃ©nom !

ğŸ’¡ *Exemples :*

* Dans une **appli de messagerie** ğŸ’¬, au lieu dâ€™envoyer â€œBonjourâ€, le fuzzer envoie â€œğŸ‘»ğŸ‘»ğŸ‘»ğŸ‘»ğŸ‘»â€.
* Dans une **appli de livraison**, il envoie un code postal de 200 chiffres pour voir si lâ€™API plante ou rÃ©agit bien.

---

## ğŸ’ª Lâ€™objectif ? Voir si **lâ€™API tient le choc** !

Lâ€™API est censÃ©e :

* soit **rÃ©pondre correctement** si elle comprend,
* soit **rÃ©agir proprement** si elle reÃ§oit quelque chose de mauvais (par exemple dire â€œErreur : entrÃ©e incorrecteâ€).

Mais elle ne doit **jamais planter complÃ¨tement** ou faire un truc dangereux âŒğŸ’¥.

Câ€™est comme tester si ton appli est **solide face aux bÃªtises quâ€™un utilisateur pourrait faire sans le vouloir** ğŸ˜….

---

## âš ï¸ Pourquoi câ€™est important ?

Parce que dans la vraie vie :

* les utilisateurs **font parfois des erreurs**,
* ou certains **essaient de faire planter le systÃ¨me exprÃ¨s** (comme des pirates informatiques ğŸ•µï¸â€â™‚ï¸).

Alors le **fuzzing** permet de **repÃ©rer ces failles Ã  lâ€™avance**.

---

## ğŸ§° Ces tests demandent des outils spÃ©ciaux

ğŸ‘‰ Le **fuzzing** et le **contract testing** sont ce quâ€™on appelle des **tests avancÃ©s** :

* Ils sont **plus complexes** que les tests de base,
* Et ils demandent **des outils professionnels** pour bien fonctionner.

Mais ils sont trÃ¨s utiles dans des applis sensibles, comme :

* une **appli mÃ©dicale** ğŸ¥,
* une **appli de sÃ©curitÃ© Ã  la maison** ğŸ ,
* ou une **appli bancaire** ğŸ’°.

---

## âœ… En rÃ©sumÃ© trÃ¨s simple :

* Le **fuzzing** consiste Ã  envoyer **plein de donnÃ©es bizarres ou imprÃ©vues** Ã  une API ğŸ²
* On vÃ©rifie si lâ€™API **rÃ©agit bien** ou si elle **plante**
* Câ€™est trÃ¨s utile pour tester la **soliditÃ©** dâ€™une API ğŸ’ª
* Câ€™est complÃ©mentaire du **contract testing**, et les deux sont des outils puissants pour faire des **tests avancÃ©s** ğŸ§ âš™ï¸

---

ğŸ¯ Câ€™est comme tester un toboggan en y faisant descendre **des objets de toutes formes** :

* petites balles âš½
* gros blocs ğŸ§±
* marshmallows ğŸ¬
  Le but : sâ€™assurer quâ€™il **ne se casse pas** et quâ€™il **rÃ©agit comme prÃ©vu**, peu importe ce quâ€™on lui envoie ğŸ˜„.


#2

---

## ğŸ§â€â™‚ï¸ğŸ” Le test **end-to-end**, câ€™est comme **imiter un vrai utilisateur** qui utilise lâ€™application du dÃ©but Ã  la fin

Quand on parle de **tests end-to-end** (on dit aussi E2E), on veut vÃ©rifier que **tout fonctionne dans lâ€™ensemble**, **comme si une vraie personne** utilisait le systÃ¨me.

ğŸ‘‰ Lâ€™idÃ©e, câ€™est de **tester lâ€™API ou lâ€™application complÃ¨te** en passant par **les mÃªmes Ã©tapes quâ€™un utilisateur normal**.

---

## ğŸ§  Pourquoi faire ce type de test ?

Parce que parfois, **chaque morceau du programme marche bien tout seul**,
mais quand on les met **ensemble**, **rien ne va plus** ğŸ˜…

ğŸ’¡ *Exemple dâ€™appli rÃ©elle :*
Imaginons une **appli de commande de pizza** ğŸ• :

1. Tu choisis une pizza.
2. Tu ajoutes une boisson.
3. Tu cliques sur â€œcommanderâ€.
4. Tu reÃ§ois la confirmation.

ğŸ‘‰ Un test end-to-end va **rejouer ces Ã©tapes** pour vÃ©rifier que **toute la chaÃ®ne fonctionne** â€” pas juste la partie qui affiche les pizzas ou celle qui envoie la commande.

---

## ğŸ¤– Avant, câ€™Ã©tait fait Ã  la mainâ€¦ maintenant on peut le faire automatiquement

Au dÃ©but, les dÃ©veloppeurs faisaient ces tests **manuellement**, comme un vrai utilisateur :

* en cliquant,
* en tapant,
* en regardant si Ã§a marche.

Mais maintenant, il existe **des outils** pour **automatiser tout Ã§a**, comme :

* **Cypress**
* **Playwright**
* **Selenium**

Ces outils peuvent :

* ouvrir une **fausse fenÃªtre de navigateur**,
* cliquer sur les boutons tout seuls,
* Ã©crire dans des formulaires,
* et **vÃ©rifier les rÃ©sultats** Ã  ta place ğŸ§‘â€ğŸ’»ğŸ§ª

---

## âš ï¸ Petit dÃ©tail important : parfois, ces tests sont un peu â€œcapricieuxâ€ ğŸ˜¬

On appelle Ã§a du **flaky testing** :
Cela veut dire que **parfois le test Ã©choue, mais sans vraie raison**.
Peut-Ãªtre que la page nâ€™a pas fini de charger, ou quâ€™un bouton met un peu trop de temps Ã  apparaÃ®tre.

ğŸ’¡ *Exemple dans une appli de rÃ©servation de billets* ğŸ« :
Un test clique trop vite avant que le bouton â€œValiderâ€ apparaisse, donc Ã§a **Ã©choue**, mÃªme si en vrai, lâ€™appli marche bien.

---

## âœ… En rÃ©sumÃ© trÃ¨s simple :

* Le test **end-to-end** vÃ©rifie si **tout le systÃ¨me fonctionne correctement**, du dÃ©but jusquâ€™Ã  la fin ğŸŒ
* Il simule **un vrai utilisateur** qui clique, tape, et navigue
* Avant, on faisait Ã§a Ã  la main ğŸ‘†, maintenant on peut utiliser **des outils automatiques** comme Cypress, Playwright ou Selenium âš™ï¸
* Câ€™est trÃ¨s utile dans **les applis complÃ¨tes**, comme :

  * une **appli de messagerie** ğŸ“±,
  * une **appli dâ€™achat de vÃªtements** ğŸ‘•,
  * ou une **appli pour organiser ses tÃ¢ches** ğŸ“‹
* Mais attention : **certains tests peuvent Ã©chouer pour des raisons un peu bizarres ou imprÃ©vues** ğŸŒ€

---

ğŸ¯ Câ€™est un peu comme **tester un toboggan entier** ğŸ› :
Tu montes, tu tâ€™assois, tu glisses, et tu arrives en bas.
Si une marche est cassÃ©e, ou que le sol est glissant Ã  lâ€™arrivÃ©e, tu le sauras **grÃ¢ce au test end-to-end** ! ğŸ˜„âœ…


#3

---

## ğŸ§ª Les tests en informatique, câ€™est un peu comme une **boÃ®te Ã  outils gÃ©ante**

Quand tu fabriques une application (comme une appli de jeux, de mÃ©tÃ©o, ou de photos), tu dois **vÃ©rifier quâ€™elle fonctionne bien**.
Mais comme il existe **plein de faÃ§ons diffÃ©rentes de tester**, on peut facilement **se perdre** ğŸ˜µ

ğŸ‘‰ Câ€™est pour Ã§a que des spÃ©cialistes ont inventÃ© une **carte en 4 parties**, pour **organiser tous les types de tests**.
On appelle Ã§a les **Agile Testing Quadrants**.

---

## ğŸ¯ Comment fonctionne cette â€œcarteâ€ Ã  4 coins ?

Câ€™est un carrÃ© divisÃ© en **4 zones**. Chaque coin (ou â€œquadrantâ€) correspond Ã  un **type de test** :

* En haut : tests **du point de vue de lâ€™utilisateur** (est-ce que lâ€™appli est agrÃ©able, utile ?)
* En bas : tests **du point de vue technique** (le code, les performances...)
* Ã€ gauche : tests pour **aider lâ€™Ã©quipe Ã  avancer**
* Ã€ droite : tests pour **critiquer, vÃ©rifier ce qui ne va pas**

Maintenant, voyons chaque coin plus en dÃ©tail ğŸ‘‡

---

### ğŸŸ¨ **Q1 â€“ Tests techniques pour aider lâ€™Ã©quipe (en bas Ã  gauche)**

ğŸ‘‰ Ici, on teste **le code lui-mÃªme**, petit morceau par petit morceau.

Ce sont :

* les **unit tests** (tests unitaires) : pour tester une toute petite fonction du code
* les **component tests** (tests de composants) : pour tester un bloc un peu plus gros, comme une section de page

ğŸ’¡ *Exemple :*
Dans une appli de tÃ¢ches ğŸ“‹, tu testes juste si **cocher une case** change bien lâ€™Ã©tat de la tÃ¢che.

---

### ğŸŸ© **Q2 â€“ Tests fonctionnels pour aider lâ€™Ã©quipe (en haut Ã  gauche)**

ğŸ‘‰ LÃ , on teste **comment les fonctions de lâ€™appli marchent ensemble**, en simulant des actions complÃ¨tes.

On y trouve :

* les **functional tests** (tests fonctionnels),
* les **prototypes** (versions dâ€™essai),
* les **simulations** (tester comme si on Ã©tait un vrai utilisateur).

ğŸ’¡ *Exemple :*
Dans une appli de livraison ğŸš´â€â™‚ï¸, tu simules : choisir une pizza + entrer lâ€™adresse + cliquer sur â€œcommanderâ€.

---

### ğŸŸ¦ **Q3 â€“ Tests manuels pour voir si lâ€™utilisateur est satisfait (en haut Ã  droite)**

ğŸ‘‰ Ici, ce sont des tests **faits Ã  la main**, pour voir si **lâ€™appli est agrÃ©able Ã  utiliser**.

On y trouve :

* les **tests alpha/bÃªta** (tests par des utilisateurs avant que lâ€™appli sorte),
* les **usability tests** (tests de facilitÃ© dâ€™utilisation),
* les **user acceptance tests** (lâ€™utilisateur dit si Ã§a lui convient).

ğŸ’¡ *Exemple :*
Tu demandes Ã  des Ã©lÃ¨ves de tester une appli de devoirs ğŸ“š : est-ce que câ€™est simple ? Est-ce que tout est comprÃ©hensible ? ğŸ˜ƒğŸ˜•âŒ

---

### ğŸŸ¥ **Q4 â€“ Tests techniques pour vÃ©rifier les limites du produit (en bas Ã  droite)**

ğŸ‘‰ LÃ , on teste **la soliditÃ© du systÃ¨me**, ce quâ€™on appelle les **tests non-fonctionnels** (ce nâ€™est pas â€œce que lâ€™appli faitâ€, mais â€œcomment elle le faitâ€).

On y trouve :

* les **performance tests** (lâ€™appli est-elle rapide ?),
* les **requirement tests** (est-ce que les rÃ¨gles imposÃ©es sont respectÃ©es ?)

ğŸ’¡ *Exemple :*
Une appli de streaming vidÃ©o ğŸ¥ : est-ce quâ€™elle supporte 10 000 personnes connectÃ©es en mÃªme temps sans planter ?

---

## âœ… RÃ©sumÃ© super simple :

| Quadrant | Ce quâ€™on teste              | Pourquoi                                                  |
| -------- | --------------------------- | --------------------------------------------------------- |
| Q1 ğŸŸ¨    | Le code, petit Ã  petit      | Pour que **chaque piÃ¨ce** fonctionne bien ğŸ§©              |
| Q2 ğŸŸ©    | Les fonctions complÃ¨tes     | Pour que **les actions de lâ€™utilisateur** marchent bien âœ… |
| Q3 ğŸŸ¦    | Le confort dâ€™usage          | Pour savoir si **les gens aiment** lâ€™utiliser ğŸ˜„          |
| Q4 ğŸŸ¥    | Les limites et performances | Pour vÃ©rifier si lâ€™appli est **rapide et solide** ğŸ’ª      |

---

ğŸ’¡ *Exemples dâ€™applis concernÃ©es :*

* **Appli de photos** ğŸ“¸ â†’ Q2 et Q3 : tester si on peut bien zoomer, partager, supprimerâ€¦
* **Jeu mobile** ğŸ® â†’ Q4 pour tester sâ€™il rame quand plein de joueurs sont connectÃ©s
* **Appli de planning familial** ğŸ—“ï¸ â†’ Q1 pour tester si les alarmes se dÃ©clenchent bien tous les jours

---

ğŸ¯ Le diagramme des quadrants aide les Ã©quipes Ã  **ne pas oublier un type de test**, et Ã  **tester Ã  tous les niveaux**, pas juste le code ou juste lâ€™apparence âœ¨.

Câ€™est comme vÃ©rifier un **manÃ¨ge de fÃªte** ğŸ¢ :

* Est-ce que les freins fonctionnent ? (Q1)
* Est-ce que le tour complet marche ? (Q2)
* Est-ce que les passagers aiment lâ€™expÃ©rience ? (Q3)
* Est-ce que Ã§a tient bien quand il y a du vent ou du monde ? (Q4)

Tout Ã§a, câ€™est du **testing agile bien organisÃ© !** ğŸ§ªğŸ§ âœ…


#4

---

## ğŸŸ¨ Q1 â€“ Les **tests techniques rapides**, pour aider les programmeurs

ğŸ‘‰ Ce type de test est fait **pour les dÃ©veloppeurs** (les personnes qui Ã©crivent le code).
Il est **automatisÃ©** (câ€™est une machine qui le fait toute seule), et **se concentre sur le code lui-mÃªme**.

On teste :

* des **petits morceaux de code** (unit tests),
* ou **des blocs plus gros** (component tests).

ğŸ’¡ *Exemple :*
Dans une **appli de recettes**, un test Q1 va juste vÃ©rifier si **la fonction qui calcule le temps de cuisson** donne le bon rÃ©sultat.

ğŸ¯ Pourquoi câ€™est utile ?
Parce que ces tests sont :

* **trÃ¨s rapides** Ã  faire,
* et donnent **un retour immÃ©diat**.
  Comme Ã§a, si une erreur apparaÃ®t, le dÃ©veloppeur la voit tout de suite et peut la corriger ğŸ› ï¸

---

## ğŸŸ© Q2 â€“ Les **tests sur les fonctions complÃ¨tes**, comme les utiliserait un vrai utilisateur

ğŸ‘‰ Ici, on teste lâ€™appli **comme si on Ã©tait un vrai utilisateur**.
Mais on le fait toujours **pour aider les dÃ©veloppeurs**, pas pour critiquer.

Ces tests vÃ©rifient que :

* **tout sâ€™enchaÃ®ne correctement**,
* les **objectifs des utilisateurs sont atteints**.

ğŸ’¡ *Exemple :*
Dans une **appli de livraison de colis** ğŸ“¦ :

* Tu veux tester si on peut vraiment **choisir une adresse, cliquer sur â€œenvoyerâ€, et voir la confirmation**.
* Câ€™est un test Q2, car il regarde **tout le parcours dâ€™un utilisateur normal**.

ğŸ§° Et si on ne peut pas le faire automatiquement ?
ğŸ‘‰ Alors on peut **le faire Ã  la main**, Ã©tape par Ã©tape.
Câ€™est un peu plus lent, mais Ã§a marche aussi ğŸ‘†

---

## âœ… En rÃ©sumÃ© super simple :

| Quadrant  | Ã€ quoi il sert                                                    | Pour qui                           | Comment il fonctionne               |
| --------- | ----------------------------------------------------------------- | ---------------------------------- | ----------------------------------- |
| **Q1** ğŸŸ¨ | Tester le **code**, petit Ã  petit                                 | Pour les **dÃ©veloppeurs**          | Automatiquement, trÃ¨s vite âš¡        |
| **Q2** ğŸŸ© | Tester **les fonctions complÃ¨tes** comme le ferait un utilisateur | Toujours pour les **dÃ©veloppeurs** | Automatiquement **ou** Ã  la main ğŸ‘¤ |

---

ğŸ’¡ *Exemples dâ€™applis oÃ¹ on utilise ces tests :*

* **Q1** dans une **appli de finances** ğŸ’° : tester si les calculs sont bons.
* **Q2** dans une **appli de rÃ©servation dâ€™hÃ´tel** ğŸ¨ : tester si on peut rÃ©server une chambre sans erreur.

---

ğŸ¯ Câ€™est un peu comme prÃ©parer un gÃ¢teau ğŸ° :

* **Q1** vÃ©rifie si **chaque ingrÃ©dient est bon sÃ©parÃ©ment**.
* **Q2** vÃ©rifie si **le gÃ¢teau est bien cuit du dÃ©but Ã  la fin**, et que **la recette marche pour les gourmands** ğŸ˜‹.

Ces deux types de tests sont essentiels pour **bÃ¢tir une application fiable** et agrÃ©able Ã  utiliser ğŸ’ªâœ….


#5

---

## ğŸŸ¦ Q3 â€“ Tester avec les yeux de lâ€™utilisateur, pour trouver ce quâ€™on a oubliÃ©

ğŸ‘‰ Dans ce coin (quâ€™on appelle â€œquadrant 3â€), on fait des tests **comme un vrai utilisateur**.
Mais au lieu dâ€™aider Ã  construire lâ€™application, ici on cherche plutÃ´t Ã  **trouver ce qui ne va pas** ğŸ•µï¸

On appelle Ã§a des tests de **critique produit** (Ã§a veut dire : â€œon regarde si quelque chose cloche ou manqueâ€).

---

### ğŸ“Œ Le test principal ici sâ€™appelle **UAT (User Acceptance Test)**

Câ€™est un test oÃ¹ un **utilisateur rÃ©el** ou un **client** essaye lâ€™application, pour voir si :

* Ã§a **fonctionne comme il le veut**,
* et si câ€™est **agrÃ©able Ã  utiliser**.

ğŸ’¡ *Exemple dans une appli de tÃ¢ches* ğŸ“ :
Tu demandes Ã  une personne de crÃ©er une tÃ¢che, de la modifier, de la supprimer.
Si elle te dit : â€œJe ne trouve pas le boutonâ€ ou â€œÃ‡a prend trop de clicsâ€, tu sais quâ€™il y a **quelque chose Ã  amÃ©liorer**.

ğŸ› ï¸ Ce genre de test est souvent **fait Ã  la main**, car **il faut observer** ce que fait la personne, et **Ã©couter ses rÃ©actions**.

---

## ğŸŸ¥ Q4 â€“ Tester la technique en profondeur, mÃªme ce quâ€™on ne voit pas

ğŸ‘‰ Dans le dernier coin (quadrant 4), on ne teste **pas ce que voit lâ€™utilisateur**, mais **ce quâ€™il ne voit pas** :

* la **rapiditÃ© de lâ€™application** âš¡,
* la **sÃ©curitÃ©** ğŸ”,
* la **fiabilitÃ©** (ne pas planter quand 1000 personnes se connectent en mÃªme temps !)

Ce sont les **tests non-fonctionnels**.
Ils ne testent pas *ce que fait lâ€™appli*, mais *comment elle le fait*.

ğŸ’¡ *Exemples dans une appli rÃ©elle :*

* Une **appli de photos** ğŸ“· : est-ce quâ€™elle ralentit quand on charge 300 images ?
* Une **appli bancaire** ğŸ’³ : est-ce quâ€™elle protÃ¨ge bien les donnÃ©es de lâ€™utilisateur ?
* Une **appli de jeu multijoueur** ğŸ® : est-ce quâ€™elle reste fluide quand 50 joueurs sont connectÃ©s ?

ğŸ‘¨â€ğŸ’» Ces tests sont souvent faits **avec des outils automatiques**, parce quâ€™ils demandent **des calculs prÃ©cis** et parfois **simulent des centaines dâ€™utilisateurs** en mÃªme temps.

---

## âœ… RÃ©sumÃ© trÃ¨s simple :

| Quadrant  | Qui regarde ?        | Ce quâ€™on vÃ©rifie                                         | Exemple dâ€™appli                      |
| --------- | -------------------- | -------------------------------------------------------- | ------------------------------------ |
| **Q3** ğŸŸ¦ | Lâ€™utilisateur rÃ©el   | Si **lâ€™expÃ©rience est bonne** et **rien nâ€™a Ã©tÃ© oubliÃ©** | Une appli de rÃ©servation de train ğŸš† |
| **Q4** ğŸŸ¥ | Un testeur technique | Si lâ€™appli est **rapide**, **sÃ»re**, **solide**          | Une appli de paiement mobile ğŸ’¸      |

---

ğŸ¯ Pour bien tester une application, il faut **voir ce que les gens ressentent quand ils lâ€™utilisent (Q3)**,
mais aussi **vÃ©rifier tout ce quâ€™il y a derriÃ¨re le rideau (Q4)** ğŸ§ âœ¨

Câ€™est un peu comme vÃ©rifier un rollercoaster ğŸ¢ :

* **Q3** â†’ â€œEst-ce que les gens sâ€™amusent et trouvent Ã§a cool ?â€
* **Q4** â†’ â€œEst-ce que les rails sont solides, les freins bien rÃ©glÃ©s et la sÃ©curitÃ© activÃ©e ?â€

Les deux sont indispensables pour un **produit vraiment rÃ©ussi** ğŸ’ªğŸ‰



#6

---

## ğŸ§­ Les 4 quadrants de test sont comme une **carte complÃ¨te** pour bien vÃ©rifier une application

Quand on construit une application â€” par exemple une appli de musique ğŸ§, une appli de recettes ğŸ³ ou une appli de gestion des devoirs ğŸ“š â€” on ne veut pas juste savoir si **elle sâ€™ouvre**.
ğŸ‘‰ On veut Ãªtre sÃ»r quâ€™elle :

* **fait bien ce quâ€™elle promet**,
* **marche bien techniquement**,
* et que les gens **aiment vraiment lâ€™utiliser** !

Câ€™est lÃ  que les **4 types de tests (Q1 Ã  Q4)** entrent en jeu. Chacun a **un rÃ´le prÃ©cis**, et ensemble ils forment une **stratÃ©gie complÃ¨te** pour tester correctement un logiciel ğŸ§ªâœ¨

---

## ğŸŸ¨ Q1 + ğŸŸ© Q2 â†’ Aider lâ€™Ã©quipe Ã  bien construire le produit

Ces deux coins servent surtout Ã  **aider les dÃ©veloppeurs** (les gens qui Ã©crivent le code).

Ils testent si lâ€™application respecte bien les **FRs** (Functional Requirements), câ€™est-Ã -dire :

> â€œEst-ce que lâ€™appli **fait ce quâ€™elle est censÃ©e faire** ?â€

ğŸ’¡ *Exemples dâ€™FRs* :

* Dans une **appli de shopping** ğŸ›ï¸ : on peut **ajouter un article au panier**.
* Dans une **appli de photo** ğŸ“· : on peut **recadrer une image**.

Q1 vÃ©rifie **petit bout par petit bout**,
Q2 vÃ©rifie **des enchaÃ®nements dâ€™actions complÃ¨tes**, comme un vrai utilisateur.

---

## ğŸŸ¦ Q3 + ğŸŸ¥ Q4 â†’ Critiquer le produit, voir si câ€™est agrÃ©able et solide

Ces deux coins servent Ã  **Ã©valuer ce quâ€™on a construit**, un peu comme un jury ğŸ‘€.

Ici, on teste les **NFRs** (Non-Functional Requirements), câ€™est-Ã -dire :

> â€œEst-ce que lâ€™appli est **rapide, stable, sÃ©curisÃ©e, et agrÃ©able Ã  utiliser** ?â€

ğŸ’¡ *Exemples dâ€™NFRs* :

* Est-ce que lâ€™appli **se charge en moins de 2 secondes** ? âš¡
* Est-ce quâ€™elle **protÃ¨ge les donnÃ©es personnelles** ? ğŸ”
* Est-ce que **les boutons sont bien visibles et faciles Ã  comprendre** ? ğŸ–±ï¸

Q3 teste **du point de vue de lâ€™utilisateur** (expÃ©rience humaine),
Q4 teste **le cÃ´tÃ© technique cachÃ©** (performance, sÃ©curitÃ©â€¦).

---

## âœ… En rÃ©sumÃ© trÃ¨s simple :

| Quadrants   | Ã€ quoi ils servent ?              | Ce quâ€™ils vÃ©rifient                                     |
| ----------- | --------------------------------- | ------------------------------------------------------- |
| Q1 + Q2 ğŸ› ï¸ | Aider Ã  **construire le produit** | Les **FRs** : Est-ce que Ã§a fait ce quâ€™on attend ?      |
| Q3 + Q4 ğŸ•µï¸ | Ã‰valuer le produit fini           | Les **NFRs** : Est-ce que câ€™est rapide, clair, fiable ? |

---

ğŸ¯ Les 4 quadrants forment un **plan complet de test** :
Ils permettent de sâ€™assurer que le logiciel est **fonctionnel**, **stable**, **facile Ã  utiliser**, et **prÃªt pour le monde rÃ©el** ğŸ§ ğŸš€

ğŸ’¡ Câ€™est comme construire une voiture ğŸš— :

* **Q1 et Q2** testent si les **roues tournent** et le **moteur fonctionne**,
* **Q3 et Q4** regardent si la **voiture est confortable**, **rapide**, **et ne tombe pas en panne**.

Avec ces 4 types de tests, tu construis **une application de qualitÃ©**, qui donne confiance aux utilisateurs ğŸ’ªğŸ˜Š.