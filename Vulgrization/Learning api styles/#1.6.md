#1

---

### 🌀 Le cycle de vie d'une API (explication très simple)

Quand on construit une application – comme une appli pour faire des listes de courses, un jeu vidéo, une appli pour écouter de la musique ou pour regarder des vidéos – on ne fait pas tout d’un coup. On suit des étapes, un peu comme quand on construit un LEGO en suivant un plan. Ce plan s'appelle dans le monde de l’informatique le **cycle de vie d’un logiciel**, ou **SDLC** (c’est l’abréviation en anglais de “Software Development Life Cycle”).

💡 Et une **API** (ça veut dire "interface de programmation", c’est un pont qui aide deux programmes à se parler, comme une télécommande pour commander une télé, ou comme une boîte aux lettres entre deux maisons), eh bien **c’est aussi un logiciel**, donc elle suit ce même chemin de construction. On peut dire que le **cycle de vie d’une API** est exactement le même que celui d’un logiciel normal.

---

### 📖 Voici comment on construit une API (comme on construit une application) :

1. **Planifier** (comme quand on réfléchit avant de créer un jeu ou une appli pour faire ses devoirs) 🧠

   * Par exemple, si tu veux faire une appli pour partager des photos de ton chat, tu vas d’abord réfléchir : “Qu’est-ce que mon appli va faire ?”, “De quoi elle aura besoin ?”

2. **Dessiner le plan (ou "concevoir")** 📝

   * Ici, tu dessines dans ta tête (ou sur papier) comment l’API va fonctionner. Tu imagines les boutons, les fonctions, les routes... Par exemple, il y aura un bouton pour envoyer une photo, un autre pour voir les photos des amis.

3. **Construire (ou "implémenter")** 🔨

   * C’est le moment où on programme l’API, on écrit les instructions. Comme quand tu écris les règles d’un jeu que tu inventes.

4. **Tester** 🧪

   * Avant de partager ton appli, tu vérifies que tout marche bien. Par exemple, tu t’assures que quand tu appuies sur le bouton “envoyer”, la photo s’envoie vraiment. Si quelque chose ne marche pas, tu corriges.

5. **Mettre en ligne (ou "déployer")** 🚀

   * Une fois que tout est prêt, on envoie l’API sur internet pour que tout le monde (ou les autres applis) puisse l’utiliser.

6. **Surveiller et réparer (ou "maintenir")** 🔧

   * Après que l’API est en ligne, il faut continuer à vérifier que tout fonctionne. Parfois, il y a des petits bugs (des erreurs) qu’il faut réparer, ou de nouvelles fonctions à ajouter.

7. **Retirer (ou "mettre à la retraite")** 🧓

   * Un jour, l’API ne sera plus utile. Peut-être que l’application de partage de photos n’est plus utilisée, ou qu’elle est remplacée par une nouvelle. Alors on la range au placard et on arrête de la faire fonctionner.

---

🎯 **À retenir** :
Même si tu ne suis pas toutes les étapes au pied de la lettre (comme si tu faisais ton propre jeu avec tes règles), connaître ces étapes t’aide beaucoup à ne pas te perdre quand tu travailles sur une application ou une API.

---

📘 Enfin, dans ton livre ou ton cours, on parle de la **"Figure 1-7"**. C’est juste une image ou un dessin qui montre toutes ces étapes du cycle de vie de l’API. Un peu comme une carte qui montre tout le chemin à suivre, depuis l’idée jusqu’au jour où on arrête de l’utiliser.

---

Si on devait comparer ça à quelque chose de la vie de tous les jours :
C’est comme créer une nouvelle recette de gâteau pour tes amis :

1. Tu penses à la recette 🍰
2. Tu notes les ingrédients et étapes 📝
3. Tu cuisines 👨‍🍳
4. Tu goûtes pour tester 😋
5. Tu partages le gâteau 🎉
6. Tu regardes si les amis l’aiment ou s’il faut améliorer 👀
7. Un jour, tu arrêtes de la faire et tu testes une nouvelle recette 😄

---


#2


---

### 🔄 Les étapes d’une API ne sont pas comme des blocs séparés

Souvent, quand on apprend comment une **API** (c’est comme une boîte magique qu’une application peut utiliser pour faire des choses, par exemple envoyer un message ou récupérer une photo 📷) est fabriquée, on pense que c’est comme une recette de cuisine : étape 1, puis étape 2, puis étape 3, etc.

Mais en vrai, **toutes les étapes sont un peu mélangées et se parlent entre elles**. C’est comme si tu faisais un gâteau 🍰, et en plein milieu, tu te rendais compte que tu voulais finalement rajouter du chocolat. Alors tu retournes à l’étape où tu choisis les ingrédients.

Par exemple :

* Si tu construis une **application de calendrier** pour noter tes devoirs 📅, tu pourrais d’abord penser à un design avec juste une page.
* Mais quand tu commences à **programmer** (la phase d’“implémentation” 👨‍💻), tu découvres que ce n’est pas très pratique.
* Du coup, tu changes ton idée de départ (la phase “design” 📝), pour ajouter une nouvelle page pour les tâches urgentes.

Cela montre que **les étapes ne sont pas toujours en ligne droite**. Elles peuvent se **croiser, revenir en arrière, ou avancer ensemble**, comme dans un jeu vidéo où tu peux revenir dans un niveau pour récupérer un objet que tu as oublié 🎮.

---

### 🧭 Et par où on commence ?

En plus, il n’y a **pas toujours une seule bonne façon de commencer**. Le **point de départ dépend du projet**. Parfois, tu peux commencer en **testant une idée rapidement**. D’autres fois, tu peux d’abord **discuter avec des amis ou ton équipe** pour bien réfléchir à ce que l’application doit faire.

Par exemple :

* Si tu fais une **appli pour noter tes repas préférés 🍔**, tu peux commencer directement par faire un petit test.
* Mais si tu travailles sur une **application de sécurité pour une école** 🏫, tu vas sûrement d’abord réfléchir longtemps avec d’autres personnes avant d’écrire une ligne.

---

### ✅ Ce qu’il faut retenir

* Les **étapes de création d’une API** sont **liées entre elles**, comme une toile d’araignée 🕸️.
* On peut **revenir en arrière ou changer les choses en cours de route**.
* Il **n’y a pas de point de départ fixe** : on commence là où ça a le plus de sens pour le projet.

Créer une API, c’est **comme inventer un jeu, cuisiner une recette ou construire une cabane** 🛠️ : on pense, on fait, on corrige, et parfois on recommence.

---



#3


---

### 🎡 L’API, comme une roue qui tourne

Créer une **API** (un outil que les applis utilisent pour se parler entre elles, comme une boîte aux lettres entre deux applis 📮) passe par plusieurs étapes. Ces étapes sont montrées ici comme un cercle, parce qu’on peut **revenir à certaines étapes**, **en sauter parfois**, ou **les répéter**. Ce n’est **pas toujours dans l’ordre**.

Imaginons qu’on veut construire une appli 📱 pour faire du tri dans ses vêtements. Tu pourrais prendre une photo d’un t-shirt, l’ajouter dans une liste, dire s’il est propre ou à donner. Cette appli aurait besoin d’une **API** pour que toutes les fonctions (ajouter, supprimer, classer) marchent ensemble.

Voici comment ça se passe :

---

### 1. **Planning (la planification)** 🧠

C’est comme faire un plan ou un dessin avant de construire une cabane.
On se pose plein de questions :

* À quoi va servir l’API ?
* Que devra-t-elle permettre de faire ?
* Qui va s’en servir (des apps de vêtements ? de revente ? d’organisation ?)

👕 *Exemple* : Dans l’appli de tri de vêtements, on veut que l’API aide à lister tous les habits qu’on a pris en photo.

---

### 2. **Design (la conception)** 🎨

Ici, on dessine avec précision comment l’API va fonctionner.
On pense à tous les boutons, les entrées, les sorties.
C’est comme si tu faisais les plans d’un robot que tu veux construire.

👕 *Exemple* : Tu imagines que l’API devra avoir une commande pour “ajouter une image”, une autre pour “voir les habits à donner”.

---

### 3. **Implementation (la fabrication)** 🔧

C’est le moment où on construit vraiment l’API.
On utilise des instructions informatiques pour dire à la machine quoi faire.

👕 *Exemple* : C’est ici qu’on “programme” la commande “ajouter un habit” pour que l’image soit bien enregistrée.

---

### 4. **Testing (les tests)** 🧪

On vérifie que tout fonctionne bien.
On essaie l’API comme si on jouait avec un nouveau jouet, pour voir s’il n’est pas cassé.

👕 *Exemple* : On teste si, quand on envoie une image, elle est bien enregistrée dans la liste des habits.

---

### 5. **Deployment (le lancement)** 🚀

Quand tout est prêt, on “envoie” l’API sur internet.
D’autres applications pourront alors l’utiliser.

👕 *Exemple* : Ton appli de tri de vêtements peut maintenant envoyer ses données à un site de dons.

---

### 6. **Maintenance (l’entretien)** 🔧

Même après le lancement, on continue de surveiller l’API.
Si quelque chose casse ou si on veut ajouter une nouvelle fonction, on revient ici.

👕 *Exemple* : On découvre que les photos sont floues. On modifie l’API pour qu’elle accepte des images plus nettes.

---

### 7. **Retirement (la fin de vie)** 🧓

Un jour, l’API n’est plus utilisée.
Soit on a une meilleure, soit elle n’est plus utile. Alors on l’éteint.

👕 *Exemple* : Si plus personne n’utilise l’appli de tri de vêtements, on peut retirer l’API.

---

### 📌 À retenir :

* C’est comme une **grande boucle** : parfois on revient à une étape précédente pour corriger, améliorer ou adapter 🌀.
* Ce cycle s’appelle aussi **SDLC** (Software Development Life Cycle), c’est-à-dire **le cycle de vie d’un logiciel**.
* Même si c’est pour une **API**, c’est **le même principe** qu’un projet normal, comme une appli de cuisine, une appli de sport ou un jeu de construction.

---

🎮 **Autres exemples** :

* Pour un **jeu de stratégie** : l’API peut servir à sauvegarder les scores, et on passe par toutes ces étapes.
* Pour une **application météo** : l’API doit récupérer les températures et les envoyer à ton écran.
* Pour une **appli de listes de tâches** : l’API garde en mémoire ce que tu dois faire et t’envoie des rappels.

---


#4

---

### 🔐 Deux éléments importants souvent oubliés : la **sécurité** et la **documentation**

Quand on regarde le **cycle de vie d’une API** (toutes les étapes pour la créer, l’utiliser, la tester, etc.), il y a **deux choses très importantes** qu’on ne voit **pas dans le dessin du cycle** :
👉 **la sécurité** (protéger les données)
👉 **la documentation** (les explications pour les humains)

---

### 📌 1. **La sécurité**, ce n’est pas juste une étape

Parfois, certains schémas montrent la **sécurité** comme une étape à part, comme si on s’en occupait juste à un moment, et puis c’est fini.
Mais en réalité, **la sécurité est présente tout le temps**, dans **chaque moment** du projet.

🛡️ **C’est comme si tu fabriques une maison**, et tu ne mets pas une seule serrure à la fin. Tu mets des **clés, serrures et alarmes** :

* Quand tu dessines la maison (design)
* Quand tu construis les murs (implémentation)
* Quand tu ouvres la porte à d’autres (déploiement)
* Quand tu fais les réparations (maintenance)

👀 *Exemple* : Imagine une **appli de santé** où tu peux noter tes symptômes ou tes allergies. Il faut que tes infos soient **protégées dès le début** :

* pendant qu’on réfléchit à ce que l’API va faire
* quand on l’écrit
* quand elle est en ligne
  Sinon, quelqu’un pourrait voir tes infos sans permission ❌.

Donc, **la sécurité est comme un super-héros invisible 🦸**, qui doit être là **à chaque moment du projet**, pas juste une fois.

---

### 📚 2. Et la documentation ?

La **documentation**, c’est un peu comme un **mode d’emploi** ou un **guide de l’API**.
Ça sert à **expliquer clairement comment utiliser l’API**, comme une recette pour ceux qui vont l’utiliser après.

👀 *Exemple* : Si tu fais une **appli de cuisine**, ton API pourrait permettre d’ajouter des recettes. La documentation va dire :

* “Voici comment on ajoute une recette”
* “Voici ce qu’il faut envoyer (le titre, la liste d’ingrédients, etc.)”
* “Voici ce que l’API renvoie (réponse)”

📘 Sans cette documentation, **les développeurs ne sauront pas comment s’en servir**, un peu comme avoir un jouet sans savoir où appuyer.

---

### 🧠 À retenir :

* La **sécurité** ne doit **jamais être mise de côté**. Elle doit **exister dans toutes les étapes** de la vie de l’API.
* La **documentation** est **essentielle** pour que les autres sachent **comment utiliser l’API sans se tromper**.

---

🧩 Même si ces deux éléments ne sont **pas toujours dessinés** dans le schéma du cycle de vie, ils sont **super importants** pour faire une API bien faite, fiable, et facile à utiliser, comme une bonne application pour :

* organiser ses devoirs 📚
* partager ses notes de cours 📝
* gérer une petite boutique en ligne 🛍️
* suivre les scores dans un tournoi de foot ⚽

Créer une API, ce n’est pas seulement “faire fonctionner” les choses. C’est aussi **protéger**, et **expliquer clairement** comment s’en servir. 💪✨


#5

---

### 📝 La documentation, ce n’est pas un truc à faire tout à la fin

Quand on crée une API (une sorte de “pont” entre deux applications pour qu’elles se comprennent), on doit aussi écrire une **documentation** — c’est comme un **mode d’emploi** pour dire à tout le monde comment s’en servir.

Mais certains projets **attendent la toute fin**, au moment de la **maintenance** (quand on surveille et répare l’API), pour écrire ce mode d’emploi.

🎯 Pourquoi ?
Ils se disent : “Tant que l’API n’est pas finie complètement, ça ne sert à rien d’écrire une explication, car tout peut encore changer.”

---

### ❌ Le problème avec cette idée…

C’est que **le projet n’est jamais vraiment totalement terminé**.
Les applis évoluent tout le temps. On rajoute des options, on modifie des choses…

Donc si on attend “la fin” pour écrire le mode d’emploi, on risque :

* soit de **ne jamais avoir le temps de le faire**,
* soit de l’**oublier complètement**,
* soit d’**écrire quelque chose qui ne correspond plus du tout à ce que fait l’API**.

---

### 🧃 Une meilleure solution ? Écrire un peu à chaque étape

Il vaut mieux **commencer à écrire la documentation dès le début**, même si ce n’est pas parfait. Et **continuer petit à petit**, à chaque étape.

👟 *Un peu comme quand tu crées un jeu de société* :

* Tu peux déjà noter les règles pendant que tu inventes le plateau 🧩,
* Puis tu ajoutes les détails quand tu fabriques les cartes 🎴,
* Et tu complètes encore quand tu testes avec des amis 🧪.

---

### 🧶 Un exemple très concret :

Imagine une **application pour ranger tes plantes** 🌱 :

* Tu prends en photo chaque plante,
* Tu ajoutes quand tu dois l’arroser,
* Tu reçois des rappels.

Tu crées une **API** pour que l’appli sache gérer les infos des plantes.
Si tu n’écris **aucune documentation pendant la création**, tu risques d’oublier comment marche la fonction “rappels” ou ce que signifient certains boutons. Et d’autres développeurs ne comprendront pas non plus 😵

Mais si tu écris un petit peu à chaque fois (“Cette fonction sert à enregistrer une nouvelle plante”, “Ici on programme le rappel d’arrosage”), alors tout sera clair 🧼.

---

### ✅ Ce qu’il faut retenir :

* La documentation (le guide) ne doit **pas attendre la fin**.
* Il vaut mieux **en écrire un peu à chaque moment**.
* Comme ça, on **gagne du temps** et **tout reste compréhensible**, même si l’API change en cours de route.

---

#6

---

### 🧠 La **planification**, c’est le moment où on réfléchit avant de foncer

Quand certaines personnes veulent créer une API (un outil pour que deux applis se parlent, comme une messagerie entre elles 📮), elles commencent **directement à écrire du code**, un peu comme si on construisait une cabane sans réfléchir à ce qu’on veut faire 🪵.

Mais **ce n’est pas une bonne idée**.

Avant de commencer à programmer, il faut passer par une étape très importante : **la planification**.

---

### 🗺️ La planification, c’est comme faire un plan ou une carte au trésor

Dans cette étape :

* On **décide à quoi va servir l’API** 🎯
* On **choisit les fonctions importantes** (qu’est-ce qu’elle doit savoir faire ?)
* On **réfléchit à qui va l’utiliser** (d’autres applis, d’autres personnes ?)

---

### 👟 Un exemple très simple :

Imaginons que tu veux créer une application pour **organiser un tournoi de foot** avec tes amis ⚽ :

* Ton API devra peut-être aider à **inscrire les joueurs**, **afficher les scores**, et **gérer les horaires des matchs**.

Si tu ne fais **aucun plan**, tu risques :

* d’oublier une fonction essentielle, comme “changer le nom d’une équipe”,
* de construire quelque chose qui ne convient pas du tout aux besoins des utilisateurs.

Mais si tu fais un bon **planning** avant de commencer :

* tu sais ce que tu veux,
* tu peux mieux organiser ton temps,
* et tu évites de devoir tout recommencer plus tard 🔁.

---

### 🚧 Ce que certains font mal...

Certains développeurs choisissent ce qu’on appelle une **approche "code-first"** (ça veut dire qu’ils **commencent tout de suite à écrire du code**, sans penser au plan).
Mais cela fait qu’ils **oublient des choses importantes** et que **le projet peut échouer** ou être très difficile à corriger ensuite.

---

### ✅ À retenir

* La **planification**, c’est **réfléchir avant d’agir**, comme dans un jeu d’échecs ou un projet scolaire 🎓.
* C’est à ce moment qu’on **prend toutes les décisions importantes** pour que l’API soit utile, claire, et réussie 🎉.
* Même si tu es pressé(e), **prendre le temps de planifier te fera gagner du temps plus tard** ⏳.

---



#7

---

### 🧱 La planification, c’est comme poser les briques d’une maison

Quand on construit une API (c’est une sorte de **chef d’orchestre invisible** qui aide une appli à parler avec une autre), la première étape importante, c’est de **préparer le terrain**.
On réfléchit à **tout ce qui doit être fait, pour qui, pourquoi, et dans quel ordre**.

C’est un peu comme quand tu veux créer :

* une **appli pour apprendre les langues** 📚,
* un **jeu d’énigmes** avec des niveaux à débloquer 🧩,
* ou une **appli de planning pour la famille** 👨‍👩‍👧‍👦.

Avant de créer, il faut **bien s’organiser**. C’est ce qu’on appelle **la planification**.

---

### 🗂️ Voici ce qu’on fait dans cette étape :

#### ✅ On définit :

* Le **but du projet** (ex. : “aider les gens à trouver une recette en fonction des ingrédients qu’ils ont dans le frigo” 🍅🧀),
* Les **dates importantes** (quand on commence, quand on veut que ce soit prêt ⏰),
* Ce qu’on veut **rendre à la fin** (ex. : une appli qui fonctionne sur téléphone 📱).

#### 👥 Qui participe ?

Des personnes différentes se réunissent :

* les **propriétaires du projet** (ceux qui ont l’idée),
* les **architectes logiciels** (ceux qui pensent à la structure),
* les **développeurs** (ceux qui écrivent les instructions).

Tout ce petit monde discute de **ce que l’API doit faire**, **qui va l’utiliser**, et **comment la rendre simple et rapide à utiliser**.

---

### 📎 On note aussi deux types de choses très importantes :

#### 1. **FR – Functional Requirements** (Besoins fonctionnels) 🛠️

Ce sont toutes les **actions que l’API doit savoir faire**.
💡 *Exemple* : Si on crée un **moteur de recherche pour une bibliothèque**, un besoin fonctionnel, c’est :

> “L’API doit permettre de chercher un livre en tapant un mot-clé.”

#### 2. **NFR – Non-Functional Requirements** (Besoins non fonctionnels) ⚙️

Ce sont les **qualités de l’API**. Ce n’est pas “ce qu’elle fait”, mais “comment elle le fait”.
💡 *Exemple* : Pour ce même moteur de recherche, un besoin non fonctionnel serait :

> “L’API doit répondre en moins d’1 seconde.”

C’est un peu comme dire :

* “Mon robot doit pouvoir faire la vaisselle” (FR) 🧽
* “Mais il ne doit pas faire trop de bruit” (NFR) 🤫

---

### 🎯 Pourquoi c’est super important ?

Parce que si on ne fait pas ça dès le début, on risque :

* de construire quelque chose qui **n’aide pas vraiment les utilisateurs**,
* ou de devoir **tout recommencer plus tard**.

Et si on oublie les **NFR**, l’appli peut marcher, mais être **trop lente**, **trop compliquée**, ou **pas agréable à utiliser**.

---

### 📌 À retenir :

* La planification, c’est **le moment où on prépare tout** avant de créer.
* On y décide :

  * **ce que l’API fera** (FR),
  * et **comment elle doit le faire** (NFR).
* C’est une étape **faite en équipe**, et **très utile** pour éviter les erreurs plus tard ⛑️.

---



#8

---

### 🧩 Il existe plusieurs sortes de "besoins" quand on crée un système

Quand on construit une API (c’est un outil invisible qui aide deux applis à **se comprendre et travailler ensemble** 📬), il faut d’abord savoir **ce qu’on veut qu’elle fasse**.

Ces envies ou attentes s’appellent des **besoins** (ou "requirements" en anglais). C’est **comme une liste de choses à respecter** dans un projet.

Et ces besoins peuvent venir de plusieurs endroits :

* de ceux qui vont utiliser l’appli (besoins utilisateurs),
* de l’entreprise ou de l’équipe (besoins business),
* de règles à respecter (comme des lois ou normes),
* de la manière de construire le système (architecture, technique...).

Mais pour bien s’organiser, on classe souvent tout ça en **deux grandes familles** :

---

### 🛠️ 1. Les **besoins fonctionnels (FR)**

Ce sont les choses **que l’API doit faire concrètement**.

💡 *Exemples :*

* Dans une **appli de recettes**, permettre aux gens de chercher une recette par ingrédient.
* Dans une **appli de transport**, permettre de réserver un ticket.
* Dans une **appli de jeux éducatifs**, permettre de voir le score et de passer au niveau suivant.

C’est un peu comme dire : “Mon robot doit savoir **parler**, **marcher** et **jouer de la musique**.”

---

### ⚙️ 2. Les **besoins non fonctionnels (NFR)**

Ce ne sont pas de nouvelles actions, mais des **règles de qualité** à respecter.

💡 *Exemples :*

* L’API doit répondre **en moins de 1 seconde**.
* L’API doit **fonctionner 24h/24**, sans coupure.
* L’API doit être **facile à comprendre et à modifier** plus tard.

C’est comme dire de ton robot :

> “Il doit **être silencieux**, **rapide**, et **ne pas tomber quand il bouge**.”

---

### 🧠 Pourquoi c’est important de séparer les deux ?

Quand on crée un projet, surtout une API, savoir faire cette différence permet de :

* **trier ce qui est le plus urgent à construire**,
* **organiser le travail des développeurs**,
* **prévenir les soucis** (par exemple, si l’API est lente, on le sait dès le début).

---

### 🕹️ Un exemple simple avec une appli de jeux vidéo 🎮

Imagine que tu fabriques une appli où on joue à un quiz en ligne :

* **Besoin fonctionnel** : L’API doit permettre d’envoyer les réponses du joueur et de calculer les points.
* **Besoin non fonctionnel** : L’API doit donner le résultat **en moins de 2 secondes**, sinon l’expérience devient frustrante 😠.

---

### ✅ En résumé :

* Il y a **plein de types de besoins** dans un projet, mais les **plus utilisés sont les fonctionnels (FR)** et les **non fonctionnels (NFR)**.
* Les **FR** disent **ce que l’API fait**.
* Les **NFR** disent **comment elle doit bien le faire**.
* C’est **essentiel dès le début** du projet, surtout dans les **trois premières étapes** (planification, design et développement).

---


#9

---

## 🧩 C’est quoi un "requirement" (besoin) dans un projet comme une API ?

Quand on fabrique une application (comme un jeu mobile 🎮, une appli de livraison 🍕 ou une appli pour faire sa liste de courses 🛒), on doit d’abord dire clairement **ce qu’elle doit faire** et **comment elle doit bien le faire**.

Ces choses-là, on les appelle des **“requirements”**, ce qui veut dire : **les besoins à respecter**.

Et on les sépare souvent en deux groupes :

* Les **FR (Functional Requirements)** ➜ Ce que le système doit faire concrètement 🛠️
* Les **NFR (Non-Functional Requirements)** ➜ Comment il doit le faire, avec quelle qualité 🎯

---

## ✅ Les **FR (besoins fonctionnels)** – Ce que l’appli doit savoir faire

Ce sont les **actions** ou **fonctions** que l’application ou l’API doit proposer.

🧠 Il y a deux façons de les voir :

* **Côté utilisateur** (toi, moi, un joueur, un client) 👤
  ➜ Par exemple : *"Je peux changer mon mot de passe."*
* **Côté système** (l’API elle-même ou le serveur) 🖥️
  ➜ Par exemple : *"Le système permet aux administrateurs de bloquer un compte."*

💡 *Exemples dans des applis réelles :*

* Une **appli de musique** 🎵 ➜ “L’utilisateur peut ajouter une chanson à sa playlist.”
* Une **appli de photos** 📷 ➜ “L’utilisateur peut supprimer une image de son album.”
* Une **appli pour les devoirs** 📝 ➜ “L’élève peut marquer un exercice comme terminé.”

---

## ⚙️ Les **NFR (besoins non fonctionnels)** – Comment l’appli doit se comporter

Ce ne sont pas de nouvelles actions. Ce sont des **règles de qualité** qui rendent l’appli agréable, rapide et sûre.

Ces besoins parlent de choses comme :

* La **rapidité** (ex. : “Le système doit répondre en moins de 1 seconde” ⏱️)
* La **disponibilité** (ex. : “L’application doit être accessible presque tout le temps, même la nuit 🌙”)
* La **sécurité** (ex. : “Les données doivent être bien protégées 🔒”)
* La **facilité de réparation** (ex. : “On doit pouvoir corriger un bug rapidement 🛠️”)
* La **facilité d’utilisation** (ex. : “Même un débutant peut comprendre comment ça marche 👶”)

📦 Dans le texte, on parle aussi des “*ilities*” (un mot drôle qui finit souvent par **-ility**), comme :

* *usability* ➜ la facilité d’usage
* *security* ➜ la sécurité
* *performance* ➜ la rapidité
* *maintainability* ➜ la facilité d’entretien
* *deployability* ➜ la capacité à être installée facilement

---

## 🎯 Pourquoi faire cette différence ?

Quand on prépare un projet (comme une **appli de covoiturage 🚗** ou une **appli de recettes 🍳**), dire ce que l’appli **fait** (FR) et **comment elle le fait bien** (NFR), aide à :

* mieux **organiser les idées**,
* **prioriser le travail** (commencer par les choses les plus importantes),
* **éviter les surprises** (comme une appli lente, pas claire ou peu fiable).

---

## 🧠 À retenir :

* Les **FR**, c’est le **quoi** ➜ ce que l’utilisateur ou le système peut faire.
* Les **NFR**, c’est le **comment** ➜ les règles de qualité à respecter.

📱 Que ce soit pour une appli de sport, un site de cinéma, un jeu éducatif ou un carnet de santé numérique, ces deux types de besoins sont **la base pour construire quelque chose de solide et utile** 🧱✨.


#10

---

## 😵‍💫 Parfois, la frontière entre FR et NFR n’est pas très claire...

Il y a deux grands types de besoins (ou "requirements") dans un projet informatique comme une API :

* **FR** (Functional Requirement) = ce que l’API doit **faire**
* **NFR** (Non-Functional Requirement) = **comment** elle doit bien le faire

Mais parfois… une phrase peut **rentrer dans les deux catégories en même temps** 🤔. Et c’est ce qu’on va expliquer ici avec un exemple.

---

## 🧪 L’exemple : un service météo dans une appli

Imaginons qu’on a une application qui donne des alertes météo ⛈️. Elle dit, par exemple :

> “Attention, tempête à venir !”

On peut écrire un besoin comme ça :
**“Le service envoie des alertes météo rapidement.”**

Mais attention ! Cette phrase contient **deux idées mélangées** :

---

### 🛠️ Partie 1 : Ce que fait l’API (FR)

🗯️ **“Le service envoie des alertes météo”**
👉 C’est une **action précise**. Donc, ça correspond à un **besoin fonctionnel (FR)**.
C’est ce que l’API **doit faire** : envoyer une alerte s’il y a un danger.

💡 *Exemple dans une appli météo :* Quand une forte pluie approche, l’appli **t’envoie une notification sur ton téléphone**. C’est une fonction.

---

### ⚙️ Partie 2 : Comment elle le fait (NFR)

🕒 **“Le service les envoie rapidement”**
👉 Là, on parle de **vitesse**. Donc c’est un **besoin non fonctionnel (NFR)**.
C’est **la qualité** du service : il doit **agir vite**, pas dans 10 minutes...

💡 *Exemple dans la vraie vie :* Si la pluie arrive dans 2 minutes, mais que l’appli t’envoie l’alerte après qu’il pleuve déjà... c’est trop tard ! 😅

---

## 🧠 Ce qu’il faut retenir

* Une **même phrase** peut parfois être **à la fois un FR et un NFR**.
* **FR** ➜ C’est **l’action** (envoyer une alerte).
* **NFR** ➜ C’est **la manière** (l’alerte arrive à temps ⏱️).

---

## 👀 Autres exemples dans d’autres applis :

* **Appli de livraison** 🍔

  * *FR* : Le client peut suivre son livreur.
  * *NFR* : Le suivi doit être mis à jour toutes les 5 secondes.

* **Appli de photos** 📸

  * *FR* : L’utilisateur peut supprimer une photo.
  * *NFR* : La suppression doit être instantanée, sans erreur.

* **Appli de listes de tâches** 📋

  * *FR* : L’utilisateur peut créer une nouvelle tâche.
  * *NFR* : La tâche doit être sauvegardée même si l’utilisateur n’a plus internet.

---

### ✨ Conclusion

Parfois, il n’y a **pas une séparation bien nette** entre ce qu’une application **fait** (FR) et **comment elle le fait bien** (NFR). Il faut juste regarder la phrase attentivement et **repérer les deux côtés** 💡. C’est comme une pièce avec deux faces : l’action et la qualité ✨.


#11

---

## 🤔 Quand on ne sait pas si c’est un FR ou un NFR…

Parfois, ce n’est **pas facile de savoir** si un besoin appartient à la famille des **FR** (les fonctions, ce que l’appli fait) ou à la famille des **NFR** (les qualités, comment elle fait les choses).

Mais pas de panique 😄 !
Pour t’aider à choisir, il suffit de **te poser quelques questions toutes simples**, comme un petit détective 🔍 :

---

### 1. 🎯 Est-ce que ce besoin demande **une action précise** de la part du système ?

👉 Si oui, c’est probablement un **FR**.
Exemple :

> “L’appli permet de créer un nouveau rendez-vous” dans un agenda numérique 🗓️
> 💡 → C’est une **fonction** que l’utilisateur va utiliser. C’est donc un **FR**.

---

### 2. 🏗️ Est-ce que ce besoin parle d’une **caractéristique de qualité** (une “-ilité”) ?

👉 Si oui, c’est sûrement un **NFR**.
Par “-ilité”, on veut dire tous les mots comme :

* *fiabilité* (le système ne plante pas),
* *sécurité* (les infos sont bien protégées 🔐),
* *performance* (le système est rapide ⚡),
* *utilisabilité* (l’interface est facile à comprendre 👶),
* *maintenabilité* (on peut corriger ou améliorer facilement 🛠️).

Exemple :

> “L’appli doit répondre en moins de 2 secondes.”
> 💡 → Ici, on ne parle pas d’une nouvelle fonction, mais de **la rapidité** de l’appli. C’est un **NFR**.

---

### 3. ⚙️ Est-ce que ce besoin oblige le système à **fonctionner d’une certaine façon** ?

👉 Si oui, ça ressemble aussi à un **NFR**.
Par exemple :

> “Le système doit envoyer les notifications en temps réel.”
> 💡 → Le mot “en temps réel” (très rapidement) parle de **comment** le système fonctionne. Encore un **NFR**.

---

### 4. 🔁 Est-ce que le besoin parle d’une **entrée** (quelque chose qu’on donne au système) ou d’une **sortie** (ce que le système renvoie) ?

👉 C’est souvent un **FR**.
Exemple :

> “L’utilisateur entre une ville, et l’appli affiche la météo.”
> 💡 → Il y a une entrée (la ville) et une sortie (la météo). Donc c’est un **FR**.

---

## 🧠 Et pourquoi c’est parfois dur à voir ?

Parce que les besoins **non fonctionnels (NFR)** agissent **en arrière-plan**, comme un **super assistant invisible 🦸**.
On ne les remarque **pas tout de suite**, mais **on s’en rend compte après un moment**.

Par exemple :

* Tu ouvres une **appli de transport 🚇**, et elle s’ouvre vite ➜ ça, c’est un NFR bien fait !
* Mais si un jour elle met **10 secondes à charger**, tu remarques que quelque chose **ne va pas**.

💡 ➜ Les effets des NFR apparaissent **dans la durée**, quand on utilise l’appli plusieurs fois.

---

## 📱 Exemples dans différentes applis du monde réel

### 📷 Appli de photos :

* “Supprimer une photo” ➜ FR (fonction)
* “La suppression doit être instantanée” ➜ NFR (vitesse)

### 📝 Appli de listes de tâches :

* “Ajouter une tâche” ➜ FR
* “Même sans internet, la tâche est enregistrée” ➜ NFR (fiabilité)

### 🚑 Appli médicale :

* “Afficher les données du patient” ➜ FR
* “Les données doivent être cryptées” ➜ NFR (sécurité)

---

### ✅ En résumé

Pour savoir si un besoin est **FR** ou **NFR**, demande-toi :

* Est-ce que c’est **une action** ? ➜ FR
* Est-ce que c’est une **qualité invisible** ? ➜ NFR
* Est-ce que ça parle **d’entrée ou de sortie** ? ➜ FR
* Est-ce que ça parle **de performance, sécurité, ou stabilité** ? ➜ NFR

Et n’oublie pas : **les FR se voient tout de suite**, mais les **NFR se ressentent dans le temps** ⏳✨.


#12

Parfait 😊 ! Voici une **explication très simple** du contenu de l’image, pour aider même les plus jeunes ou les débutants à comprendre **ce qu’on doit se demander pendant la planification d’une API**, c’est-à-dire avant de commencer à la construire.

---

## 🧠 Pendant la planification, on doit se poser des questions importantes

Avant de commencer à créer une API (c’est un **outil qui aide les applis à se parler entre elles**, comme un **messager invisible 📬**), on ne fonce pas tête baissée. On **prend le temps de réfléchir** à plein de choses.

Voici les **questions à se poser au départ**, pour bien préparer le terrain 👷 :

---

### 1. 🎯 Quelle est **la portée** de l’API ? (c’est-à-dire : pour qui elle est faite ?)

> Est-ce qu’elle sera **secrète**, utilisée seulement **à l’intérieur d’une entreprise** ?
> Ou est-ce qu’elle sera **publique**, accessible par **tout le monde** ?
> Ou bien, est-ce qu’elle est **partagée entre plusieurs organisations** qui travaillent ensemble ?

💡 *Exemples :*

* Une **appli de livraison interne dans un supermarché** 🛒 → API privée.
* Une **appli météo** utilisée par plein de gens dans le monde 🌍 → API publique.
* Une **appli d’échange de données médicales entre hôpitaux** 🏥 → API partagée entre partenaires.

---

### 2. 🖥️ Quels sont **les types d’appareils** qui vont utiliser l’API ?

> Est-ce que ce sont des téléphones ? des tablettes ? des objets connectés (comme des montres ou des frigos intelligents) ? des navigateurs web ? des consoles de jeux ?

💡 *Exemples :*

* Une **appli de commande vocale dans une maison connectée** 🏠 → utilisée par un appareil IoT (Internet of Things, c’est-à-dire un objet “intelligent”).
* Une **appli d’emploi du temps d’école** 📅 → utilisée par un navigateur web sur un ordi.
* Une **appli de jeux pour enfants** 🎮 → utilisée sur tablette.

Chaque appareil **n’a pas les mêmes besoins**, donc ça aide à bien préparer l’API.

---

### 3. 📜 Quels sont **les besoins techniques** de l’API ?

> Est-ce qu’on doit utiliser un langage précis (comme une langue que tout le monde comprend) ?
> Est-ce que l’API doit **répondre très vite** ?
> Est-ce qu’elle dépend d’autres services (par exemple, une autre API qui donne la météo) ?

💡 *Exemples :*

* Une **appli de traduction instantanée** 🗣️ → elle doit répondre très vite.
* Une **appli de carte routière** 🗺️ → elle doit se connecter à une autre API pour afficher les routes.
* Une **appli de contrôle parental** 👨‍👩‍👧‍👦 → elle doit être compatible avec certains outils déjà en place.

---

### 4. 📊 Quelle est **l’échelle prévue** ? (combien de personnes vont l’utiliser ?)

> Est-ce que l’API va être utilisée par **100 personnes**, ou **100 000** ?
> Est-ce qu’elle doit gérer beaucoup de demandes en même temps ?

💡 *Exemples :*

* Une **appli locale de bibliothèque de quartier** 📚 → peu d’utilisateurs.
* Une **appli de streaming musical** 🎵 → beaucoup d’utilisateurs connectés en même temps.
* Une **appli de gestion de transports publics** 🚍 → utilisée par des milliers de voyageurs chaque jour.

⚠️ Plus il y a de monde, plus il faut que l’API soit **robuste et rapide**, sinon ça peut **planter ou ralentir**.

---

## ✅ En résumé :

Avant de construire une API, il faut **réfléchir à 4 grandes choses** :

1. **À qui elle s’adresse** (privée, publique, partagée)
2. **Quels appareils vont s’en servir** (téléphone, frigo, site web…)
3. **Ce qu’elle doit faire techniquement** (rapidité, dépendances, règles)
4. **Combien de personnes vont l’utiliser** (et donc combien de demandes à gérer)

---

🔧 Comme quand on prépare une fête 🎉 :
Tu ne commences pas sans savoir **combien de gens viennent**, **où elle aura lieu**, **s’il faut de la musique ou non**, et **s’il faut cuisiner pour 5 ou pour 100** ! 😄

Créer une API, c’est pareil : on **planifie bien** pour éviter les mauvaises surprises 💡✨.


#13

---

## 🧠 Quand on prépare une API, il reste encore d’autres questions importantes

Tu sais maintenant qu’une API (un **pont invisible entre deux applis** 📡) doit être bien pensée avant d’être construite. Voici d’autres **questions à se poser** pour éviter les surprises plus tard :

---

### 1. 🧮 **Quelle version va-t-on utiliser pour l’API ?**

> Une **version**, c’est comme dire si l’API est à sa **première version** (v1), sa **deuxième** (v2), ou une **mise à jour spéciale**.

On peut utiliser deux styles :

* Une version avec des **nombres** (comme v1.2.3) → c’est ce qu’on appelle une **version sémantique**, très précise 📏.
* Une version avec une **date de sortie** (comme “API 2025-07-01”) 📅.

💡 *Exemple dans une appli de messagerie* :

* Si on ajoute les **appels vidéo** dans une nouvelle version de l’API, il faut **prévenir les développeurs** pour qu’ils utilisent la bonne version.

---

### 2. 🚦 **Est-ce qu’il y a des règles à respecter (comme des lois) ?**

Parfois, **on ne peut pas faire tout ce qu’on veut** avec une API, car il existe des **lois très strictes** qu’il faut suivre, surtout quand on **gère des données personnelles** (comme les noms, adresses, ou infos médicales).

Exemples de lois :

* **RGPD (GDPR)** : protège les **données personnelles** des gens en Europe 🇪🇺.
* **HIPAA** : protège les **données médicales** aux États-Unis 🇺🇸.

💡 *Exemple dans une appli de santé* 🏥 :

* L’API doit **masquer les informations sensibles** (comme les traitements ou maladies) si quelqu’un non autorisé essaie de les voir. Sinon, on **enfreint la loi** ❌.

---

### 3. 💬 **Comment les utilisateurs de l’API vont-ils apprendre à l’utiliser ?**

Il faut aussi penser à la **documentation** (c’est un **guide d’utilisation** pour expliquer comment fonctionne l’API, comme un mode d’emploi 📘).

Et on doit se poser deux questions :

* Où est-ce que ce guide sera **disponible** ? (sur un site web ? dans un fichier PDF ? dans un espace privé ?)
* Est-ce que tout le monde pourra le lire **librement**, ou seulement certaines personnes **autorisées** ?

💡 *Exemple dans une appli de gestion scolaire* 🎓 :

* Les **professeurs** peuvent avoir accès à une documentation plus complète que les **élèves**, car ils doivent faire plus de choses avec l’API.

---

## ✅ En résumé :

Avant de construire une API, pense aussi à :

1. Quelle **version** tu vas utiliser 🧾
2. Quelles **règles** ou **lois** il faut respecter ⚖️
3. Comment tu vas **expliquer aux autres comment s’en servir** 📖

---



#14

---

## 🧠 Avant de construire une API, il faut répondre à plusieurs questions importantes

Quand on veut créer une API (rappelle-toi, c’est une sorte de **pont numérique invisible** qui aide des applis à se parler entre elles 📡), on ne se jette pas tout de suite dans la programmation.

👉 Il faut **d’abord répondre à plein de questions**, comme on l’a vu avant :

* Pour qui l’API est faite ?
* Combien de personnes vont l’utiliser ?
* Est-ce qu’elle doit répondre vite ?
* Faut-il protéger des données personnelles ?

Tout ça fait partie de ce qu’on appelle la **planification**, un mot compliqué qui veut dire : “On réfléchit avant de faire.”

---

## 🛡️ Et pendant qu’on fait ce plan, il y a deux choses à ne jamais oublier :

### 1. La **sécurité** 🔒

C’est l’idée de **protéger les informations** et d’éviter que quelqu’un de mal intentionné puisse **voler des données** ou **faire des dégâts**.

💡 *Exemples* :

* Dans une **appli de banque**, on ne veut pas que n’importe qui voie ton solde 💰.
* Dans une **appli scolaire**, on ne veut pas qu’un élève change les notes d’un autre.

Donc dès le début, quand on imagine l’API, il faut penser à **comment la rendre sûre**.

---

### 2. La **conformité** ⚖️ (ou “compliance” en anglais)

C’est un mot difficile qui veut dire : **suivre les règles et les lois**.

💡 *Exemples* :

* En Europe, il y a une règle qui dit : “Tu dois demander la permission avant de collecter des données personnelles.”
* Aux États-Unis, dans la santé, il y a une loi qui dit : “Les infos médicales doivent être ultra protégées.”

Donc, quand tu construis une API, **tu dois respecter ces lois**. Tu ne peux pas juste dire : “J’ai envie de faire ça” — il faut que ce soit **autorisé**.

---

## 📌 Ce qu’il faut retenir :

* Avant de créer une API, **on réfléchit bien** à tout : pour qui ? comment ? avec quelles règles ?
* On pense à la **sécurité** dès le départ (et pas à la fin).
* On **respecte les lois**, surtout quand il y a des **données sensibles**.
* Tout cela fait partie du **travail de planification**, c’est-à-dire **préparer le terrain comme un architecte avant de construire une maison 🏗️**.

---

#15

---

## 🎨 La phase de **design**, c’est comme dessiner les plans d’une machine avant de la construire

Une fois qu’on a bien réfléchi à ce qu’on veut faire avec l’API (dans la phase de **planification**), il faut maintenant **imaginer comment on va construire cette API**.

Cette étape s’appelle la **conception** (ou *design* en anglais).
C’est le moment où les **architectes logiciels** (ceux qui réfléchissent à la forme du système 🏗️) et les **développeurs** (ceux qui vont l’écrire 👨‍💻) prennent des **décisions importantes**.

---

## 🧠 Ils se posent des questions comme :

### 1. **Qu’est-ce que l’API doit faire exactement ?**

Et **comment elle doit le faire ?**

💡 *Exemple dans une appli de livraison* 🍕 :

* L’API doit permettre d’**envoyer une commande** au restaurant.
* Mais aussi, **comment** cette commande est transmise (est-ce rapide ? est-ce clair ? est-ce sécurisé ?).

Donc ici, on pense **à la fonction** (envoyer la commande) **et à la manière** dont cette fonction est réalisée.

---

### 2. **À qui est destinée l’API ?**

On utilise ce qu’on a appris dans la phase de planification :

* Est-ce que ce sont des **téléphones**, des **montres connectées**, ou des **ordinateurs** qui vont l’utiliser ?
* Est-ce pour des **jeunes utilisateurs**, des **profs**, des **commerçants**, ou des **médecins** ?

💡 *Exemple dans une appli de gestion de santé* 🏥 :

* Si l’API est utilisée par des **médecins sur tablette**, on va faire en sorte que tout soit **clair, rapide, et sûr**.

---

### 3. **Quels outils et technologies allons-nous utiliser ?**

Comme quand tu construis une cabane : il faut choisir **les bons matériaux et les bons outils** 🔨🧱.

Les développeurs choisissent :

* **Quels logiciels** utiliser (des programmes déjà existants ou faits maison ?),
* **Quels outils de communication** entre l’API et d’autres services.

💡 *Exemple dans une appli de shopping en ligne* 🛍️ :

* L’API peut être **connectée à un service de paiement** déjà existant, au lieu de tout refaire depuis zéro.

---

## 🤝 Parfois, on utilise des outils d’autres personnes

Dans cette étape, on peut aussi décider de **ne pas tout faire soi-même**.
On peut utiliser des **services extérieurs**, déjà prêts, qu’on intègre dans notre projet.
On appelle ça des **solutions tierces** (ou “third-party solutions”).

💡 *Exemple dans une appli de vidéos* 📺 :

* On peut utiliser une API extérieure déjà faite pour **ajouter des sous-titres automatiques**.

---

## ✅ En résumé :

La phase de **design** sert à :

* Imaginer **comment construire l’API** 🎨
* Choisir **les outils**, **les fonctions**, et **la manière** dont tout va marcher ensemble ⚙️
* Décider **si on crée tout nous-mêmes**, ou si on **utilise des services déjà existants** 🤝

---

Comme quand tu veux créer ton propre **jeu de société**, cette phase consiste à :

* choisir les règles,
* dessiner les cartes,
* décider si tu fabriques les dés ou si tu prends ceux d’un autre jeu 🎲

Tout cela, c’est **le design**, et c’est **essentiel** pour que ton projet fonctionne bien et soit facile à utiliser 💡✨.